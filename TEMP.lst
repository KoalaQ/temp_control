Interrupt Vectors
    00000 940C 009C JMP	__text_start|__start
    00014 940C 08E9 JMP	_int_timer2
    0001C 940C 0898 JMP	_int_timer1
    00020 940C 084A JMP	_int_timer0
    0003A 940C 093A JMP	_int_timer3

Program Code (text area)
__text_start|__start:
    0009C EFCF      LDI	R28,0xFF
    0009D E1D0      LDI	R29,0x10
    0009E BFCD      OUT	0x3D,R28
    0009F BFDE      OUT	0x3E,R29
    000A0 51CE      SUBI	R28,0x1E
    000A1 40D0      SBCI	R29,0
    000A2 EA0A      LDI	R16,0xAA
    000A3 8308      ST	Y,R16
    000A4 2400      CLR	R0
    000A5 EAEB      LDI	R30,0xAB
    000A6 E0F1      LDI	R31,1
    000A7 E016      LDI	R17,6
    000A8 37E6      CPI	R30,0x76
    000A9 07F1      CPC	R31,R17
    000AA F011      BEQ	0x00AD
    000AB 9201      ST	Z+,R0
    000AC CFFB      RJMP	0x00A8
    000AD 8300      ST	Z,R16
    000AE E8EC      LDI	R30,0x8C
    000AF E0F0      LDI	R31,0
    000B0 E0A0      LDI	R26,0
    000B1 E0B1      LDI	R27,1
    000B2 E011      LDI	R17,1
    000B3 E000      LDI	R16,0
    000B4 BF0B      OUT	0x3B,R16
    000B5 33E7      CPI	R30,0x37
    000B6 07F1      CPC	R31,R17
    000B7 F021      BEQ	0x00BC
    000B8 95C8      LPM
    000B9 9631      ADIW	R30,1
    000BA 920D      ST	X+,R0
    000BB CFF9      RJMP	0x00B5
    000BC 940E 07D1 CALL	_main
_exit:
    000BE CFFF      RJMP	_exit
FILE: E:\ICCDemo\Temp_Control\temp_control\delay.c
(0001) #include<iom128v.h>
(0002) #include "delay.h"
(0003) 
(0004) 
(0005) void delay_us(uint n)//延时us
(0006) {
(0007)   n=2*n;
_delay_us:
  n                    --> R16
    000BF 0F00      LSL	R16
    000C0 1F11      ROL	R17
(0008)   do{ n--;
    000C1 5001      SUBI	R16,1
    000C2 4010      SBCI	R17,0
(0009)   }while(n>1);
    000C3 E081      LDI	R24,1
    000C4 E090      LDI	R25,0
    000C5 1780      CP	R24,R16
    000C6 0791      CPC	R25,R17
    000C7 F3C8      BCS	0x00C1
    000C8 9508      RET
_delay_ms:
  j                    --> R20
    000C9 934A      ST	-Y,R20
    000CA 935A      ST	-Y,R21
    000CB 01A8      MOVW	R20,R16
(0010) }
(0011) void delay_ms(uint j)//延时ms
(0012) {
(0013)    do{j--;
    000CC 5041      SUBI	R20,1
    000CD 4050      SBCI	R21,0
(0014)      delay_us(1141);
    000CE E705      LDI	R16,0x75
    000CF E014      LDI	R17,4
    000D0 DFEE      RCALL	_delay_us
(0015)    }while(j>1);
    000D1 E081      LDI	R24,1
    000D2 E090      LDI	R25,0
    000D3 1784      CP	R24,R20
    000D4 0795      CPC	R25,R21
    000D5 F3B0      BCS	0x00CC
    000D6 9159      LD	R21,Y+
    000D7 9149      LD	R20,Y+
    000D8 9508      RET
_delay_s:
  i                    --> R20
    000D9 934A      ST	-Y,R20
    000DA 935A      ST	-Y,R21
    000DB 01A8      MOVW	R20,R16
(0016) }
(0017) void delay_s(uint i)
(0018) {
(0019)    do{
(0020)    i--;
    000DC 5041      SUBI	R20,1
    000DD 4050      SBCI	R21,0
(0021)    delay_ms(1000);
    000DE EE08      LDI	R16,0xE8
    000DF E013      LDI	R17,3
    000E0 DFE8      RCALL	_delay_ms
(0022)    }while(i>1);
    000E1 E081      LDI	R24,1
    000E2 E090      LDI	R25,0
    000E3 1784      CP	R24,R20
    000E4 0795      CPC	R25,R21
    000E5 F3B0      BCS	0x00DC
    000E6 9159      LD	R21,Y+
    000E7 9149      LD	R20,Y+
    000E8 9508      RET
_Write1302:
  temp                 --> R10
  i                    --> R20
  dat                  --> R18
  addr                 --> R16
    000E9 92AA      ST	-Y,R10
    000EA 934A      ST	-Y,R20
FILE: E:\ICCDemo\Temp_Control\temp_control\time.c
(0001) #include<iom128v.h>
(0002) #include "time.h"
(0003) #include "delay.h"
(0004) #include "lcd.h"
(0005) //寄存器宏定义
(0006) #define WRITE_SECOND 0x80
(0007) #define WRITE_MINUTE 0x82 
(0008) #define WRITE_HOUR 0x84
(0009) #define WRITE_DAY 0x86
(0010) #define WRITE_MONTH 0x88 
(0011) #define WRITE_WEEK 0x8A
(0012) #define WRITE_YEAE 0x8C
(0013) #define WRITE_PROTECT 0x8E 
(0014) 
(0015) #define READ_SECOND 0x81 
(0016) #define READ_MINUTE 0x83 
(0017) #define READ_HOUR 0x85 
(0018) #define READ_DAY 0x87
(0019) #define READ_MONTH 0x89
(0020) #define READ_WEEK 0x8B
(0021) #define READ_YEAE 0x8D
(0022) #define READ_PROTECT 0x8F
(0023) 
(0024) 
(0025) #define  SCLK_H  PORTD|=1<<PD0 //
(0026) #define  SCLK_L  PORTD&=~(1<<PD0) //
(0027) #define  DIO    PORTD&(~(1<<PD1)) //会获得PB1的值，判断是否等于0来确定值
(0028) #define  DIO_H   PORTD|=1<<PD1 //
(0029) #define  DIO_L  PORTD&=~(1<<PD1)  //
(0030) #define  CE_H    PORTD|=1<<PD2
(0031) #define  CE_L   PORTD&=~(1<<PD2) 
(0032) //地址、数据发送子程序
(0033) void Write1302  ( unsigned char  addr,unsigned char dat )
(0034) { 
(0035)   unsigned char  i,temp; 
(0036)   CE_L; //CE引脚为低，数据传送中止
    000EB 9892      CBI	0x12,2
(0037)   SCLK_L;//清零时钟总线?
    000EC 9890      CBI	0x12,0
(0038)   CE_H;//CE引脚为高，逻辑控制有效
    000ED 9A92      SBI	0x12,2
(0039)   //发送地址?
(0040)     for ( i=8; i>0; i-- ) //循环8次移位
    000EE E048      LDI	R20,0x8
    000EF C00A      RJMP	0x00FA
(0041)     { 
(0042)        SCLK_L;
    000F0 9890      CBI	0x12,0
(0043) 	   temp=addr;
    000F1 2EA0      MOV	R10,R16
(0044)        if((temp&0x01))//每次传输低字节
    000F2 FF00      SBRS	R16,0
    000F3 C002      RJMP	0x00F6
(0045) 	   {
(0046) 	   	DIO_H;
    000F4 9A91      SBI	0x12,1
(0047) 	   }else{
    000F5 C001      RJMP	0x00F7
(0048) 	   DIO_L;
    000F6 9891      CBI	0x12,1
(0049) 	   }
(0050)        addr>>=1;//右移一位
    000F7 9506      LSR	R16
(0051) 			  SCLK_H;
    000F8 9A90      SBI	0x12,0
    000F9 954A      DEC	R20
    000FA E080      LDI	R24,0
    000FB 1784      CP	R24,R20
    000FC F398      BCS	0x00F0
(0052)  }
(0053) //发送数据?
(0054) for(i=8;i>0;i--){
    000FD E048      LDI	R20,0x8
    000FE C00A      RJMP	0x0109
(0055)    SCLK_L; 
    000FF 9890      CBI	0x12,0
(0056)    temp=dat;
    00100 2EA2      MOV	R10,R18
(0057)    if((temp&0x01))//每次传输低字节
    00101 FF20      SBRS	R18,0
    00102 C002      RJMP	0x0105
(0058) 	   {
(0059) 	   	DIO_H;
    00103 9A91      SBI	0x12,1
(0060) 	   }else{
    00104 C001      RJMP	0x0106
(0061) 	   DIO_L;
    00105 9891      CBI	0x12,1
(0062) 	   }
(0063) 	dat>>=1;
    00106 9526      LSR	R18
(0064)     SCLK_H;
    00107 9A90      SBI	0x12,0
    00108 954A      DEC	R20
    00109 E080      LDI	R24,0
    0010A 1784      CP	R24,R20
    0010B F398      BCS	0x00FF
(0065)   }
(0066)    CE_L;
    0010C 9892      CBI	0x12,2
    0010D 9149      LD	R20,Y+
    0010E 90A9      LD	R10,Y+
    0010F 9508      RET
_Read1302:
  data                 --> R10
  temp                 --> R14
  i                    --> R20
  addr                 --> R12
    00110 940E 112C CALL	push_xgset30FC
    00112 2EC0      MOV	R12,R16
(0067) }
(0068) //数据读取子程序
(0069) unsigned char Read1302( unsigned char addr ){
(0070)    unsigned char i,temp,data=0;
    00113 24AA      CLR	R10
(0071)    CE_L;
    00114 9892      CBI	0x12,2
(0072)    SCLK_L;
    00115 9890      CBI	0x12,0
(0073)    CE_H;//发送地址?
    00116 9A92      SBI	0x12,2
(0074)    for(i=8;i>0;i--)//循环8次移位
    00117 E048      LDI	R20,0x8
    00118 C00A      RJMP	0x0123
(0075)    {
(0076)       
(0077) 	   temp=addr;
    00119 2CEC      MOV	R14,R12
(0078)       if((temp&0x01))//每次传输低字节
    0011A FEC0      SBRS	R12,0
    0011B C002      RJMP	0x011E
(0079) 	   {
(0080) 	   	DIO_H;
    0011C 9A91      SBI	0x12,1
(0081) 	   }else{
    0011D C001      RJMP	0x011F
(0082) 	   DIO_L;
    0011E 9891      CBI	0x12,1
(0083) 	   }
(0084) 	   SCLK_L;
    0011F 9890      CBI	0x12,0
(0085)        addr>>=1;//右移一位
    00120 94C6      LSR	R12
(0086) 	  SCLK_H;
    00121 9A90      SBI	0x12,0
    00122 954A      DEC	R20
    00123 E080      LDI	R24,0
    00124 1784      CP	R24,R20
    00125 F398      BCS	0x0119
(0087)    }
(0088) //读取数据
(0089) DDRD&=0xFD;
    00126 B381      IN	R24,0x11
    00127 7F8D      ANDI	R24,0xFD
    00128 BB81      OUT	0x11,R24
(0090)  for(i=0;i<8;i++)
    00129 2744      CLR	R20
    0012A C00E      RJMP	0x0139
(0091)   {
(0092)      SCLK_H;
    0012B 9A90      SBI	0x12,0
(0093) 	 SCLK_L;
    0012C 9890      CBI	0x12,0
(0094) 	 delay_ms(1);
    0012D E001      LDI	R16,1
    0012E E010      LDI	R17,0
    0012F 940E 00C9 CALL	_delay_ms
(0095)    	 data |=(((PIND&(1<<PD1))>>1)<<i);
    00131 B300      IN	R16,0x10
    00132 7002      ANDI	R16,2
    00133 9506      LSR	R16
    00134 2F14      MOV	R17,R20
    00135 940E 117E CALL	lsl8
    00137 2AA0      OR	R10,R16
    00138 9543      INC	R20
    00139 3048      CPI	R20,0x8
    0013A F380      BCS	0x012B
(0096)            
(0097)     }
(0098) 	///PORTE=data;
(0099)    DDRD|=0x07;
    0013B B381      IN	R24,0x11
    0013C 6087      ORI	R24,7
    0013D BB81      OUT	0x11,R24
(0100)     CE_L;
    0013E 9892      CBI	0x12,2
(0101)     // temp = data>>4;
(0102)    // data &= 0x0f;
(0103)     //data = temp*10 + data;
(0104) 	
(0105)     return(data);
    0013F 2D0A      MOV	R16,R10
    00140 940C 1116 JMP	pop_xgset30FC
(0106) }
(0107) //初始化DS1302?
(0108) void Initial_time(void) {
(0109)    DDRD|=0x07;
_Initial_time:
    00142 B381      IN	R24,0x11
    00143 6087      ORI	R24,7
    00144 BB81      OUT	0x11,R24
(0110)    PORTD=0x00;
    00145 2422      CLR	R2
    00146 BA22      OUT	0x12,R2
(0111)   // Write1302(WRITE_PROTECT,0X00);//禁止写保护
(0112)    //Write1302(WRITE_SECOND,0x00);//秒位初始化
(0113)    //Write1302(WRITE_MINUTE,0x50);//分钟初始化
(0114)   // Write1302(WRITE_HOUR,0xa4);//小时初始化
(0115)    Write1302(WRITE_PROTECT,0x80);//写保护
    00147 E820      LDI	R18,0x80
    00148 E80E      LDI	R16,0x8E
    00149 CF9F      RJMP	_Write1302
_showTimeLcd:
    0014A 92AA      ST	-Y,R10
    0014B 934A      ST	-Y,R20
    0014C 9721      SBIW	R28,1
(0116) }
(0117) //显示时间，时分秒
(0118) void showTimeLcd(void){
(0119)    //PORTE=~Read1302(0x81);
(0120) 	if(Read1302(0x85)&0x80){
    0014D E805      LDI	R16,0x85
    0014E DFC1      RCALL	_Read1302
    0014F FF07      SBRS	R16,7
    00150 C048      RJMP	0x0199
(0121) 	if( (Read1302(0x85)>>4)&0x01 )
    00151 E805      LDI	R16,0x85
    00152 DFBD      RCALL	_Read1302
    00153 2F80      MOV	R24,R16
    00154 9582      SWAP	R24
    00155 708F      ANDI	R24,0xF
    00156 7081      ANDI	R24,1
    00157 F0B9      BEQ	0x016F
(0122) 	{
(0123) 	 lcd_write_char(0x00,1,0x30|((Read1302(0x85)>>4)&0x01));
    00158 E805      LDI	R16,0x85
    00159 DFB6      RCALL	_Read1302
    0015A 2EA0      MOV	R10,R16
    0015B 2D8A      MOV	R24,R10
    0015C 9582      SWAP	R24
    0015D 708F      ANDI	R24,0xF
    0015E 7081      ANDI	R24,1
    0015F 6380      ORI	R24,0x30
    00160 8388      ST	Y,R24
    00161 E021      LDI	R18,1
    00162 2700      CLR	R16
    00163 940E 049C CALL	_lcd_write_char
(0124) 	 lcd_write_char_con(1,0x30|(Read1302(0x85)&0x0F));
    00165 E805      LDI	R16,0x85
    00166 DFA9      RCALL	_Read1302
    00167 2F40      MOV	R20,R16
    00168 2F24      MOV	R18,R20
    00169 702F      ANDI	R18,0xF
    0016A 6320      ORI	R18,0x30
    0016B E001      LDI	R16,1
    0016C 940E 046A CALL	_lcd_write_char_con
(0125) 	}else{
    0016E C00F      RJMP	0x017E
(0126) 	 lcd_write_char(0x00,1,' ' );
    0016F E280      LDI	R24,0x20
    00170 8388      ST	Y,R24
    00171 E021      LDI	R18,1
    00172 2700      CLR	R16
    00173 940E 049C CALL	_lcd_write_char
(0127) 	 lcd_write_char_con(1,0x30|(Read1302(0x85)&0x0F));
    00175 E805      LDI	R16,0x85
    00176 DF99      RCALL	_Read1302
    00177 2F40      MOV	R20,R16
    00178 2F24      MOV	R18,R20
    00179 702F      ANDI	R18,0xF
    0017A 6320      ORI	R18,0x30
    0017B E001      LDI	R16,1
    0017C 940E 046A CALL	_lcd_write_char_con
(0128) 	}
(0129) 
(0130) 	   if(((Read1302(0x85))&0x20)){
    0017E E805      LDI	R16,0x85
    0017F DF90      RCALL	_Read1302
    00180 2EA0      MOV	R10,R16
    00181 FF05      SBRS	R16,5
    00182 C00B      RJMP	0x018E
(0131) 	      lcd_write_char(0x05,1, 'P');
    00183 E580      LDI	R24,0x50
    00184 8388      ST	Y,R24
    00185 E021      LDI	R18,1
    00186 E005      LDI	R16,5
    00187 940E 049C CALL	_lcd_write_char
(0132) 	     lcd_write_char_con(1, 'M');
    00189 E42D      LDI	R18,0x4D
    0018A E001      LDI	R16,1
    0018B 940E 046A CALL	_lcd_write_char_con
(0133) 	   }else{
    0018D C021      RJMP	0x01AF
(0134) 	     lcd_write_char(0x05,1, 'A');
    0018E E481      LDI	R24,0x41
    0018F 8388      ST	Y,R24
    00190 E021      LDI	R18,1
    00191 E005      LDI	R16,5
    00192 940E 049C CALL	_lcd_write_char
(0135) 	     lcd_write_char_con(1, 'M');
    00194 E42D      LDI	R18,0x4D
    00195 E001      LDI	R16,1
    00196 940E 046A CALL	_lcd_write_char_con
(0136) 	    }
(0137) 	}else{
    00198 C016      RJMP	0x01AF
(0138) 	 lcd_write_char(0x00,1, 0x30|((Read1302(0x85)>>4)&0x03));
    00199 E805      LDI	R16,0x85
    0019A DF75      RCALL	_Read1302
    0019B 2EA0      MOV	R10,R16
    0019C 2D8A      MOV	R24,R10
    0019D 9582      SWAP	R24
    0019E 708F      ANDI	R24,0xF
    0019F 7083      ANDI	R24,3
    001A0 6380      ORI	R24,0x30
    001A1 8388      ST	Y,R24
    001A2 E021      LDI	R18,1
    001A3 2700      CLR	R16
    001A4 940E 049C CALL	_lcd_write_char
(0139) 	 lcd_write_char_con(1,0x30|(Read1302(0x85)&0x0F)); 
    001A6 E805      LDI	R16,0x85
    001A7 DF68      RCALL	_Read1302
    001A8 2F40      MOV	R20,R16
    001A9 2F24      MOV	R18,R20
    001AA 702F      ANDI	R18,0xF
    001AB 6320      ORI	R18,0x30
    001AC E001      LDI	R16,1
    001AD 940E 046A CALL	_lcd_write_char_con
(0140) 	}
(0141) 	
(0142) 	lcd_write_char(0x01,1,':');
    001AF E38A      LDI	R24,0x3A
    001B0 8388      ST	Y,R24
    001B1 E021      LDI	R18,1
    001B2 E001      LDI	R16,1
    001B3 940E 049C CALL	_lcd_write_char
(0143) 	
(0144) 	lcd_write_char_con(1, 0x30|Read1302(0x83)>>4);
    001B5 E803      LDI	R16,0x83
    001B6 DF59      RCALL	_Read1302
    001B7 2EA0      MOV	R10,R16
    001B8 2D2A      MOV	R18,R10
    001B9 9522      SWAP	R18
    001BA 702F      ANDI	R18,0xF
    001BB 6320      ORI	R18,0x30
    001BC E001      LDI	R16,1
    001BD 940E 046A CALL	_lcd_write_char_con
(0145) 	lcd_write_char_con(1,0x30|(Read1302(0x83)&0x0F));
    001BF E803      LDI	R16,0x83
    001C0 DF4F      RCALL	_Read1302
    001C1 2F40      MOV	R20,R16
    001C2 2F24      MOV	R18,R20
    001C3 702F      ANDI	R18,0xF
    001C4 6320      ORI	R18,0x30
    001C5 E001      LDI	R16,1
    001C6 940E 046A CALL	_lcd_write_char_con
(0146) 
(0147) 	lcd_write_char_con(1,':');
    001C8 E32A      LDI	R18,0x3A
    001C9 E001      LDI	R16,1
    001CA 940E 046A CALL	_lcd_write_char_con
(0148) 	
(0149) 	 lcd_write_char_con(1, 0x30|(Read1302(0x81)>>4));
    001CC E801      LDI	R16,0x81
    001CD DF42      RCALL	_Read1302
    001CE 2EA0      MOV	R10,R16
    001CF 2D2A      MOV	R18,R10
    001D0 9522      SWAP	R18
    001D1 702F      ANDI	R18,0xF
    001D2 6320      ORI	R18,0x30
    001D3 E001      LDI	R16,1
    001D4 940E 046A CALL	_lcd_write_char_con
(0150) 	lcd_write_char_con(1,0x30|(Read1302(0x81)&0x0F));
    001D6 E801      LDI	R16,0x81
    001D7 DF38      RCALL	_Read1302
    001D8 2F40      MOV	R20,R16
    001D9 2F24      MOV	R18,R20
    001DA 702F      ANDI	R18,0xF
    001DB 6320      ORI	R18,0x30
    001DC E001      LDI	R16,1
    001DD 940E 046A CALL	_lcd_write_char_con
    001DF 9621      ADIW	R28,1
    001E0 9149      LD	R20,Y+
    001E1 90A9      LD	R10,Y+
    001E2 9508      RET
_showTime_page:
    001E3 92AA      ST	-Y,R10
    001E4 934A      ST	-Y,R20
(0151) }
(0152) 
(0153) //显示时间，年月日时分秒，用于page调用。没有改变AC，会接着写
(0154) void showTime_page(void){
(0155)    //PORTE=~Read1302(0x81);
(0156)    //年
(0157)     lcd_write_str_con(1, "20");
    001E5 E020      LDI	R18,0
    001E6 E031      LDI	R19,1
    001E7 E001      LDI	R16,1
    001E8 940E 050C CALL	_lcd_write_str_con
(0158)     lcd_write_char_con(1, 0x30|((Read1302(0x8D)>>4)&0x0F));
    001EA E80D      LDI	R16,0x8D
    001EB DF24      RCALL	_Read1302
    001EC 2F20      MOV	R18,R16
    001ED 9522      SWAP	R18
    001EE 702F      ANDI	R18,0xF
    001EF 702F      ANDI	R18,0xF
    001F0 6320      ORI	R18,0x30
    001F1 E001      LDI	R16,1
    001F2 940E 046A CALL	_lcd_write_char_con
(0159)     lcd_write_char_con(1,0x30|(Read1302(0x8D)&0x0F)); 
    001F4 E80D      LDI	R16,0x8D
    001F5 DF1A      RCALL	_Read1302
    001F6 2F20      MOV	R18,R16
    001F7 702F      ANDI	R18,0xF
    001F8 6320      ORI	R18,0x30
    001F9 E001      LDI	R16,1
    001FA 940E 046A CALL	_lcd_write_char_con
(0160) 	lcd_write_char_con(1,'-');
    001FC E22D      LDI	R18,0x2D
    001FD E001      LDI	R16,1
    001FE 940E 046A CALL	_lcd_write_char_con
(0161) 	 //月
(0162) 	 lcd_write_char_con(1, 0x30|((Read1302(0x89)>>4)&0x01));
    00200 E809      LDI	R16,0x89
    00201 DF0E      RCALL	_Read1302
    00202 2EA0      MOV	R10,R16
    00203 2D2A      MOV	R18,R10
    00204 9522      SWAP	R18
    00205 702F      ANDI	R18,0xF
    00206 7021      ANDI	R18,1
    00207 6320      ORI	R18,0x30
    00208 E001      LDI	R16,1
    00209 940E 046A CALL	_lcd_write_char_con
(0163)      lcd_write_char_con(1,0x30|(Read1302(0x89)&0x0F)); 
    0020B E809      LDI	R16,0x89
    0020C DF03      RCALL	_Read1302
    0020D 2F40      MOV	R20,R16
    0020E 2F24      MOV	R18,R20
    0020F 702F      ANDI	R18,0xF
    00210 6320      ORI	R18,0x30
    00211 E001      LDI	R16,1
    00212 940E 046A CALL	_lcd_write_char_con
(0164) 	 lcd_write_char_con(1,'-');
    00214 E22D      LDI	R18,0x2D
    00215 E001      LDI	R16,1
    00216 940E 046A CALL	_lcd_write_char_con
(0165) 	 //日
(0166) 	 lcd_write_char_con(1, 0x30|((Read1302(0x87)>>4)&0x03));
    00218 E807      LDI	R16,0x87
    00219 DEF6      RCALL	_Read1302
    0021A 2EA0      MOV	R10,R16
    0021B 2D2A      MOV	R18,R10
    0021C 9522      SWAP	R18
    0021D 702F      ANDI	R18,0xF
    0021E 7023      ANDI	R18,3
    0021F 6320      ORI	R18,0x30
    00220 E001      LDI	R16,1
    00221 940E 046A CALL	_lcd_write_char_con
(0167)      lcd_write_char_con(1,0x30|(Read1302(0x87)&0x0F)); 
    00223 E807      LDI	R16,0x87
    00224 DEEB      RCALL	_Read1302
    00225 2F40      MOV	R20,R16
    00226 2F24      MOV	R18,R20
    00227 702F      ANDI	R18,0xF
    00228 6320      ORI	R18,0x30
    00229 E001      LDI	R16,1
    0022A 940E 046A CALL	_lcd_write_char_con
(0168) 	 lcd_write_char_con(1,' ');
    0022C E220      LDI	R18,0x20
    0022D E001      LDI	R16,1
    0022E 940E 046A CALL	_lcd_write_char_con
(0169) 	//时
(0170) 	 lcd_write_char_con(1, 0x30|((Read1302(0x85)>>4)&0x03));
    00230 E805      LDI	R16,0x85
    00231 DEDE      RCALL	_Read1302
    00232 2EA0      MOV	R10,R16
    00233 2D2A      MOV	R18,R10
    00234 9522      SWAP	R18
    00235 702F      ANDI	R18,0xF
    00236 7023      ANDI	R18,3
    00237 6320      ORI	R18,0x30
    00238 E001      LDI	R16,1
    00239 940E 046A CALL	_lcd_write_char_con
(0171) 	 lcd_write_char_con(1,0x30|(Read1302(0x85)&0x0F)); 
    0023B E805      LDI	R16,0x85
    0023C DED3      RCALL	_Read1302
    0023D 2F40      MOV	R20,R16
    0023E 2F24      MOV	R18,R20
    0023F 702F      ANDI	R18,0xF
    00240 6320      ORI	R18,0x30
    00241 E001      LDI	R16,1
    00242 940E 046A CALL	_lcd_write_char_con
(0172) 	 lcd_write_char_con(1,':');
    00244 E32A      LDI	R18,0x3A
    00245 E001      LDI	R16,1
    00246 940E 046A CALL	_lcd_write_char_con
(0173) 	//分
(0174) 	 lcd_write_char_con(1, 0x30|Read1302(0x83)>>4);
    00248 E803      LDI	R16,0x83
    00249 DEC6      RCALL	_Read1302
    0024A 2EA0      MOV	R10,R16
    0024B 2D2A      MOV	R18,R10
    0024C 9522      SWAP	R18
    0024D 702F      ANDI	R18,0xF
    0024E 6320      ORI	R18,0x30
    0024F E001      LDI	R16,1
    00250 940E 046A CALL	_lcd_write_char_con
(0175) 	 lcd_write_char_con(1,0x30|(Read1302(0x83)&0x0F));
    00252 E803      LDI	R16,0x83
    00253 DEBC      RCALL	_Read1302
    00254 2F40      MOV	R20,R16
    00255 2F24      MOV	R18,R20
    00256 702F      ANDI	R18,0xF
    00257 6320      ORI	R18,0x30
    00258 E001      LDI	R16,1
    00259 940E 046A CALL	_lcd_write_char_con
(0176) 	 lcd_write_char_con(1,':');
    0025B E32A      LDI	R18,0x3A
    0025C E001      LDI	R16,1
    0025D 940E 046A CALL	_lcd_write_char_con
(0177) 	//秒
(0178) 	 lcd_write_char_con(1, 0x30|(Read1302(0x81)>>4));
    0025F E801      LDI	R16,0x81
    00260 DEAF      RCALL	_Read1302
    00261 2EA0      MOV	R10,R16
    00262 2D2A      MOV	R18,R10
    00263 9522      SWAP	R18
    00264 702F      ANDI	R18,0xF
    00265 6320      ORI	R18,0x30
    00266 E001      LDI	R16,1
    00267 940E 046A CALL	_lcd_write_char_con
(0179) 	 lcd_write_char_con(1,0x30|(Read1302(0x81)&0x0F));
    00269 E801      LDI	R16,0x81
    0026A DEA5      RCALL	_Read1302
    0026B 2F40      MOV	R20,R16
    0026C 2F24      MOV	R18,R20
    0026D 702F      ANDI	R18,0xF
    0026E 6320      ORI	R18,0x30
    0026F E001      LDI	R16,1
    00270 940E 046A CALL	_lcd_write_char_con
    00272 9149      LD	R20,Y+
    00273 90A9      LD	R10,Y+
    00274 9508      RET
FILE: E:\ICCDemo\Temp_Control\temp_control\key.c
(0001) #include<iom128v.h>
(0002) #include "delay.h"
(0003) #include "lcd.h"
(0004) uchar key_value='n';
(0005) void KeyInit(void){
_KeyInit:
    00275 9508      RET
_KeyScan:
    00276 934A      ST	-Y,R20
    00277 935A      ST	-Y,R21
(0006) }
(0007) uchar KeyScan(void){
(0008)   //初始化端口
(0009)    DDRC=0xE0;
    00278 EE80      LDI	R24,0xE0
    00279 BB84      OUT	0x14,R24
(0010)    DDRG|=0x10;
    0027A 9180 0064 LDS	R24,0x64
    0027C 6180      ORI	R24,0x10
    0027D 9380 0064 STS	0x64,R24
(0011)    
(0012)    //第一次扫描
(0013)    PORTC=0xDF;
    0027F ED8F      LDI	R24,0xDF
    00280 BB85      OUT	0x15,R24
(0014)    PORTG|=0x10;
    00281 9180 0065 LDS	R24,0x65
    00283 6180      ORI	R24,0x10
    00284 9380 0065 STS	0x65,R24
(0015)    delay_us(1);
    00286 E001      LDI	R16,1
    00287 E010      LDI	R17,0
    00288 940E 00BF CALL	_delay_us
(0016)    switch(PINC)
    0028A B343      IN	R20,0x13
    0028B 2755      CLR	R21
    0028C 3C4F      CPI	R20,0xCF
    0028D E0E0      LDI	R30,0
    0028E 075E      CPC	R21,R30
    0028F F0E9      BEQ	0x02AD
    00290 3C4F      CPI	R20,0xCF
    00291 E0E0      LDI	R30,0
    00292 075E      CPC	R21,R30
    00293 F0DC      BLT	0x02AF
    00294 3D47      CPI	R20,0xD7
    00295 E0E0      LDI	R30,0
    00296 075E      CPC	R21,R30
    00297 F099      BEQ	0x02AB
    00298 3D4B      CPI	R20,0xDB
    00299 E0E0      LDI	R30,0
    0029A 075E      CPC	R21,R30
    0029B F069      BEQ	0x02A9
    0029C 3D4D      CPI	R20,0xDD
    0029D E0E0      LDI	R30,0
    0029E 075E      CPC	R21,R30
    0029F F039      BEQ	0x02A7
    002A0 3D4E      CPI	R20,0xDE
    002A1 E0E0      LDI	R30,0
    002A2 075E      CPC	R21,R30
    002A3 F009      BEQ	0x02A5
    002A4 C00A      RJMP	0x02AF
(0017)    {
(0018)    		case 0xDE:return  'e';//'esc';
    002A5 E605      LDI	R16,0x65
    002A6 C099      RJMP	0x0340
(0019) 		case 0xdd:return  'a';//'alm';
    002A7 E601      LDI	R16,0x61
    002A8 C097      RJMP	0x0340
(0020) 		case 0xdb:return  'd';//'down';  
    002A9 E604      LDI	R16,0x64
    002AA C095      RJMP	0x0340
(0021) 		case 0xd7:return  'u';//'up';
    002AB E705      LDI	R16,0x75
    002AC C093      RJMP	0x0340
(0022) 		case 0xcf:return  'l';//'left';
    002AD E60C      LDI	R16,0x6C
    002AE C091      RJMP	0x0340
(0023) 		default:break;	   
(0024)    } 
(0025)     //第二次扫描
(0026)    PORTC=0xBF;
    002AF EB8F      LDI	R24,0xBF
    002B0 BB85      OUT	0x15,R24
(0027)    PORTG|=0x10;
    002B1 9180 0065 LDS	R24,0x65
    002B3 6180      ORI	R24,0x10
    002B4 9380 0065 STS	0x65,R24
(0028)    delay_us(1);
    002B6 E001      LDI	R16,1
    002B7 E010      LDI	R17,0
    002B8 940E 00BF CALL	_delay_us
(0029)    switch(PINC)
    002BA B343      IN	R20,0x13
    002BB 2755      CLR	R21
    002BC 3A4F      CPI	R20,0xAF
    002BD E0E0      LDI	R30,0
    002BE 075E      CPC	R21,R30
    002BF F0E9      BEQ	0x02DD
    002C0 3A4F      CPI	R20,0xAF
    002C1 E0E0      LDI	R30,0
    002C2 075E      CPC	R21,R30
    002C3 F0DC      BLT	0x02DF
    002C4 3B47      CPI	R20,0xB7
    002C5 E0E0      LDI	R30,0
    002C6 075E      CPC	R21,R30
    002C7 F099      BEQ	0x02DB
    002C8 3B4B      CPI	R20,0xBB
    002C9 E0E0      LDI	R30,0
    002CA 075E      CPC	R21,R30
    002CB F069      BEQ	0x02D9
    002CC 3B4D      CPI	R20,0xBD
    002CD E0E0      LDI	R30,0
    002CE 075E      CPC	R21,R30
    002CF F039      BEQ	0x02D7
    002D0 3B4E      CPI	R20,0xBE
    002D1 E0E0      LDI	R30,0
    002D2 075E      CPC	R21,R30
    002D3 F009      BEQ	0x02D5
    002D4 C00A      RJMP	0x02DF
(0030)    {
(0031)    		case 0xbE:return 's';//'set';
    002D5 E703      LDI	R16,0x73
    002D6 C069      RJMP	0x0340
(0032) 		case 0xbd:return 'r';//'right';
    002D7 E702      LDI	R16,0x72
    002D8 C067      RJMP	0x0340
(0033) 		case 0xbb:return 't';//'ent';  
    002D9 E704      LDI	R16,0x74
    002DA C065      RJMP	0x0340
(0034) 		case 0xb7:return 'c';//'clr';
    002DB E603      LDI	R16,0x63
    002DC C063      RJMP	0x0340
(0035) 		case 0xaf:return '+';//'+/-';
    002DD E20B      LDI	R16,0x2B
    002DE C061      RJMP	0x0340
(0036) 		default:break;	   
(0037)    } 
(0038)     //第三次扫描
(0039)    PORTC=0x7F;
    002DF E78F      LDI	R24,0x7F
    002E0 BB85      OUT	0x15,R24
(0040)    PORTG|=0x10;
    002E1 9180 0065 LDS	R24,0x65
    002E3 6180      ORI	R24,0x10
    002E4 9380 0065 STS	0x65,R24
(0041)    delay_us(1);
    002E6 E001      LDI	R16,1
    002E7 E010      LDI	R17,0
    002E8 940E 00BF CALL	_delay_us
(0042)    switch(PINC)
    002EA B343      IN	R20,0x13
    002EB 2755      CLR	R21
    002EC 364F      CPI	R20,0x6F
    002ED E0E0      LDI	R30,0
    002EE 075E      CPC	R21,R30
    002EF F0E9      BEQ	0x030D
    002F0 364F      CPI	R20,0x6F
    002F1 E0E0      LDI	R30,0
    002F2 075E      CPC	R21,R30
    002F3 F0DC      BLT	0x030F
    002F4 3747      CPI	R20,0x77
    002F5 E0E0      LDI	R30,0
    002F6 075E      CPC	R21,R30
    002F7 F099      BEQ	0x030B
    002F8 374B      CPI	R20,0x7B
    002F9 E0E0      LDI	R30,0
    002FA 075E      CPC	R21,R30
    002FB F069      BEQ	0x0309
    002FC 374D      CPI	R20,0x7D
    002FD E0E0      LDI	R30,0
    002FE 075E      CPC	R21,R30
    002FF F039      BEQ	0x0307
    00300 374E      CPI	R20,0x7E
    00301 E0E0      LDI	R30,0
    00302 075E      CPC	R21,R30
    00303 F009      BEQ	0x0305
    00304 C00A      RJMP	0x030F
(0043)    {
(0044)    		case 0x7E:return '0';
    00305 E300      LDI	R16,0x30
    00306 C039      RJMP	0x0340
(0045) 		case 0x7d:return '3';
    00307 E303      LDI	R16,0x33
    00308 C037      RJMP	0x0340
(0046) 		case 0x7b:return '2';  
    00309 E302      LDI	R16,0x32
    0030A C035      RJMP	0x0340
(0047) 		case 0x77:return '1';
    0030B E301      LDI	R16,0x31
    0030C C033      RJMP	0x0340
(0048) 		case 0x6f:return '6';
    0030D E306      LDI	R16,0x36
    0030E C031      RJMP	0x0340
(0049) 		default:break;	   
(0050)    } 
(0051)       //第四次扫描
(0052)    PORTC=0xFF;
    0030F EF8F      LDI	R24,0xFF
    00310 BB85      OUT	0x15,R24
(0053)    PORTG&=0x0F;
    00311 9180 0065 LDS	R24,0x65
    00313 708F      ANDI	R24,0xF
    00314 9380 0065 STS	0x65,R24
(0054)    delay_us(1);
    00316 E001      LDI	R16,1
    00317 E010      LDI	R17,0
    00318 940E 00BF CALL	_delay_us
(0055)    switch(PINC)
    0031A B343      IN	R20,0x13
    0031B 2755      CLR	R21
    0031C 3E4F      CPI	R20,0xEF
    0031D E0E0      LDI	R30,0
    0031E 075E      CPC	R21,R30
    0031F F0E9      BEQ	0x033D
    00320 3E4F      CPI	R20,0xEF
    00321 E0E0      LDI	R30,0
    00322 075E      CPC	R21,R30
    00323 F0DC      BLT	0x033F
    00324 3F47      CPI	R20,0xF7
    00325 E0E0      LDI	R30,0
    00326 075E      CPC	R21,R30
    00327 F099      BEQ	0x033B
    00328 3F4B      CPI	R20,0xFB
    00329 E0E0      LDI	R30,0
    0032A 075E      CPC	R21,R30
    0032B F069      BEQ	0x0339
    0032C 3F4D      CPI	R20,0xFD
    0032D E0E0      LDI	R30,0
    0032E 075E      CPC	R21,R30
    0032F F039      BEQ	0x0337
    00330 3F4E      CPI	R20,0xFE
    00331 E0E0      LDI	R30,0
    00332 075E      CPC	R21,R30
    00333 F009      BEQ	0x0335
    00334 C00A      RJMP	0x033F
(0056)    {
(0057)    		case 0xFE:return '7';
    00335 E307      LDI	R16,0x37
    00336 C009      RJMP	0x0340
(0058) 		case 0xFd:return '8';
    00337 E308      LDI	R16,0x38
    00338 C007      RJMP	0x0340
(0059) 		case 0xFb:return '9';  
    00339 E309      LDI	R16,0x39
    0033A C005      RJMP	0x0340
(0060) 		case 0xF7:return '4';
    0033B E304      LDI	R16,0x34
    0033C C003      RJMP	0x0340
(0061) 		case 0xEf:return '5';
    0033D E305      LDI	R16,0x35
    0033E C001      RJMP	0x0340
(0062) 		default:break;	   
(0063)    }
(0064)  return 'n';
    0033F E60E      LDI	R16,0x6E
    00340 9159      LD	R21,Y+
    00341 9149      LD	R20,Y+
    00342 9508      RET
_KeyScan_once:
  keyValue2            --> R10
  keyValue             --> R20
    00343 92AA      ST	-Y,R10
    00344 934A      ST	-Y,R20
(0065)    
(0066) }
(0067) //********************************
(0068) //		加上延时抖动的读取，一次读取一个
(0069) //********************************
(0070) uchar KeyScan_once(void){
(0071) 	  uchar keyValue,keyValue2;
(0072) 	  keyValue=KeyScan();
    00345 DF30      RCALL	_KeyScan
    00346 2F40      MOV	R20,R16
(0073) 	  delay_ms(2);
    00347 E002      LDI	R16,2
    00348 E010      LDI	R17,0
    00349 940E 00C9 CALL	_delay_ms
(0074) 	  keyValue2=KeyScan();
    0034B DF2A      RCALL	_KeyScan
    0034C 2EA0      MOV	R10,R16
(0075) 	 if(keyValue==keyValue2 && keyValue!='n'){//两次扫描，消除抖动
    0034D 1740      CP	R20,R16
    0034E F461      BNE	0x035B
    0034F 364E      CPI	R20,0x6E
    00350 F051      BEQ	0x035B
(0076) 	 	if(key_value==keyValue){//如果还是上一次保存的值则代表一直按着，返回‘n’
    00351 9020 0103 LDS	R2,key_value
    00353 1624      CP	R2,R20
    00354 F411      BNE	0x0357
(0077) 		    return 'n';  
    00355 E60E      LDI	R16,0x6E
    00356 C008      RJMP	0x035F
(0078) 	    }else{                  //松开后第一次按下，返回该键的值
(0079) 		 key_value=keyValue;
    00357 9340 0103 STS	key_value,R20
(0080) 		  return keyValue;
    00359 2F04      MOV	R16,R20
    0035A C004      RJMP	0x035F
(0081) 		}
(0082) 	 }else{                     //因为读取键盘的值会多次刷新，所以在松开按键时key_value重置
(0083) 	   key_value='n';
    0035B E68E      LDI	R24,0x6E
    0035C 9380 0103 STS	key_value,R24
(0084) 	   return 'n';
    0035E E60E      LDI	R16,0x6E
    0035F 9149      LD	R20,Y+
    00360 90A9      LD	R10,Y+
    00361 9508      RET
_lcd_bz_1:
  result               --> R20
    00362 934A      ST	-Y,R20
    00363 935A      ST	-Y,R21
FILE: E:\ICCDemo\Temp_Control\temp_control\lcd.c
(0001) #include<iom128v.h>
(0002) #include "lcd.h"
(0003) #include "delay.h" 
(0004) #define rs_l PORTG&=~(1<<PG1)
(0005) #define rs_h PORTG|=1<<PG1
(0006) #define rw_l PORTG&=~(1<<PG0)
(0007) #define rw_h PORTG|=1<<PG0
(0008) #define ep1_l PORTG&=~(1<<PG3)
(0009) #define ep1_h PORTG|=1<<PG3
(0010) #define ep2_l PORTF&=~(1<<PF0)
(0011) #define ep2_h PORTF|=1<<PF0
(0012) //***********************************
(0013) //上半屏幕
(0014) //**********************************
(0015) /*
(0016)  读忙程序。命令后，读入BF
(0017) */
(0018) uint lcd_bz_1(void){
(0019) 	uint result;
(0020) 	DDRA=0x00;
    00364 2422      CLR	R2
    00365 BA2A      OUT	0x1A,R2
(0021) 	rs_l;
    00366 9180 0065 LDS	R24,0x65
    00368 7F8D      ANDI	R24,0xFD
    00369 9380 0065 STS	0x65,R24
(0022) 	rw_h;
    0036B 9180 0065 LDS	R24,0x65
    0036D 6081      ORI	R24,1
    0036E 9380 0065 STS	0x65,R24
(0023) 	ep1_h;
    00370 9180 0065 LDS	R24,0x65
    00372 6088      ORI	R24,0x8
    00373 9380 0065 STS	0x65,R24
(0024) 	delay_ms(1);
    00375 E001      LDI	R16,1
    00376 E010      LDI	R17,0
    00377 940E 00C9 CALL	_delay_ms
(0025) 	result=PINA&(1<<PINA7);
    00379 B349      IN	R20,0x19
    0037A 2755      CLR	R21
    0037B 7840      ANDI	R20,0x80
    0037C 7050      ANDI	R21,0
(0026) 	DDRA=0xFF;
    0037D EF8F      LDI	R24,0xFF
    0037E BB8A      OUT	0x1A,R24
(0027) 	ep1_l;
    0037F 9180 0065 LDS	R24,0x65
    00381 7F87      ANDI	R24,0xF7
    00382 9380 0065 STS	0x65,R24
(0028) 	return result;
    00384 018A      MOVW	R16,R20
    00385 9159      LD	R21,Y+
    00386 9149      LD	R20,Y+
    00387 9508      RET
_lcd_wcmd_1:
  cmd                  --> R10
    00388 92AA      ST	-Y,R10
    00389 2EA0      MOV	R10,R16
(0029) }
(0030) void lcd_wcmd_1(uchar cmd){
(0031) 	 while(lcd_bz_1());
    0038A DFD7      RCALL	_lcd_bz_1
    0038B 3000      CPI	R16,0
    0038C 0701      CPC	R16,R17
    0038D F7E1      BNE	0x038A
(0032) 	 rs_l;
    0038E 9180 0065 LDS	R24,0x65
    00390 7F8D      ANDI	R24,0xFD
    00391 9380 0065 STS	0x65,R24
(0033) 	 rw_l;
    00393 9180 0065 LDS	R24,0x65
    00395 7F8E      ANDI	R24,0xFE
    00396 9380 0065 STS	0x65,R24
(0034) 	 ep1_l;
    00398 9180 0065 LDS	R24,0x65
    0039A 7F87      ANDI	R24,0xF7
    0039B 9380 0065 STS	0x65,R24
(0035) 	 delay_ms(1);
    0039D E001      LDI	R16,1
    0039E E010      LDI	R17,0
    0039F 940E 00C9 CALL	_delay_ms
(0036) 	 PORTA=cmd;
    003A1 BAAB      OUT	0x1B,R10
(0037) 	 delay_ms(2);
    003A2 E002      LDI	R16,2
    003A3 E010      LDI	R17,0
    003A4 940E 00C9 CALL	_delay_ms
(0038) 	 ep1_h;
    003A6 9180 0065 LDS	R24,0x65
    003A8 6088      ORI	R24,0x8
    003A9 9380 0065 STS	0x65,R24
(0039) 	 delay_ms(1);
    003AB E001      LDI	R16,1
    003AC E010      LDI	R17,0
    003AD 940E 00C9 CALL	_delay_ms
(0040) 	 ep1_l;
    003AF 9180 0065 LDS	R24,0x65
    003B1 7F87      ANDI	R24,0xF7
    003B2 9380 0065 STS	0x65,R24
(0041) 	 return;
    003B4 90A9      LD	R10,Y+
    003B5 9508      RET
_lcd_wdat_1:
  dat                  --> R10
    003B6 92AA      ST	-Y,R10
    003B7 2EA0      MOV	R10,R16
(0042) }
(0043) /*
(0044) 写输出数据,char
(0045) */
(0046) void lcd_wdat_1(uchar dat){
(0047) 	 while(lcd_bz_1());
    003B8 DFA9      RCALL	_lcd_bz_1
    003B9 3000      CPI	R16,0
    003BA 0701      CPC	R16,R17
    003BB F7E1      BNE	0x03B8
(0048) 	 rs_h;
    003BC 9180 0065 LDS	R24,0x65
    003BE 6082      ORI	R24,2
    003BF 9380 0065 STS	0x65,R24
(0049) 	 rw_l;
    003C1 9180 0065 LDS	R24,0x65
    003C3 7F8E      ANDI	R24,0xFE
    003C4 9380 0065 STS	0x65,R24
(0050) 	 ep1_l;
    003C6 9180 0065 LDS	R24,0x65
    003C8 7F87      ANDI	R24,0xF7
    003C9 9380 0065 STS	0x65,R24
(0051) 	 PORTA=dat;
    003CB BAAB      OUT	0x1B,R10
(0052) 	 delay_ms(2);
    003CC E002      LDI	R16,2
    003CD E010      LDI	R17,0
    003CE 940E 00C9 CALL	_delay_ms
(0053) 	 ep1_h;
    003D0 9180 0065 LDS	R24,0x65
    003D2 6088      ORI	R24,0x8
    003D3 9380 0065 STS	0x65,R24
(0054) 	 delay_ms(2);
    003D5 E002      LDI	R16,2
    003D6 E010      LDI	R17,0
    003D7 940E 00C9 CALL	_delay_ms
(0055) 	 ep1_l;
    003D9 9180 0065 LDS	R24,0x65
    003DB 7F87      ANDI	R24,0xF7
    003DC 9380 0065 STS	0x65,R24
    003DE 90A9      LD	R10,Y+
    003DF 9508      RET
(0056) }
(0057) 
(0058) /*清显示*/
(0059) void lcd_clear_1(void) 
(0060) {
(0061) 	lcd_wcmd_1(0x01);
_lcd_clear_1:
    003E0 E001      LDI	R16,1
    003E1 DFA6      RCALL	_lcd_wcmd_1
(0062) 	delay_ms(1);
    003E2 E001      LDI	R16,1
    003E3 E010      LDI	R17,0
    003E4 940C 00C9 JMP	_delay_ms
_lcd_bz_2:
  result               --> R20
    003E6 934A      ST	-Y,R20
    003E7 935A      ST	-Y,R21
(0063) }
(0064) //***********************************
(0065) //    下半屏幕
(0066) //***********************************
(0067) uint lcd_bz_2(void){
(0068) 	uint result;
(0069) 	DDRA=0x00;
    003E8 2422      CLR	R2
    003E9 BA2A      OUT	0x1A,R2
(0070) 	rs_l;
    003EA 9180 0065 LDS	R24,0x65
    003EC 7F8D      ANDI	R24,0xFD
    003ED 9380 0065 STS	0x65,R24
(0071) 	rw_h;
    003EF 9180 0065 LDS	R24,0x65
    003F1 6081      ORI	R24,1
    003F2 9380 0065 STS	0x65,R24
(0072) 	ep2_h;
    003F4 9180 0062 LDS	R24,0x62
    003F6 6081      ORI	R24,1
    003F7 9380 0062 STS	0x62,R24
(0073) 	delay_ms(1);
    003F9 E001      LDI	R16,1
    003FA E010      LDI	R17,0
    003FB 940E 00C9 CALL	_delay_ms
(0074) 	result=PINA&(1<<PINA7);
    003FD B349      IN	R20,0x19
    003FE 2755      CLR	R21
    003FF 7840      ANDI	R20,0x80
    00400 7050      ANDI	R21,0
(0075) 	DDRA=0xFF;
    00401 EF8F      LDI	R24,0xFF
    00402 BB8A      OUT	0x1A,R24
(0076) 	ep2_l;
    00403 9180 0062 LDS	R24,0x62
    00405 7F8E      ANDI	R24,0xFE
    00406 9380 0062 STS	0x62,R24
(0077) 	return result;
    00408 018A      MOVW	R16,R20
    00409 9159      LD	R21,Y+
    0040A 9149      LD	R20,Y+
    0040B 9508      RET
_lcd_wcmd_2:
  cmd                  --> R10
    0040C 92AA      ST	-Y,R10
    0040D 2EA0      MOV	R10,R16
(0078) }
(0079) void lcd_wcmd_2(uchar cmd){
(0080) 	 while(lcd_bz_2());
    0040E DFD7      RCALL	_lcd_bz_2
    0040F 3000      CPI	R16,0
    00410 0701      CPC	R16,R17
    00411 F7E1      BNE	0x040E
(0081) 	 rs_l;
    00412 9180 0065 LDS	R24,0x65
    00414 7F8D      ANDI	R24,0xFD
    00415 9380 0065 STS	0x65,R24
(0082) 	 rw_l;
    00417 9180 0065 LDS	R24,0x65
    00419 7F8E      ANDI	R24,0xFE
    0041A 9380 0065 STS	0x65,R24
(0083) 	 ep2_l;
    0041C 9180 0062 LDS	R24,0x62
    0041E 7F8E      ANDI	R24,0xFE
    0041F 9380 0062 STS	0x62,R24
(0084) 	 delay_ms(1);
    00421 E001      LDI	R16,1
    00422 E010      LDI	R17,0
    00423 940E 00C9 CALL	_delay_ms
(0085) 	 PORTA=cmd;
    00425 BAAB      OUT	0x1B,R10
(0086) 	 delay_ms(2);
    00426 E002      LDI	R16,2
    00427 E010      LDI	R17,0
    00428 940E 00C9 CALL	_delay_ms
(0087) 	 ep2_h;
    0042A 9180 0062 LDS	R24,0x62
    0042C 6081      ORI	R24,1
    0042D 9380 0062 STS	0x62,R24
(0088) 	 delay_ms(1);
    0042F E001      LDI	R16,1
    00430 E010      LDI	R17,0
    00431 940E 00C9 CALL	_delay_ms
(0089) 	 ep2_l;
    00433 9180 0062 LDS	R24,0x62
    00435 7F8E      ANDI	R24,0xFE
    00436 9380 0062 STS	0x62,R24
    00438 90A9      LD	R10,Y+
    00439 9508      RET
_lcd_wdat_2:
  dat                  --> R10
    0043A 92AA      ST	-Y,R10
    0043B 2EA0      MOV	R10,R16
(0090) }
(0091) //  写输出数据,char
(0092) void lcd_wdat_2(uchar dat){
(0093) 	 while(lcd_bz_2());
    0043C DFA9      RCALL	_lcd_bz_2
    0043D 3000      CPI	R16,0
    0043E 0701      CPC	R16,R17
    0043F F7E1      BNE	0x043C
(0094) 	 rs_h;
    00440 9180 0065 LDS	R24,0x65
    00442 6082      ORI	R24,2
    00443 9380 0065 STS	0x65,R24
(0095) 	 rw_l;
    00445 9180 0065 LDS	R24,0x65
    00447 7F8E      ANDI	R24,0xFE
    00448 9380 0065 STS	0x65,R24
(0096) 	 ep2_l;
    0044A 9180 0062 LDS	R24,0x62
    0044C 7F8E      ANDI	R24,0xFE
    0044D 9380 0062 STS	0x62,R24
(0097) 	 PORTA=dat;
    0044F BAAB      OUT	0x1B,R10
(0098) 	 delay_ms(2);
    00450 E002      LDI	R16,2
    00451 E010      LDI	R17,0
    00452 940E 00C9 CALL	_delay_ms
(0099) 	 ep2_h;
    00454 9180 0062 LDS	R24,0x62
    00456 6081      ORI	R24,1
    00457 9380 0062 STS	0x62,R24
(0100) 	 delay_ms(2);
    00459 E002      LDI	R16,2
    0045A E010      LDI	R17,0
    0045B 940E 00C9 CALL	_delay_ms
(0101) 	 ep2_l;
    0045D 9180 0062 LDS	R24,0x62
    0045F 7F8E      ANDI	R24,0xFE
    00460 9380 0062 STS	0x62,R24
    00462 90A9      LD	R10,Y+
    00463 9508      RET
(0102) }
(0103) /*清显示*/
(0104) void lcd_clear_2(void) 
(0105) {
(0106) 	
(0107) 	lcd_wcmd_2(0x01);
_lcd_clear_2:
    00464 E001      LDI	R16,1
    00465 DFA6      RCALL	_lcd_wcmd_2
(0108) 
(0109) 	delay_ms(1);
    00466 E001      LDI	R16,1
    00467 E010      LDI	R17,0
    00468 940C 00C9 JMP	_delay_ms
_lcd_write_char_con:
  data                 --> R10
  y                    --> R20
    0046A 92AA      ST	-Y,R10
    0046B 934A      ST	-Y,R20
    0046C 2EA2      MOV	R10,R18
    0046D 2F40      MOV	R20,R16
(0110) 
(0111) }
(0112) 
(0113) //*************************************************
(0114) //					写字符
(0115) //***************************************************
(0116) /*
(0117)   附带y。调用 lcd_wdat（）方法。传入时转换为char。直接连续写入使用
(0118) */
(0119) void lcd_write_char_con(unsigned char y,unsigned char data) 
(0120) {
(0121) 	
(0122)     if (y == 0 || y==1) 
    0046E 2344      TST	R20
    0046F F011      BEQ	0x0472
    00470 3041      CPI	R20,1
    00471 F419      BNE	0x0475
(0123)     {
(0124)     	
(0125) 		 lcd_wdat_1( data);
    00472 2D0A      MOV	R16,R10
    00473 DF42      RCALL	_lcd_wdat_1
(0126)     }else  if(y==2 || y==3 )
    00474 C006      RJMP	0x047B
    00475 3042      CPI	R20,2
    00476 F011      BEQ	0x0479
    00477 3043      CPI	R20,3
    00478 F411      BNE	0x047B
(0127)     {
(0128)     	
(0129) 		 lcd_wdat_2( data);
    00479 2D0A      MOV	R16,R10
    0047A DFBF      RCALL	_lcd_wdat_2
(0130)     }
(0131)    return; 
    0047B 9149      LD	R20,Y+
    0047C 90A9      LD	R10,Y+
    0047D 9508      RET
_lcd_write_pos:
  y                    --> R22
  x                    --> R20
    0047E 934A      ST	-Y,R20
    0047F 936A      ST	-Y,R22
    00480 2F62      MOV	R22,R18
    00481 2F40      MOV	R20,R16
(0132) }
(0133) /*
(0134)   附带x,y。写光标位置
(0135) */
(0136) void lcd_write_pos(unsigned char x,unsigned char y) 
(0137) {
(0138) 	
(0139)     if (y == 0) 
    00482 2366      TST	R22
    00483 F421      BNE	0x0488
(0140)     {
(0141)     	lcd_wcmd_1(0x80 + x);
    00484 2F04      MOV	R16,R20
    00485 5800      SUBI	R16,0x80
    00486 DF01      RCALL	_lcd_wcmd_1
(0142)     }
    00487 C011      RJMP	0x0499
(0143)     else  if(y==1)
    00488 3061      CPI	R22,1
    00489 F421      BNE	0x048E
(0144)     {
(0145)     	lcd_wcmd_1(0x90 + x);
    0048A 2F04      MOV	R16,R20
    0048B 5700      SUBI	R16,0x70
    0048C DEFB      RCALL	_lcd_wcmd_1
(0146)     }else  if(y==2)
    0048D C00B      RJMP	0x0499
    0048E 3062      CPI	R22,2
    0048F F421      BNE	0x0494
(0147)     {
(0148)     	lcd_wcmd_2(0x80 + x);
    00490 2F04      MOV	R16,R20
    00491 5800      SUBI	R16,0x80
    00492 DF79      RCALL	_lcd_wcmd_2
(0149)     }else  if(y==3)
    00493 C005      RJMP	0x0499
    00494 3063      CPI	R22,3
    00495 F419      BNE	0x0499
(0150)     {
(0151)     	lcd_wcmd_2(0x90 + x);
    00496 2F04      MOV	R16,R20
    00497 5700      SUBI	R16,0x70
    00498 DF73      RCALL	_lcd_wcmd_2
(0152)     }
(0153)    return; 
    00499 9169      LD	R22,Y+
    0049A 9149      LD	R20,Y+
    0049B 9508      RET
_lcd_write_char:
  data                 --> R10
  y                    --> R22
  x                    --> R20
    0049C 940E 1149 CALL	push_xgsetF00C
    0049E 2F62      MOV	R22,R18
    0049F 2F40      MOV	R20,R16
    004A0 80AE      LDD	R10,Y+6
(0154) }
(0155) /*
(0156)   附带x,y。调用 lcd_wdat（）方法。传入时转换为char
(0157) */
(0158) void lcd_write_char(unsigned char x,unsigned char y,unsigned char data) 
(0159) {
(0160) 	
(0161)     if (y == 0) 
    004A1 2366      TST	R22
    004A2 F431      BNE	0x04A9
(0162)     {
(0163)     	lcd_wcmd_1(0x80 + x);
    004A3 2F04      MOV	R16,R20
    004A4 5800      SUBI	R16,0x80
    004A5 DEE2      RCALL	_lcd_wcmd_1
(0164) 		 lcd_wdat_1( data);
    004A6 2D0A      MOV	R16,R10
    004A7 DF0E      RCALL	_lcd_wdat_1
(0165)     }
    004A8 C017      RJMP	0x04C0
(0166)     else  if(y==1)
    004A9 3061      CPI	R22,1
    004AA F431      BNE	0x04B1
(0167)     {
(0168)     	lcd_wcmd_1(0x90 + x);
    004AB 2F04      MOV	R16,R20
    004AC 5700      SUBI	R16,0x70
    004AD DEDA      RCALL	_lcd_wcmd_1
(0169) 		 lcd_wdat_1( data);
    004AE 2D0A      MOV	R16,R10
    004AF DF06      RCALL	_lcd_wdat_1
(0170)     }else  if(y==2)
    004B0 C00F      RJMP	0x04C0
    004B1 3062      CPI	R22,2
    004B2 F431      BNE	0x04B9
(0171)     {
(0172)     	lcd_wcmd_2(0x80 + x);
    004B3 2F04      MOV	R16,R20
    004B4 5800      SUBI	R16,0x80
    004B5 DF56      RCALL	_lcd_wcmd_2
(0173) 		 lcd_wdat_2( data);
    004B6 2D0A      MOV	R16,R10
    004B7 DF82      RCALL	_lcd_wdat_2
(0174)     }else  if(y==3)
    004B8 C007      RJMP	0x04C0
    004B9 3063      CPI	R22,3
    004BA F429      BNE	0x04C0
(0175)     {
(0176)     	lcd_wcmd_2(0x90 + x);
    004BB 2F04      MOV	R16,R20
    004BC 5700      SUBI	R16,0x70
    004BD DF4E      RCALL	_lcd_wcmd_2
(0177) 		 lcd_wdat_2( data);
    004BE 2D0A      MOV	R16,R10
    004BF DF7A      RCALL	_lcd_wdat_2
(0178)     }
(0179)    return; 
    004C0 940C 1150 JMP	pop_xgsetF00C
_lcd_write_str:
  s                    --> R20
  y                    --> R10
  x                    --> R22
    004C2 940E 1149 CALL	push_xgsetF00C
    004C4 2EA2      MOV	R10,R18
    004C5 2F60      MOV	R22,R16
    004C6 814E      LDD	R20,Y+6
    004C7 815F      LDD	R21,Y+7
(0180) }
(0181) /*
(0182)   附带x,y。调用 lcd_wdat（）方法，会通过指针遍历字符串。不太好，还是自己循环遍历
(0183) */
(0184) void lcd_write_str(unsigned char x,unsigned char y,unsigned char *s) 
(0185) {
(0186) 	
(0187)     if (y == 0) 
    004C8 20AA      TST	R10
    004C9 F471      BNE	0x04D8
(0188)     {
(0189)     	lcd_wcmd_1(0x80 + x);
    004CA 2F06      MOV	R16,R22
    004CB 5800      SUBI	R16,0x80
    004CC DEBB      RCALL	_lcd_wcmd_1
    004CD C005      RJMP	0x04D3
(0190) 		 while (*s) 
(0191)        {
(0192)     	lcd_wdat_1( *s);
    004CE 01FA      MOVW	R30,R20
    004CF 8100      LD	R16,Z
    004D0 DEE5      RCALL	_lcd_wdat_1
(0193)     	s ++;
    004D1 5F4F      SUBI	R20,0xFF
    004D2 4F5F      SBCI	R21,0xFF
    004D3 01FA      MOVW	R30,R20
    004D4 8020      LD	R2,Z
    004D5 2022      TST	R2
    004D6 F7B9      BNE	0x04CE
(0194)         }
(0195)     }
    004D7 C032      RJMP	0x050A
(0196)     else  if(y==1)
    004D8 2D8A      MOV	R24,R10
    004D9 3081      CPI	R24,1
    004DA F471      BNE	0x04E9
(0197)     {
(0198)     	lcd_wcmd_1(0x90 + x);
    004DB 2F06      MOV	R16,R22
    004DC 5700      SUBI	R16,0x70
    004DD DEAA      RCALL	_lcd_wcmd_1
    004DE C005      RJMP	0x04E4
(0199) 		 while (*s) 
(0200)         {
(0201)     	lcd_wdat_1( *s);
    004DF 01FA      MOVW	R30,R20
    004E0 8100      LD	R16,Z
    004E1 DED4      RCALL	_lcd_wdat_1
(0202)     	s ++;
    004E2 5F4F      SUBI	R20,0xFF
    004E3 4F5F      SBCI	R21,0xFF
    004E4 01FA      MOVW	R30,R20
    004E5 8020      LD	R2,Z
    004E6 2022      TST	R2
    004E7 F7B9      BNE	0x04DF
(0203)        }
(0204)     }else  if(y==2)
    004E8 C021      RJMP	0x050A
    004E9 2D8A      MOV	R24,R10
    004EA 3082      CPI	R24,2
    004EB F471      BNE	0x04FA
(0205)     {
(0206)     	lcd_wcmd_2(0x80 + x);
    004EC 2F06      MOV	R16,R22
    004ED 5800      SUBI	R16,0x80
    004EE DF1D      RCALL	_lcd_wcmd_2
    004EF C005      RJMP	0x04F5
(0207) 		  while (*s) 
(0208)        {
(0209)     	lcd_wdat_2( *s);
    004F0 01FA      MOVW	R30,R20
    004F1 8100      LD	R16,Z
    004F2 DF47      RCALL	_lcd_wdat_2
(0210)     	s ++;
    004F3 5F4F      SUBI	R20,0xFF
    004F4 4F5F      SBCI	R21,0xFF
    004F5 01FA      MOVW	R30,R20
    004F6 8020      LD	R2,Z
    004F7 2022      TST	R2
    004F8 F7B9      BNE	0x04F0
(0211)        }
(0212)     }else  if(y==3)
    004F9 C010      RJMP	0x050A
    004FA 2D8A      MOV	R24,R10
    004FB 3083      CPI	R24,3
    004FC F469      BNE	0x050A
(0213)     {
(0214)     	lcd_wcmd_2(0x90 + x);
    004FD 2F06      MOV	R16,R22
    004FE 5700      SUBI	R16,0x70
    004FF DF0C      RCALL	_lcd_wcmd_2
    00500 C005      RJMP	0x0506
(0215) 		  while (*s) 
(0216)        {
(0217)     	lcd_wdat_2( *s);
    00501 01FA      MOVW	R30,R20
    00502 8100      LD	R16,Z
    00503 DF36      RCALL	_lcd_wdat_2
(0218)     	s ++;
    00504 5F4F      SUBI	R20,0xFF
    00505 4F5F      SBCI	R21,0xFF
    00506 01FA      MOVW	R30,R20
    00507 8020      LD	R2,Z
    00508 2022      TST	R2
    00509 F7B9      BNE	0x0501
(0219)        }
(0220)     }
    0050A 940C 1150 JMP	pop_xgsetF00C
_lcd_write_str_con:
  s                    --> R20
  y                    --> R22
    0050C 940E 113F CALL	push_xgsetF000
    0050E 01A9      MOVW	R20,R18
    0050F 2F60      MOV	R22,R16
(0221)    
(0222) }
(0223) /*
(0224)   附带x,y。调用 lcd_wdat（）方法，会通过指针遍历字符串。不太好，还是自己循环遍历
(0225) */
(0226) void lcd_write_str_con(unsigned char y,unsigned char *s) 
(0227) {
(0228) 	
(0229)     if (y == 0 || y==1) 
    00510 2366      TST	R22
    00511 F011      BEQ	0x0514
    00512 3061      CPI	R22,1
    00513 F459      BNE	0x051F
(0230)     {
    00514 C005      RJMP	0x051A
(0231)     	
(0232) 		 while (*s) 
(0233)        {
(0234)     	lcd_wdat_1( *s);
    00515 01FA      MOVW	R30,R20
    00516 8100      LD	R16,Z
    00517 DE9E      RCALL	_lcd_wdat_1
(0235)     	s ++;
    00518 5F4F      SUBI	R20,0xFF
    00519 4F5F      SBCI	R21,0xFF
    0051A 01FA      MOVW	R30,R20
    0051B 8020      LD	R2,Z
    0051C 2022      TST	R2
    0051D F7B9      BNE	0x0515
(0236)         }
(0237)     }
    0051E C00E      RJMP	0x052D
(0238)     else  if(y==2 || y==3)
    0051F 3062      CPI	R22,2
    00520 F011      BEQ	0x0523
    00521 3063      CPI	R22,3
    00522 F451      BNE	0x052D
(0239)     {
    00523 C005      RJMP	0x0529
(0240)     	
(0241) 		  while (*s) 
(0242)        {
(0243)     	lcd_wdat_2( *s);
    00524 01FA      MOVW	R30,R20
    00525 8100      LD	R16,Z
    00526 DF13      RCALL	_lcd_wdat_2
(0244)     	s ++;
    00527 5F4F      SUBI	R20,0xFF
    00528 4F5F      SBCI	R21,0xFF
    00529 01FA      MOVW	R30,R20
    0052A 8020      LD	R2,Z
    0052B 2022      TST	R2
    0052C F7B9      BNE	0x0524
(0245)        }
(0246)     }
    0052D 940C 1144 JMP	pop_xgsetF000
_read_ac_1:
  result               --> R20
    0052F 934A      ST	-Y,R20
    00530 935A      ST	-Y,R21
(0247)    
(0248) }
(0249) //****************************
(0250) //  读出数据,.不知道有没有用，先放在这
(0251) //****************************
(0252) /**
(0253)  读程序。命令后，读AC地址
(0254) */
(0255) uchar read_ac_1(void){
(0256) 	uint result;
(0257) 	DDRA=0x00;
    00531 2422      CLR	R2
    00532 BA2A      OUT	0x1A,R2
(0258) 	rs_l;
    00533 9180 0065 LDS	R24,0x65
    00535 7F8D      ANDI	R24,0xFD
    00536 9380 0065 STS	0x65,R24
(0259) 	rw_h;
    00538 9180 0065 LDS	R24,0x65
    0053A 6081      ORI	R24,1
    0053B 9380 0065 STS	0x65,R24
(0260) 	ep1_h;
    0053D 9180 0065 LDS	R24,0x65
    0053F 6088      ORI	R24,0x8
    00540 9380 0065 STS	0x65,R24
(0261) 	delay_ms(1);
    00542 E001      LDI	R16,1
    00543 E010      LDI	R17,0
    00544 940E 00C9 CALL	_delay_ms
(0262) 	result=PINA&(~(1<<PINA7));
    00546 B349      IN	R20,0x19
    00547 2755      CLR	R21
    00548 774F      ANDI	R20,0x7F
(0263) 	DDRA=0xFF;
    00549 EF8F      LDI	R24,0xFF
    0054A BB8A      OUT	0x1A,R24
(0264) 	ep1_l;
    0054B 9180 0065 LDS	R24,0x65
    0054D 7F87      ANDI	R24,0xF7
    0054E 9380 0065 STS	0x65,R24
(0265) 	return result;
    00550 2F04      MOV	R16,R20
    00551 9159      LD	R21,Y+
    00552 9149      LD	R20,Y+
    00553 9508      RET
_read_ac_2:
  result               --> R20
    00554 934A      ST	-Y,R20
    00555 935A      ST	-Y,R21
(0266) }
(0267) uchar read_ac_2(void){
(0268) 	uint result;
(0269) 	DDRA=0x00;
    00556 2422      CLR	R2
    00557 BA2A      OUT	0x1A,R2
(0270) 	rs_l;
    00558 9180 0065 LDS	R24,0x65
    0055A 7F8D      ANDI	R24,0xFD
    0055B 9380 0065 STS	0x65,R24
(0271) 	rw_h;
    0055D 9180 0065 LDS	R24,0x65
    0055F 6081      ORI	R24,1
    00560 9380 0065 STS	0x65,R24
(0272) 	ep2_h;
    00562 9180 0062 LDS	R24,0x62
    00564 6081      ORI	R24,1
    00565 9380 0062 STS	0x62,R24
(0273) 	delay_ms(1);
    00567 E001      LDI	R16,1
    00568 E010      LDI	R17,0
    00569 940E 00C9 CALL	_delay_ms
(0274) 	result=PINA&(~(1<<PINA7));
    0056B B349      IN	R20,0x19
    0056C 2755      CLR	R21
    0056D 774F      ANDI	R20,0x7F
(0275) 	DDRA=0xFF;
    0056E EF8F      LDI	R24,0xFF
    0056F BB8A      OUT	0x1A,R24
(0276) 	ep2_l;
    00570 9180 0062 LDS	R24,0x62
    00572 7F8E      ANDI	R24,0xFE
    00573 9380 0062 STS	0x62,R24
(0277) 	return result;
    00575 2F04      MOV	R16,R20
    00576 9159      LD	R21,Y+
    00577 9149      LD	R20,Y+
    00578 9508      RET
(0278) }
(0279) 
(0280) void lcd_clear(void){
(0281)    lcd_clear_1();
_lcd_clear:
    00579 DE66      RCALL	_lcd_clear_1
(0282)     lcd_clear_2();
    0057A CEE9      RJMP	_lcd_clear_2
_date_cmd_1:
  result               --> R10
    0057B 92AA      ST	-Y,R10
    0057C 92BA      ST	-Y,R11
(0283) }
(0284) /*
(0285)  读数据程序。命令后，读入。使用read_data函数会是设定的值，再吃调用本函数会使ac
(0286)  移动一次，8读取位的数据
(0287) */
(0288) uchar date_cmd_1(void){
(0289) 	uint result;
(0290) 	DDRA=0x00;
    0057D 2422      CLR	R2
    0057E BA2A      OUT	0x1A,R2
(0291) 	rs_h;
    0057F 9180 0065 LDS	R24,0x65
    00581 6082      ORI	R24,2
    00582 9380 0065 STS	0x65,R24
(0292) 	rw_h;
    00584 9180 0065 LDS	R24,0x65
    00586 6081      ORI	R24,1
    00587 9380 0065 STS	0x65,R24
(0293) 	ep1_h;
    00589 9180 0065 LDS	R24,0x65
    0058B 6088      ORI	R24,0x8
    0058C 9380 0065 STS	0x65,R24
(0294) 	delay_ms(1);
    0058E E001      LDI	R16,1
    0058F E010      LDI	R17,0
    00590 940E 00C9 CALL	_delay_ms
(0295) 	result=PINA;
    00592 B2A9      IN	R10,0x19
    00593 24BB      CLR	R11
(0296) 	DDRA=0xFF;
    00594 EF8F      LDI	R24,0xFF
    00595 BB8A      OUT	0x1A,R24
(0297) 	ep1_l;
    00596 9180 0065 LDS	R24,0x65
    00598 7F87      ANDI	R24,0xF7
    00599 9380 0065 STS	0x65,R24
(0298) 	return result;
    0059B 2D0A      MOV	R16,R10
    0059C 90B9      LD	R11,Y+
    0059D 90A9      LD	R10,Y+
    0059E 9508      RET
_date_cmd_2:
  result               --> R10
    0059F 92AA      ST	-Y,R10
    005A0 92BA      ST	-Y,R11
(0299) }
(0300) uchar date_cmd_2(void){
(0301) 	uint result;
(0302) 	DDRA=0x00;
    005A1 2422      CLR	R2
    005A2 BA2A      OUT	0x1A,R2
(0303) 	rs_h;
    005A3 9180 0065 LDS	R24,0x65
    005A5 6082      ORI	R24,2
    005A6 9380 0065 STS	0x65,R24
(0304) 	rw_h;
    005A8 9180 0065 LDS	R24,0x65
    005AA 6081      ORI	R24,1
    005AB 9380 0065 STS	0x65,R24
(0305) 	ep2_h;
    005AD 9180 0062 LDS	R24,0x62
    005AF 6081      ORI	R24,1
    005B0 9380 0062 STS	0x62,R24
(0306) 	delay_ms(1);
    005B2 E001      LDI	R16,1
    005B3 E010      LDI	R17,0
    005B4 940E 00C9 CALL	_delay_ms
(0307) 	result=PINA;
    005B6 B2A9      IN	R10,0x19
    005B7 24BB      CLR	R11
(0308) 	DDRA=0xFF;
    005B8 EF8F      LDI	R24,0xFF
    005B9 BB8A      OUT	0x1A,R24
(0309) 	ep2_l;
    005BA 9180 0062 LDS	R24,0x62
    005BC 7F8E      ANDI	R24,0xFE
    005BD 9380 0062 STS	0x62,R24
(0310) 	return result;
    005BF 2D0A      MOV	R16,R10
    005C0 90B9      LD	R11,Y+
    005C1 90A9      LD	R10,Y+
    005C2 9508      RET
_read_data_xy:
  y                    --> R22
  x                    --> R20
    005C3 940E 1149 CALL	push_xgsetF00C
    005C5 2F62      MOV	R22,R18
    005C6 2F40      MOV	R20,R16
(0311) }
(0312) //**************************
(0313) //读取函数，注意会ac位置
(0314) //**************************
(0315) uchar read_data_xy(unsigned char x,unsigned char y){
(0316) 	if (y == 0) {
    005C7 2366      TST	R22
    005C8 F449      BNE	0x05D2
(0317)     	lcd_wcmd_1(0x80 + x);
    005C9 2F04      MOV	R16,R20
    005CA 5800      SUBI	R16,0x80
    005CB DDBC      RCALL	_lcd_wcmd_1
(0318) 		delay_us(10);
    005CC E00A      LDI	R16,0xA
    005CD E010      LDI	R17,0
    005CE 940E 00BF CALL	_delay_us
(0319) 		return date_cmd_1();
    005D0 DFAA      RCALL	_date_cmd_1
    005D1 C024      RJMP	0x05F6
(0320) 		
(0321)     }else  if(y==1){
    005D2 3061      CPI	R22,1
    005D3 F449      BNE	0x05DD
(0322)     	lcd_wcmd_1(0x90 + x);
    005D4 2F04      MOV	R16,R20
    005D5 5700      SUBI	R16,0x70
    005D6 DDB1      RCALL	_lcd_wcmd_1
(0323) 		delay_us(10);
    005D7 E00A      LDI	R16,0xA
    005D8 E010      LDI	R17,0
    005D9 940E 00BF CALL	_delay_us
(0324) 		return date_cmd_1();
    005DB DF9F      RCALL	_date_cmd_1
    005DC C019      RJMP	0x05F6
(0325)     }else  if(y==2){
    005DD 3062      CPI	R22,2
    005DE F451      BNE	0x05E9
(0326)     	lcd_wcmd_2(0x80 + x);
    005DF 2F04      MOV	R16,R20
    005E0 5800      SUBI	R16,0x80
    005E1 DE2A      RCALL	_lcd_wcmd_2
(0327) 		delay_us(10);
    005E2 E00A      LDI	R16,0xA
    005E3 E010      LDI	R17,0
    005E4 940E 00BF CALL	_delay_us
(0328) 		return date_cmd_2();
    005E6 DFB8      RCALL	_date_cmd_2
    005E7 2EA0      MOV	R10,R16
    005E8 C00D      RJMP	0x05F6
(0329)     }else  if(y==3){
    005E9 3063      CPI	R22,3
    005EA F451      BNE	0x05F5
(0330)     	lcd_wcmd_2(0x90 + x);
    005EB 2F04      MOV	R16,R20
    005EC 5700      SUBI	R16,0x70
    005ED DE1E      RCALL	_lcd_wcmd_2
(0331) 		delay_us(10);
    005EE E00A      LDI	R16,0xA
    005EF E010      LDI	R17,0
    005F0 940E 00BF CALL	_delay_us
(0332) 		return date_cmd_2();
    005F2 DFAC      RCALL	_date_cmd_2
    005F3 2EA0      MOV	R10,R16
    005F4 C001      RJMP	0x05F6
(0333)     }
(0334) 	
(0335) 	return 0x00;
    005F5 2700      CLR	R16
    005F6 940C 1150 JMP	pop_xgsetF00C
_read_data_1:
  addr                 --> R10
    005F8 92AA      ST	-Y,R10
    005F9 2EA0      MOV	R10,R16
(0336) }
(0337) uchar read_data_1(unsigned char addr){
(0338) 	
(0339)     	lcd_wcmd_1(addr);
    005FA 2D0A      MOV	R16,R10
    005FB DD8C      RCALL	_lcd_wcmd_1
(0340)     	return date_cmd_1();
    005FC DF7E      RCALL	_date_cmd_1
    005FD 90A9      LD	R10,Y+
    005FE 9508      RET
_read_data_2:
  addr                 --> R10
    005FF 92AA      ST	-Y,R10
    00600 2EA0      MOV	R10,R16
(0341) }
(0342) uchar read_data_2(unsigned char addr){
(0343)     	lcd_wcmd_1(addr);
    00601 2D0A      MOV	R16,R10
    00602 DD85      RCALL	_lcd_wcmd_1
(0344) 		return date_cmd_2();
    00603 DF9B      RCALL	_date_cmd_2
    00604 90A9      LD	R10,Y+
    00605 9508      RET
(0345) }
(0346) 
(0347) 
(0348) /*初始化功能*/
(0349) void lcd_init(void){
(0350) 	 //初始化端口功能
(0351) 	 DDRA |=0xFF;
_lcd_init:
    00606 B38A      IN	R24,0x1A
    00607 6F8F      ORI	R24,0xFF
    00608 BB8A      OUT	0x1A,R24
(0352) 	 PORTA=0xFF;
    00609 EF8F      LDI	R24,0xFF
    0060A BB8B      OUT	0x1B,R24
(0353) 	 DDRG |=0x0F;
    0060B 9180 0064 LDS	R24,0x64
    0060D 608F      ORI	R24,0xF
    0060E 9380 0064 STS	0x64,R24
(0354) 	 PORTG|=0x0F;
    00610 9180 0065 LDS	R24,0x65
    00612 608F      ORI	R24,0xF
    00613 9380 0065 STS	0x65,R24
(0355) 	 DDRF|=0x01;
    00615 9180 0061 LDS	R24,0x61
    00617 6081      ORI	R24,1
    00618 9380 0061 STS	0x61,R24
(0356) 	 PORTF|=0x01;
    0061A 9180 0062 LDS	R24,0x62
    0061C 6081      ORI	R24,1
    0061D 9380 0062 STS	0x62,R24
(0357) 	 //lcd_wcmd(0x38);//初始化功能,8位，基本指令
(0358) 	 lcd_wcmd_1(0x30);//初始化功能,8位，基本指令
    0061F E300      LDI	R16,0x30
    00620 DD67      RCALL	_lcd_wcmd_1
(0359) 	 delay_us(1);
    00621 E001      LDI	R16,1
    00622 E010      LDI	R17,0
    00623 940E 00BF CALL	_delay_us
(0360) 	  lcd_wcmd_1(0x08);//关显示
    00625 E008      LDI	R16,0x8
    00626 DD61      RCALL	_lcd_wcmd_1
(0361) 	 delay_us(1);
    00627 E001      LDI	R16,1
    00628 E010      LDI	R17,0
    00629 940E 00BF CALL	_delay_us
(0362) 	  lcd_wcmd_1(0x01);//清显示
    0062B E001      LDI	R16,1
    0062C DD5B      RCALL	_lcd_wcmd_1
(0363) 	 delay_us(1);
    0062D E001      LDI	R16,1
    0062E E010      LDI	R17,0
    0062F 940E 00BF CALL	_delay_us
(0364) 	  lcd_wcmd_1(0x06);//输入模式，右移
    00631 E006      LDI	R16,6
    00632 DD55      RCALL	_lcd_wcmd_1
(0365) 	  delay_us(1);
    00633 E001      LDI	R16,1
    00634 E010      LDI	R17,0
    00635 940E 00BF CALL	_delay_us
(0366) 	  lcd_wcmd_1(0x0c);//初始化光标,开显示
    00637 E00C      LDI	R16,0xC
    00638 DD4F      RCALL	_lcd_wcmd_1
(0367) 	
(0368) 	 delay_us(1);
    00639 E001      LDI	R16,1
    0063A E010      LDI	R17,0
    0063B 940E 00BF CALL	_delay_us
(0369) 	  lcd_wcmd_2(0x30);//初始化功能,8位，基本指令
    0063D E300      LDI	R16,0x30
    0063E DDCD      RCALL	_lcd_wcmd_2
(0370) 	 delay_us(1);
    0063F E001      LDI	R16,1
    00640 E010      LDI	R17,0
    00641 940E 00BF CALL	_delay_us
(0371) 	 lcd_wcmd_2(0x08);//关显示
    00643 E008      LDI	R16,0x8
    00644 DDC7      RCALL	_lcd_wcmd_2
(0372) 	 delay_us(1);
    00645 E001      LDI	R16,1
    00646 E010      LDI	R17,0
    00647 940E 00BF CALL	_delay_us
(0373) 	 lcd_wcmd_2(0x01);//清显示
    00649 E001      LDI	R16,1
    0064A DDC1      RCALL	_lcd_wcmd_2
(0374) 	 delay_us(1);
    0064B E001      LDI	R16,1
    0064C E010      LDI	R17,0
    0064D 940E 00BF CALL	_delay_us
(0375) 	 lcd_wcmd_2(0x06);//输入模式，右移
    0064F E006      LDI	R16,6
    00650 DDBB      RCALL	_lcd_wcmd_2
(0376) 	  delay_us(1);
    00651 E001      LDI	R16,1
    00652 E010      LDI	R17,0
    00653 940E 00BF CALL	_delay_us
(0377) 	 lcd_wcmd_2(0x0c);//初始化光标,开显示
    00655 E00C      LDI	R16,0xC
    00656 CDB5      RJMP	_lcd_wcmd_2
_cur_set:
  type                 --> R20
    00657 934A      ST	-Y,R20
    00658 935A      ST	-Y,R21
    00659 01A8      MOVW	R20,R16
(0378) }
(0379) //************
(0380) // 光标显示操作,默认初始化都是关闭。上半屏 0:关闭,1：开游标,2：游标反白,3：开游标、反白
(0381) // 下半屏  4:关闭,5：开游标,6：游标反白,7：开游标、反白
(0382) //************
(0383) void cur_set(uint type){
(0384) 	 if(type==0){
    0065A 3040      CPI	R20,0
    0065B 0745      CPC	R20,R21
    0065C F419      BNE	0x0660
(0385) 	 	lcd_wcmd_1(0x0c);	 
    0065D E00C      LDI	R16,0xC
    0065E DD29      RCALL	_lcd_wcmd_1
(0386) 	 }else if(type==1){
    0065F C030      RJMP	0x0690
    00660 3041      CPI	R20,1
    00661 E0E0      LDI	R30,0
    00662 075E      CPC	R21,R30
    00663 F419      BNE	0x0667
(0387) 	     lcd_wcmd_1(0x0e);
    00664 E00E      LDI	R16,0xE
    00665 DD22      RCALL	_lcd_wcmd_1
(0388) 	 }else if(type==2){
    00666 C029      RJMP	0x0690
    00667 3042      CPI	R20,2
    00668 E0E0      LDI	R30,0
    00669 075E      CPC	R21,R30
    0066A F419      BNE	0x066E
(0389) 	    lcd_wcmd_1(0x0d);
    0066B E00D      LDI	R16,0xD
    0066C DD1B      RCALL	_lcd_wcmd_1
(0390) 	 }else if(type==3){
    0066D C022      RJMP	0x0690
    0066E 3043      CPI	R20,3
    0066F E0E0      LDI	R30,0
    00670 075E      CPC	R21,R30
    00671 F419      BNE	0x0675
(0391) 	    lcd_wcmd_1(0x0f);
    00672 E00F      LDI	R16,0xF
    00673 DD14      RCALL	_lcd_wcmd_1
(0392) 	 }else if(type==4){
    00674 C01B      RJMP	0x0690
    00675 3044      CPI	R20,4
    00676 E0E0      LDI	R30,0
    00677 075E      CPC	R21,R30
    00678 F419      BNE	0x067C
(0393) 	    lcd_wcmd_2(0x0c);
    00679 E00C      LDI	R16,0xC
    0067A DD91      RCALL	_lcd_wcmd_2
(0394) 	 }else if(type==5){
    0067B C014      RJMP	0x0690
    0067C 3045      CPI	R20,5
    0067D E0E0      LDI	R30,0
    0067E 075E      CPC	R21,R30
    0067F F419      BNE	0x0683
(0395) 	    lcd_wcmd_2(0x0e);
    00680 E00E      LDI	R16,0xE
    00681 DD8A      RCALL	_lcd_wcmd_2
(0396) 	 }else if(type==6){
    00682 C00D      RJMP	0x0690
    00683 3046      CPI	R20,6
    00684 E0E0      LDI	R30,0
    00685 075E      CPC	R21,R30
    00686 F419      BNE	0x068A
(0397) 	    lcd_wcmd_2(0x0d);
    00687 E00D      LDI	R16,0xD
    00688 DD83      RCALL	_lcd_wcmd_2
(0398) 	 }else if(type==7){
    00689 C006      RJMP	0x0690
    0068A 3047      CPI	R20,7
    0068B E0E0      LDI	R30,0
    0068C 075E      CPC	R21,R30
    0068D F411      BNE	0x0690
(0399) 	    lcd_wcmd_2(0x0f);
    0068E E00F      LDI	R16,0xF
    0068F DD7C      RCALL	_lcd_wcmd_2
(0400) 	 }
    00690 9159      LD	R21,Y+
    00691 9149      LD	R20,Y+
    00692 9508      RET
(0401) }
(0402) //***************************************************
(0403) //   反白相关
(0404) //***************************************************
(0405) /********************************************************************  
(0406)     函 数 名：Set_Draw(  
(0407)     入口参数：无  
(0408)     出口参数：无  
(0409)     修改日期：  
(0410)     函数作用：  
(0411)     说    明：  
(0412)     ********************************************************************/   
(0413)     void Set_Draw(void)   
(0414)     {   
(0415)         //W_1byte(0,0,0x01);            //清屏   
(0416)         delay_ms(2);                  //延时   
_Set_Draw:
    00693 E002      LDI	R16,2
    00694 E010      LDI	R17,0
    00695 940E 00C9 CALL	_delay_ms
(0417)         //W_1byte(0,0,0x34);            //8BIT控制界面，扩充指令集,，绘图显示OFF   
(0418)         lcd_wcmd_1(0x36); 
    00697 E306      LDI	R16,0x36
    00698 DCEF      RCALL	_lcd_wcmd_1
(0419) 		lcd_wcmd_2(0x36);   
    00699 E306      LDI	R16,0x36
    0069A DD71      RCALL	_lcd_wcmd_2
(0420)         delay_ms(2);                  //延时   
    0069B E002      LDI	R16,2
    0069C E010      LDI	R17,0
    0069D 940C 00C9 JMP	_delay_ms
(0421)     }
(0422) 	void Set_UNDraw(void)   
(0423)     {   
(0424)         //W_1byte(0,0,0x01);            //清屏   
(0425)         delay_ms(2);                  //延时   
_Set_UNDraw:
    0069F E002      LDI	R16,2
    006A0 E010      LDI	R17,0
    006A1 940E 00C9 CALL	_delay_ms
(0426)         //W_1byte(0,0,0x34);            //8BIT控制界面，扩充指令集,，绘图显示OFF   
(0427)         lcd_wcmd_1(0x30); 
    006A3 E300      LDI	R16,0x30
    006A4 DCE3      RCALL	_lcd_wcmd_1
(0428) 		lcd_wcmd_2(0x30);   
    006A5 E300      LDI	R16,0x30
    006A6 DD65      RCALL	_lcd_wcmd_2
(0429)         delay_ms(2);                  //延时   
    006A7 E002      LDI	R16,2
    006A8 E010      LDI	R17,0
    006A9 940C 00C9 JMP	_delay_ms
_Set_White_off:
  clr_y                --> R14
  clr_x                --> R10
  white_y              --> R20
  white_x              --> Y,+0
  i                    --> R10
  white_end_x          --> R12
  j                    --> R14
  end_x                --> R10
  y                    --> R22
  x                    --> Y,+11
    006AB 940E 110A CALL	push_arg4
    006AD 940E 112A CALL	push_xgsetF0FC
    006AF 2F62      MOV	R22,R18
    006B0 9721      SBIW	R28,1
    006B1 84AF      LDD	R10,Y+15
(0430)     }
(0431) /**************************************************  
(0432)     uchar x,起始位置
(0433) 	uchar y,对应y
(0434) 	uchar end_x, 反白结束位置
(0435) 	uchar clear 0：反白，1：不反白
(0436)  **************************************************/   
(0437)     void Set_White_off(uchar x,uchar y,uchar end_x)   
(0438)     {   
(0439)         uchar i, j, white_x, white_y,white_end_x,clr_x,clr_y;       //   
(0440)         white_end_x = (end_x-x+1);   
    006B2 2D8A      MOV	R24,R10
    006B3 840B      LDD	R0,Y+11
    006B4 1980      SUB	R24,R0
    006B5 5F8F      SUBI	R24,0xFF
    006B6 2EC8      MOV	R12,R24
(0441)         white_end_x <<= 1;   //16*16，一次写8个，所以乘2
    006B7 0CCC      LSL	R12
(0442) 		Set_Draw(); //开画图
    006B8 DFDA      RCALL	_Set_Draw
(0443) 		delay_us(1); 
    006B9 E001      LDI	R16,1
    006BA E010      LDI	R17,0
    006BB 940E 00BF CALL	_delay_us
(0444)         if(y==0)   
    006BD 2366      TST	R22
    006BE F449      BNE	0x06C8
(0445)         {   
(0446)             white_x = (0x80+x-1);   
    006BF 858B      LDD	R24,Y+11
    006C0 5880      SUBI	R24,0x80
    006C1 5081      SUBI	R24,1
    006C2 8388      ST	Y,R24
(0447)             white_y = 0x80;   
    006C3 E840      LDI	R20,0x80
(0448)             clr_x = 0x80;   
    006C4 E880      LDI	R24,0x80
    006C5 2EA8      MOV	R10,R24
(0449)             clr_y = 0x80;   
    006C6 2EE8      MOV	R14,R24
(0450)         }   
    006C7 C022      RJMP	0x06EA
(0451)         else if(y==1)   
    006C8 3061      CPI	R22,1
    006C9 F451      BNE	0x06D4
(0452)         {   
(0453)             white_x = (0x80+x-1);   
    006CA 858B      LDD	R24,Y+11
    006CB 5880      SUBI	R24,0x80
    006CC 5081      SUBI	R24,1
    006CD 8388      ST	Y,R24
(0454)             white_y = 0x90;   
    006CE E940      LDI	R20,0x90
(0455)             clr_x = 0x80;   
    006CF E880      LDI	R24,0x80
    006D0 2EA8      MOV	R10,R24
(0456)             clr_y = 0x90;   
    006D1 E980      LDI	R24,0x90
    006D2 2EE8      MOV	R14,R24
(0457)         }   
    006D3 C016      RJMP	0x06EA
(0458)         else if(y==2)   
    006D4 3062      CPI	R22,2
    006D5 F449      BNE	0x06DF
(0459)         {   
(0460)             white_x = (0x80+x-1);   
    006D6 858B      LDD	R24,Y+11
    006D7 5880      SUBI	R24,0x80
    006D8 5081      SUBI	R24,1
    006D9 8388      ST	Y,R24
(0461)             white_y = 0x80;   
    006DA E840      LDI	R20,0x80
(0462)             clr_x = 0x80;   
    006DB E880      LDI	R24,0x80
    006DC 2EA8      MOV	R10,R24
(0463)             clr_y = 0x80;   
    006DD 2EE8      MOV	R14,R24
(0464)         }   
    006DE C00B      RJMP	0x06EA
(0465)         else if(y==3)   
    006DF 3063      CPI	R22,3
    006E0 F449      BNE	0x06EA
(0466)         {   
(0467)             white_x = (0x80+x-1);   
    006E1 858B      LDD	R24,Y+11
    006E2 5880      SUBI	R24,0x80
    006E3 5081      SUBI	R24,1
    006E4 8388      ST	Y,R24
(0468)             white_y = 0x90;   
    006E5 E940      LDI	R20,0x90
(0469)             clr_x = 0x80;   
    006E6 E880      LDI	R24,0x80
    006E7 2EA8      MOV	R10,R24
(0470)             clr_y = 0x90;   
    006E8 E980      LDI	R24,0x90
    006E9 2EE8      MOV	R14,R24
(0471)         }   
(0472)         delay_us(1); 
    006EA E001      LDI	R16,1
    006EB E010      LDI	R17,0
    006EC 940E 00BF CALL	_delay_us
(0473) 		if(y==0 || y==1){    
    006EE 2366      TST	R22
    006EF F011      BEQ	0x06F2
    006F0 3061      CPI	R22,1
    006F1 F4A1      BNE	0x0706
(0474)           for(i=0;i<16;i++ )               //16行，因为是16*16汉字   
    006F2 24AA      CLR	R10
    006F3 C00E      RJMP	0x0702
(0475)           {   
(0476)              lcd_wcmd_1(white_y++);     //设置绘图区的Y地址坐标0   
    006F4 2E24      MOV	R2,R20
    006F5 5F4F      SUBI	R20,0xFF
    006F6 2D02      MOV	R16,R2
    006F7 DC90      RCALL	_lcd_wcmd_1
(0477)              lcd_wcmd_1(white_x);       //设置绘图区的X地址坐标0   
    006F8 8108      LD	R16,Y
    006F9 DC8E      RCALL	_lcd_wcmd_1
(0478)              for(j=0;j<white_end_x;j++)   //   
    006FA 24EE      CLR	R14
    006FB C003      RJMP	0x06FF
(0479)              {     
(0480)                lcd_wdat_1(0x00); //取消这一行的8个点的反白，液晶地址自动加   
    006FC 2700      CLR	R16
    006FD DCB8      RCALL	_lcd_wdat_1
    006FE 94E3      INC	R14
    006FF 14EC      CP	R14,R12
    00700 F3D8      BCS	0x06FC
    00701 94A3      INC	R10
    00702 2D8A      MOV	R24,R10
    00703 3180      CPI	R24,0x10
    00704 F378      BCS	0x06F4
(0481)              }   
(0482)           }
(0483) 		}else if(y==2 || y==3){
    00705 C017      RJMP	0x071D
    00706 3062      CPI	R22,2
    00707 F011      BEQ	0x070A
    00708 3063      CPI	R22,3
    00709 F499      BNE	0x071D
(0484) 		    for(i=0;i<16;i++ )               //16行，因为是16*16汉字   
    0070A 24AA      CLR	R10
    0070B C00E      RJMP	0x071A
(0485)           {   
(0486)              lcd_wcmd_2(white_y++);     //设置绘图区的Y地址坐标0   
    0070C 2E24      MOV	R2,R20
    0070D 5F4F      SUBI	R20,0xFF
    0070E 2D02      MOV	R16,R2
    0070F DCFC      RCALL	_lcd_wcmd_2
(0487)              lcd_wcmd_2(white_x);       //设置绘图区的X地址坐标0   
    00710 8108      LD	R16,Y
    00711 DCFA      RCALL	_lcd_wcmd_2
(0488)              for(j=0;j<white_end_x;j++)   //   
    00712 24EE      CLR	R14
    00713 C003      RJMP	0x0717
(0489)              {     
(0490)                lcd_wdat_2(0x00); //取消这一行的8个点的反白，液晶地址自动加   
    00714 2700      CLR	R16
    00715 DD24      RCALL	_lcd_wdat_2
    00716 94E3      INC	R14
    00717 14EC      CP	R14,R12
    00718 F3D8      BCS	0x0714
    00719 94A3      INC	R10
    0071A 2D8A      MOV	R24,R10
    0071B 3180      CPI	R24,0x10
    0071C F378      BCS	0x070C
(0491)              }   
(0492)           }
(0493) 		}
(0494) 		  Set_UNDraw();//关画图  
    0071D DF81      RCALL	_Set_UNDraw
(0495) 		  delay_us(1);  
    0071E E001      LDI	R16,1
    0071F E010      LDI	R17,0
    00720 940E 00BF CALL	_delay_us
    00722 9621      ADIW	R28,1
    00723 940E 111F CALL	pop_xgsetF0FC
    00725 9624      ADIW	R28,4
    00726 9508      RET
_Set_White:
  clr_y                --> R14
  clr_x                --> R10
  white_y              --> R20
  white_x              --> Y,+0
  i                    --> R10
  white_end_x          --> R12
  j                    --> R14
  end_x                --> R10
  y                    --> R22
  x                    --> Y,+11
    00727 940E 110A CALL	push_arg4
    00729 940E 112A CALL	push_xgsetF0FC
    0072B 2F62      MOV	R22,R18
    0072C 9721      SBIW	R28,1
    0072D 84AF      LDD	R10,Y+15
(0496)     } 
(0497) 	void Set_White(uchar x,uchar y,uchar end_x)   
(0498)     {   
(0499)         uchar i, j, white_x, white_y,white_end_x,clr_x,clr_y;       //   
(0500)         white_end_x = (end_x-x+1);   
    0072E 2D8A      MOV	R24,R10
    0072F 840B      LDD	R0,Y+11
    00730 1980      SUB	R24,R0
    00731 5F8F      SUBI	R24,0xFF
    00732 2EC8      MOV	R12,R24
(0501)         white_end_x <<= 1;   //16*16，一次写8个，所以乘2
    00733 0CCC      LSL	R12
(0502) 		Set_Draw(); //开画图
    00734 DF5E      RCALL	_Set_Draw
(0503) 		delay_us(1); 
    00735 E001      LDI	R16,1
    00736 E010      LDI	R17,0
    00737 940E 00BF CALL	_delay_us
(0504)         if(y==0)   
    00739 2366      TST	R22
    0073A F449      BNE	0x0744
(0505)         {   
(0506)             white_x = (0x80+x-1);   
    0073B 858B      LDD	R24,Y+11
    0073C 5880      SUBI	R24,0x80
    0073D 5081      SUBI	R24,1
    0073E 8388      ST	Y,R24
(0507)             white_y = 0x80;   
    0073F E840      LDI	R20,0x80
(0508)             clr_x = 0x80;   
    00740 E880      LDI	R24,0x80
    00741 2EA8      MOV	R10,R24
(0509)             clr_y = 0x80;   
    00742 2EE8      MOV	R14,R24
(0510)         }   
    00743 C022      RJMP	0x0766
(0511)         else if(y==1)   
    00744 3061      CPI	R22,1
    00745 F451      BNE	0x0750
(0512)         {   
(0513)             white_x = (0x80+x-1);   
    00746 858B      LDD	R24,Y+11
    00747 5880      SUBI	R24,0x80
    00748 5081      SUBI	R24,1
    00749 8388      ST	Y,R24
(0514)             white_y = 0x90;   
    0074A E940      LDI	R20,0x90
(0515)             clr_x = 0x80;   
    0074B E880      LDI	R24,0x80
    0074C 2EA8      MOV	R10,R24
(0516)             clr_y = 0x90;   
    0074D E980      LDI	R24,0x90
    0074E 2EE8      MOV	R14,R24
(0517)         }   
    0074F C016      RJMP	0x0766
(0518)         else if(y==2)   
    00750 3062      CPI	R22,2
    00751 F449      BNE	0x075B
(0519)         {   
(0520)             white_x = (0x80+x-1);   
    00752 858B      LDD	R24,Y+11
    00753 5880      SUBI	R24,0x80
    00754 5081      SUBI	R24,1
    00755 8388      ST	Y,R24
(0521)             white_y = 0x80;   
    00756 E840      LDI	R20,0x80
(0522)             clr_x = 0x80;   
    00757 E880      LDI	R24,0x80
    00758 2EA8      MOV	R10,R24
(0523)             clr_y = 0x80;   
    00759 2EE8      MOV	R14,R24
(0524)         }   
    0075A C00B      RJMP	0x0766
(0525)         else if(y==3)   
    0075B 3063      CPI	R22,3
    0075C F449      BNE	0x0766
(0526)         {   
(0527)             white_x = (0x80+x-1);   
    0075D 858B      LDD	R24,Y+11
    0075E 5880      SUBI	R24,0x80
    0075F 5081      SUBI	R24,1
    00760 8388      ST	Y,R24
(0528)             white_y = 0x90;   
    00761 E940      LDI	R20,0x90
(0529)             clr_x = 0x80;   
    00762 E880      LDI	R24,0x80
    00763 2EA8      MOV	R10,R24
(0530)             clr_y = 0x90;   
    00764 E980      LDI	R24,0x90
    00765 2EE8      MOV	R14,R24
(0531)         } 
(0532) 		if(y==0 || y==1){          
    00766 2366      TST	R22
    00767 F011      BEQ	0x076A
    00768 3061      CPI	R22,1
    00769 F4A1      BNE	0x077E
(0533)           for(i=0;i<16;i++ )               //16行，因为是16*16汉字   
    0076A 24AA      CLR	R10
    0076B C00E      RJMP	0x077A
(0534)           {   
(0535)               lcd_wcmd_1(white_y++);     //设置绘图区的Y地址坐标0   
    0076C 2E24      MOV	R2,R20
    0076D 5F4F      SUBI	R20,0xFF
    0076E 2D02      MOV	R16,R2
    0076F DC18      RCALL	_lcd_wcmd_1
(0536)               lcd_wcmd_1(white_x);       //设置绘图区的X地址坐标0   
    00770 8108      LD	R16,Y
    00771 DC16      RCALL	_lcd_wcmd_1
(0537)               for(j=0;j<white_end_x;j++)   //   
    00772 24EE      CLR	R14
    00773 C003      RJMP	0x0777
(0538)               {    
(0539)                     lcd_wdat_1(0xff); //反白这一行的8个点，液晶地址自动加1     
    00774 EF0F      LDI	R16,0xFF
    00775 DC40      RCALL	_lcd_wdat_1
    00776 94E3      INC	R14
    00777 14EC      CP	R14,R12
    00778 F3D8      BCS	0x0774
    00779 94A3      INC	R10
    0077A 2D8A      MOV	R24,R10
    0077B 3180      CPI	R24,0x10
    0077C F378      BCS	0x076C
(0540)               }   
(0541)           }
(0542) 		}else if(y==2 || y==3){
    0077D C017      RJMP	0x0795
    0077E 3062      CPI	R22,2
    0077F F011      BEQ	0x0782
    00780 3063      CPI	R22,3
    00781 F499      BNE	0x0795
(0543) 		   for(i=0;i<16;i++ )               //16行，因为是16*16汉字   
    00782 24AA      CLR	R10
    00783 C00E      RJMP	0x0792
(0544)             {   
(0545)               lcd_wcmd_2(white_y++);     //设置绘图区的Y地址坐标0   
    00784 2E24      MOV	R2,R20
    00785 5F4F      SUBI	R20,0xFF
    00786 2D02      MOV	R16,R2
    00787 DC84      RCALL	_lcd_wcmd_2
(0546)               lcd_wcmd_2(white_x);       //设置绘图区的X地址坐标0   
    00788 8108      LD	R16,Y
    00789 DC82      RCALL	_lcd_wcmd_2
(0547)               for(j=0;j<white_end_x;j++)   //   
    0078A 24EE      CLR	R14
    0078B C003      RJMP	0x078F
(0548)               {    
(0549)                     lcd_wdat_2(0xff); //反白这一行的8个点，液晶地址自动加1     
    0078C EF0F      LDI	R16,0xFF
    0078D DCAC      RCALL	_lcd_wdat_2
    0078E 94E3      INC	R14
    0078F 14EC      CP	R14,R12
    00790 F3D8      BCS	0x078C
    00791 94A3      INC	R10
    00792 2D8A      MOV	R24,R10
    00793 3180      CPI	R24,0x10
    00794 F378      BCS	0x0784
(0550)               }   
(0551)             }
(0552) 		}
(0553) 		  Set_UNDraw();//关画图  
    00795 DF09      RCALL	_Set_UNDraw
(0554) 		  delay_us(1);  
    00796 E001      LDI	R16,1
    00797 E010      LDI	R17,0
    00798 940E 00BF CALL	_delay_us
    0079A 9621      ADIW	R28,1
    0079B 940E 111F CALL	pop_xgsetF0FC
    0079D 9624      ADIW	R28,4
    0079E 9508      RET
_lcd_Desk:
    0079F 9722      SBIW	R28,2
(0555)     } 
(0556) 	/********************************************************************  
(0557)     函 数 名：Draw_Pic  128*64  
(0558)     入口参数：x,y,*Draw  
(0559)     出口参数：无  
(0560)     建立日期：2007年8月26日  
(0561)     修改日期：  
(0562)     函数作用：  
(0563)     说    明：  
(0564)     ********************************************************************/   
(0565)     /*************************************************/   
(0566)     /*   
(0567)     void Draw_Pic(uchar x, uchar y, const uchar *Draw)   
(0568)     {   
(0569)         uchar i, j, temp_x, temp_y;     //   
(0570)         temp_x = x;                     //   
(0571)         temp_y = y;                     //   
(0572)         temp_x |= 0x80;                 //   
(0573)         temp_y |= 0x80;                 //   
(0574)         for(i=0;i<32;i++ )               //上半屏32行   
(0575)         {   
(0576)             lcd_wcmd_1(0,0,temp_y++);      //设置绘图区的Y地址坐标0   
(0577)             lcd_wcmd_1(0,0,temp_x);        //设置绘图区的X地址坐标0   
(0578)             for(j=0;j<16;j++)            //   
(0579)             {   
(0580)                  lcd_wdat_2(0,1,*Draw++);  //   
(0581)             }   
(0582)         }   
(0583)            
(0584)         temp_x = 0x88;                  //   
(0585)         temp_y = 0x80;                  //   
(0586)         j = 0;                          //   
(0587)         for(;i<64;i++ )   
(0588)         {   
(0589)             lcd_wcmd_1(temp_y++);      //设置绘图区的Y地址坐标   
(0590)             lcd_wdat_2(temp_x);        //设置绘图区的X地址坐标   
(0591)             for(j=0;j<16;j++)   
(0592)             {   
(0593)                  lcd_wdat_2(0,1,*Draw++);  //   
(0594)             }   
(0595)         }   
(0596)             
(0597)     } */    
(0598)     /*************************************************/  
(0599) //***********************************************************************
(0600) //      液晶显示界面初始化
(0601) //***********************************************************************
(0602) void lcd_Desk(void)
(0603) { 
(0604)   //uint i=0;   
(0605)  // lcd_clear();
(0606)   //lcd_write_str(0,0,"ADC0:");
(0607)   lcd_write_str(0,3,"反白测试第一次");
    007A0 E084      LDI	R24,4
    007A1 E091      LDI	R25,1
    007A2 8399      STD	Y+1,R25
    007A3 8388      ST	Y,R24
    007A4 E023      LDI	R18,3
    007A5 2700      CLR	R16
    007A6 DD1B      RCALL	_lcd_write_str
(0608)   lcd_write_str(0,0,"反白测试第一次");
    007A7 E084      LDI	R24,4
    007A8 E091      LDI	R25,1
    007A9 8399      STD	Y+1,R25
    007AA 8388      ST	Y,R24
    007AB 2722      CLR	R18
    007AC 2700      CLR	R16
    007AD DD14      RCALL	_lcd_write_str
(0609)   //delay_ms(100);
(0610)      
(0611)     Set_White(1,1,7); 
    007AE E087      LDI	R24,7
    007AF 8388      ST	Y,R24
    007B0 E021      LDI	R18,1
    007B1 E001      LDI	R16,1
    007B2 DF74      RCALL	_Set_White
(0612) 	   
(0613) 	 
(0614)     delay_ms(3000); 
    007B3 EB08      LDI	R16,0xB8
    007B4 E01B      LDI	R17,0xB
    007B5 940E 00C9 CALL	_delay_ms
(0615)      Set_White_off(1,1,7);
    007B7 E087      LDI	R24,7
    007B8 8388      ST	Y,R24
    007B9 E021      LDI	R18,1
    007BA E001      LDI	R16,1
    007BB DEEF      RCALL	_Set_White_off
(0616) 	Set_White(2,1,2); 
    007BC E082      LDI	R24,2
    007BD 8388      ST	Y,R24
    007BE E021      LDI	R18,1
    007BF E002      LDI	R16,2
    007C0 DF66      RCALL	_Set_White
(0617) 	 delay_ms(300); 
    007C1 E20C      LDI	R16,0x2C
    007C2 E011      LDI	R17,1
    007C3 940E 00C9 CALL	_delay_ms
(0618) 	 Set_White_off(2,2,7);
    007C5 E087      LDI	R24,7
    007C6 8388      ST	Y,R24
    007C7 E022      LDI	R18,2
    007C8 E002      LDI	R16,2
    007C9 DEE1      RCALL	_Set_White_off
(0619) 	 Set_White(3,1,5);   
    007CA E085      LDI	R24,5
    007CB 8388      ST	Y,R24
    007CC E021      LDI	R18,1
    007CD E003      LDI	R16,3
    007CE DF58      RCALL	_Set_White
    007CF 9622      ADIW	R28,2
    007D0 9508      RET
_main:
  data                 --> Y,+2
    007D1 9721      SBIW	R28,1
FILE: E:\ICCDemo\Temp_Control\temp_control\main.c
(0001) 
(0002) #include<iom128v.h>
(0003) #include "main.h"
(0004) #include "lcd.h"
(0005) #include "time.h"
(0006) #include "key.h"
(0007) #include "delay.h"
(0008) #include "timertask.h"
(0009) #include "eeprom.h"
(0010) #include "pages.h"
(0011) //下面两个要删掉，现在为编译暂时不删
(0012)  unsigned int temp_h=0;
(0013)  unsigned int temp_l=0;
(0014)  //uart需要参数
(0015)  unsigned char send_buf[600];
(0016)  unsigned char receive_buf[600];
(0017)  unsigned int send_len;
(0018)  unsigned int receive_len;
(0019)  //界面需要参数
(0020)  unsigned int pageNum;//当前页面，如需跳转改变这个值就行
(0021)  unsigned int pageParam[5];//传递参数。界面间参数暂存
(0022)  unsigned int prePageNum; //上一界面
(0023)  //**************
(0024) struct temp temps[4]={{0},{0},{0},{0}};
(0025) 
(0026) 
(0027) //*************************************************************************
(0028) //			主程序
(0029) //*************************************************************************
(0030) void main(void)
(0031) { 
(0032)   uchar data;
(0033) temps[0].flag=0;
    007D2 2422      CLR	R2
    007D3 2433      CLR	R3
    007D4 9230 0118 STS	temps+1,R3
    007D6 9220 0117 STS	temps,R2
(0034)  temps[1].flag=1;
    007D8 E081      LDI	R24,1
    007D9 E090      LDI	R25,0
    007DA 9390 011A STS	temps+3,R25
    007DC 9380 0119 STS	temps+2,R24
(0035)  temps[2].flag=2;
    007DE E082      LDI	R24,2
    007DF 9390 011C STS	temps+5,R25
    007E1 9380 011B STS	temps+4,R24
(0036)  temps[3].flag=5; 
    007E3 E085      LDI	R24,5
    007E4 9390 011E STS	temps+7,R25
    007E6 9380 011D STS	temps+6,R24
(0037)   DDRE=0xFF;
    007E8 EF8F      LDI	R24,0xFF
    007E9 B982      OUT	0x02,R24
(0038)   SREG|=0x80;//开中断
    007EA 9478      BSET	7
(0039)   lcd_init();
    007EB 940E 0606 CALL	_lcd_init
(0040)   lcd_clear(); 
    007ED 940E 0579 CALL	_lcd_clear
(0041)   pageNum=1;
    007EF E081      LDI	R24,1
    007F0 E090      LDI	R25,0
    007F1 9390 066C STS	pageNum+1,R25
    007F3 9380 066B STS	pageNum,R24
(0042)  Set_White_off(1,0,12);
    007F5 E08C      LDI	R24,0xC
    007F6 8388      ST	Y,R24
    007F7 2722      CLR	R18
    007F8 E001      LDI	R16,1
    007F9 940E 06AB CALL	_Set_White_off
(0043) 	 Set_White_off(1,1,12);
    007FB E08C      LDI	R24,0xC
    007FC 8388      ST	Y,R24
    007FD E021      LDI	R18,1
    007FE E001      LDI	R16,1
    007FF 940E 06AB CALL	_Set_White_off
(0044) 	 Set_White_off(1,2,12);
    00801 E08C      LDI	R24,0xC
    00802 8388      ST	Y,R24
    00803 E022      LDI	R18,2
    00804 E001      LDI	R16,1
    00805 940E 06AB CALL	_Set_White_off
(0045) 	 Set_White_off(1,3,12);
    00807 E08C      LDI	R24,0xC
    00808 8388      ST	Y,R24
    00809 E023      LDI	R18,3
    0080A E001      LDI	R16,1
    0080B 940E 06AB CALL	_Set_White_off
    0080D C002      RJMP	0x0810
(0046) 	 while(1){
(0047)      dispatchPages();
    0080E 940E 10BC CALL	_dispatchPages
    00810 CFFD      RJMP	0x080E
    00811 9621      ADIW	R28,1
    00812 9508      RET
FILE: E:\ICCDemo\Temp_Control\temp_control\timertask.c
(0001) #include<iom128v.h>
(0002) #include "timertask.h"
(0003) #include "time.h"
(0004) #include "lcd.h"
(0005) #include "delay.h"
(0006) unsigned char time_h_1, time_l_1,time_h_3, time_l_3,time_0, time_2,i;
(0007) //************************************************
(0008) //16位定时器，定时器1
(0009) //*************************************************
(0010) /*
(0011)   计数器1，16位的。普通计时，1024分频。在16M下约0.061ms计数一次。共4s钟,
(0012)   自行计算时间传入。传入高低八位
(0013) */
(0014) void Timerinit_1(uchar time_h,uchar time_l){
(0015)     time_h_1=time_h;
_Timerinit_1:
  time_l               --> R18
  time_h               --> R16
    00813 9300 0673 STS	time_h_1,R16
(0016) 	time_l_1=time_l;
    00815 9320 0672 STS	time_l_1,R18
(0017) 	 TCCR1B=0x00;
    00817 2422      CLR	R2
    00818 BC2E      OUT	0x2E,R2
(0018) 	//写入初值
(0019)     TCNT1H=time_h;
    00819 BD0D      OUT	0x2D,R16
(0020)     TCNT1L=time_l;
    0081A BD2C      OUT	0x2C,R18
(0021) 	//普通计数，1024分频
(0022)     TCCR1A=0x00;
    0081B BC2F      OUT	0x2F,R2
(0023)     TCCR1B=0x05;
    0081C E085      LDI	R24,5
    0081D BD8E      OUT	0x2E,R24
(0024) 	 TIMSK|=0x04;//开定时器1溢出中断,16位的
    0081E B787      IN	R24,0x37
    0081F 6084      ORI	R24,4
    00820 BF87      OUT	0x37,R24
    00821 9508      RET
(0025) }
(0026) //************************************************
(0027) //16位定时器，定时器3
(0028) //*************************************************
(0029) /*
(0030)   计数器1，16位的。普通计时，1024分频。在16M下约0.061ms计数一次。共4s钟,
(0031)   自行计算时间传入。传入高低八位
(0032) */
(0033) void Timerinit_3(uchar time_h,uchar time_l){
(0034)  	time_h_3=time_h;
_Timerinit_3:
  time_l               --> R18
  time_h               --> R16
    00822 9300 0671 STS	time_h_3,R16
(0035) 	time_l_3=time_l;
    00824 9320 0670 STS	time_l_3,R18
(0036) 	//写入初值
(0037) 	 TCCR3B=0x00;
    00826 2422      CLR	R2
    00827 9220 008A STS	0x8A,R2
(0038)     TCNT3H=time_h;
    00829 9300 0089 STS	0x89,R16
(0039)     TCNT3L=time_l;
    0082B 9320 0088 STS	0x88,R18
(0040) 	//普通计数，1024分频
(0041)     TCCR3A=0x00;
    0082D 9220 008B STS	0x8B,R2
(0042)     TCCR3B=0x05;
    0082F E085      LDI	R24,5
    00830 9380 008A STS	0x8A,R24
(0043) 	ETIMSK |=0x04;//开外部中断1
    00832 9180 007D LDS	R24,0x7D
    00834 6084      ORI	R24,4
    00835 9380 007D STS	0x7D,R24
    00837 9508      RET
(0044) }
(0045) //************************************************
(0046) //8位定时器，定时器0
(0047) //*************************************************
(0048) 
(0049) /*
(0050)   计数器0，8位的。普通计时，1024分频。
(0051)   自行计算时间传入。
(0052) */
(0053) void Timerinit_0(uchar time){
(0054)     time_0=time;
_Timerinit_0:
  time                 --> R16
    00838 9300 066F STS	time_0,R16
(0055) 	//写入初值
(0056)     TCNT0=time;
    0083A BF02      OUT	0x32,R16
(0057) 	TIMSK|=0x01;//开定时器0溢出中断,8位的
    0083B B787      IN	R24,0x37
    0083C 6081      ORI	R24,1
    0083D BF87      OUT	0x37,R24
(0058) 	 TCCR0=0x07;//普通计数，1024分频
    0083E E087      LDI	R24,7
    0083F BF83      OUT	0x33,R24
    00840 9508      RET
(0059) }
(0060) //************************************************
(0061) //8位定时器，定时器2
(0062) //*************************************************
(0063) /*
(0064)   计数器0，8位的。普通计时，1024分频。
(0065)   自行计算时间传入。
(0066) */
(0067) void Timerinit_2(uchar time){
(0068)     time_2=time;
_Timerinit_2:
  time                 --> R16
    00841 9300 066E STS	time_2,R16
(0069) 	//写入初值
(0070)     TCNT2=time;
    00843 BD04      OUT	0x24,R16
(0071) 	TIMSK|=0x40;//开定时器0溢出中断,8位的
    00844 B787      IN	R24,0x37
    00845 6480      ORI	R24,0x40
    00846 BF87      OUT	0x37,R24
(0072) 	//普通计数，1024分频
(0073)     TCCR2=0x05;
    00847 E085      LDI	R24,5
    00848 BD85      OUT	0x25,R24
    00849 9508      RET
_int_timer0:
    0084A 920A      ST	-Y,R0
    0084B 921A      ST	-Y,R1
    0084C 922A      ST	-Y,R2
    0084D 923A      ST	-Y,R3
    0084E 924A      ST	-Y,R4
    0084F 925A      ST	-Y,R5
    00850 926A      ST	-Y,R6
    00851 927A      ST	-Y,R7
    00852 928A      ST	-Y,R8
    00853 929A      ST	-Y,R9
    00854 930A      ST	-Y,R16
    00855 931A      ST	-Y,R17
    00856 932A      ST	-Y,R18
    00857 933A      ST	-Y,R19
    00858 938A      ST	-Y,R24
    00859 939A      ST	-Y,R25
    0085A 93AA      ST	-Y,R26
    0085B 93BA      ST	-Y,R27
    0085C 93EA      ST	-Y,R30
    0085D 93FA      ST	-Y,R31
    0085E B60F      IN	R0,0x3F
    0085F 920A      ST	-Y,R0
    00860 9721      SBIW	R28,1
(0074) }
(0075) #pragma interrupt_handler int_timer0:17
(0076) void int_timer0(void){ 
(0077) 		TCCR0=0x00;
    00861 2422      CLR	R2
    00862 BE23      OUT	0x33,R2
(0078) 		//adc_init_once();
(0079) 		for(i=0;i<5;i++){
    00863 9220 066D STS	i,R2
    00865 C011      RJMP	0x0877
(0080)   		 lcd_write_char(0x01,3,0x30+i);	
    00866 9180 066D LDS	R24,i
    00868 5D80      SUBI	R24,0xD0
    00869 8388      ST	Y,R24
    0086A E023      LDI	R18,3
    0086B E001      LDI	R16,1
    0086C 940E 049C CALL	_lcd_write_char
(0081) 		 delay_ms(100);		
    0086E E604      LDI	R16,0x64
    0086F E010      LDI	R17,0
    00870 940E 00C9 CALL	_delay_ms
    00872 9180 066D LDS	R24,i
    00874 5F8F      SUBI	R24,0xFF
    00875 9380 066D STS	i,R24
    00877 9180 066D LDS	R24,i
    00879 3085      CPI	R24,5
    0087A F358      BCS	0x0866
(0082)         }
(0083) 		TCNT0=time_0;
    0087B 9020 066F LDS	R2,time_0
    0087D BE22      OUT	0x32,R2
(0084) 		TCCR0=0x07;
    0087E E087      LDI	R24,7
    0087F BF83      OUT	0x33,R24
(0085) 		return;
    00880 9621      ADIW	R28,1
    00881 9009      LD	R0,Y+
    00882 BE0F      OUT	0x3F,R0
    00883 91F9      LD	R31,Y+
    00884 91E9      LD	R30,Y+
    00885 91B9      LD	R27,Y+
    00886 91A9      LD	R26,Y+
    00887 9199      LD	R25,Y+
    00888 9189      LD	R24,Y+
    00889 9139      LD	R19,Y+
    0088A 9129      LD	R18,Y+
    0088B 9119      LD	R17,Y+
    0088C 9109      LD	R16,Y+
    0088D 9099      LD	R9,Y+
    0088E 9089      LD	R8,Y+
    0088F 9079      LD	R7,Y+
    00890 9069      LD	R6,Y+
    00891 9059      LD	R5,Y+
    00892 9049      LD	R4,Y+
    00893 9039      LD	R3,Y+
    00894 9029      LD	R2,Y+
    00895 9019      LD	R1,Y+
    00896 9009      LD	R0,Y+
    00897 9518      RETI
_int_timer1:
    00898 920A      ST	-Y,R0
    00899 921A      ST	-Y,R1
    0089A 922A      ST	-Y,R2
    0089B 923A      ST	-Y,R3
    0089C 924A      ST	-Y,R4
    0089D 925A      ST	-Y,R5
    0089E 926A      ST	-Y,R6
    0089F 927A      ST	-Y,R7
    008A0 928A      ST	-Y,R8
    008A1 929A      ST	-Y,R9
    008A2 930A      ST	-Y,R16
    008A3 931A      ST	-Y,R17
    008A4 932A      ST	-Y,R18
    008A5 933A      ST	-Y,R19
    008A6 938A      ST	-Y,R24
    008A7 939A      ST	-Y,R25
    008A8 93AA      ST	-Y,R26
    008A9 93BA      ST	-Y,R27
    008AA 93EA      ST	-Y,R30
    008AB 93FA      ST	-Y,R31
    008AC B60F      IN	R0,0x3F
    008AD 920A      ST	-Y,R0
    008AE 9721      SBIW	R28,1
(0086) }
(0087) //溢出中断。
(0088) #pragma interrupt_handler int_timer1:15
(0089) void int_timer1(void){
(0090) 		 TCCR1B=0x00;
    008AF 2422      CLR	R2
    008B0 BC2E      OUT	0x2E,R2
(0091) 		//adc_init_once();
(0092) 		for(i=0;i<5;i++){
    008B1 9220 066D STS	i,R2
    008B3 C011      RJMP	0x08C5
(0093)   		 lcd_write_char(0x03,3,0x30+i);	
    008B4 9180 066D LDS	R24,i
    008B6 5D80      SUBI	R24,0xD0
    008B7 8388      ST	Y,R24
    008B8 E023      LDI	R18,3
    008B9 E003      LDI	R16,3
    008BA 940E 049C CALL	_lcd_write_char
(0094) 		 delay_ms(100);		
    008BC E604      LDI	R16,0x64
    008BD E010      LDI	R17,0
    008BE 940E 00C9 CALL	_delay_ms
    008C0 9180 066D LDS	R24,i
    008C2 5F8F      SUBI	R24,0xFF
    008C3 9380 066D STS	i,R24
    008C5 9180 066D LDS	R24,i
    008C7 3085      CPI	R24,5
    008C8 F358      BCS	0x08B4
(0095)         }
(0096) 		TCNT1H=time_h_1;
    008C9 9020 0673 LDS	R2,time_h_1
    008CB BC2D      OUT	0x2D,R2
(0097)          TCNT1L=time_l_1;
    008CC 9020 0672 LDS	R2,time_l_1
    008CE BC2C      OUT	0x2C,R2
(0098) 		 TCCR1B=0x05;
    008CF E085      LDI	R24,5
    008D0 BD8E      OUT	0x2E,R24
(0099) 		return;
    008D1 9621      ADIW	R28,1
    008D2 9009      LD	R0,Y+
    008D3 BE0F      OUT	0x3F,R0
    008D4 91F9      LD	R31,Y+
    008D5 91E9      LD	R30,Y+
    008D6 91B9      LD	R27,Y+
    008D7 91A9      LD	R26,Y+
    008D8 9199      LD	R25,Y+
    008D9 9189      LD	R24,Y+
    008DA 9139      LD	R19,Y+
    008DB 9129      LD	R18,Y+
    008DC 9119      LD	R17,Y+
    008DD 9109      LD	R16,Y+
    008DE 9099      LD	R9,Y+
    008DF 9089      LD	R8,Y+
    008E0 9079      LD	R7,Y+
    008E1 9069      LD	R6,Y+
    008E2 9059      LD	R5,Y+
    008E3 9049      LD	R4,Y+
    008E4 9039      LD	R3,Y+
    008E5 9029      LD	R2,Y+
    008E6 9019      LD	R1,Y+
    008E7 9009      LD	R0,Y+
    008E8 9518      RETI
_int_timer2:
    008E9 920A      ST	-Y,R0
    008EA 921A      ST	-Y,R1
    008EB 922A      ST	-Y,R2
    008EC 923A      ST	-Y,R3
    008ED 924A      ST	-Y,R4
    008EE 925A      ST	-Y,R5
    008EF 926A      ST	-Y,R6
    008F0 927A      ST	-Y,R7
    008F1 928A      ST	-Y,R8
    008F2 929A      ST	-Y,R9
    008F3 930A      ST	-Y,R16
    008F4 931A      ST	-Y,R17
    008F5 932A      ST	-Y,R18
    008F6 933A      ST	-Y,R19
    008F7 938A      ST	-Y,R24
    008F8 939A      ST	-Y,R25
    008F9 93AA      ST	-Y,R26
    008FA 93BA      ST	-Y,R27
    008FB 93EA      ST	-Y,R30
    008FC 93FA      ST	-Y,R31
    008FD B60F      IN	R0,0x3F
    008FE 920A      ST	-Y,R0
    008FF 9721      SBIW	R28,1
(0100) }
(0101) #pragma interrupt_handler int_timer2:11
(0102) void int_timer2(void){
(0103)       PORTE=~PORTE;
    00900 B023      IN	R2,0x03
    00901 9420      COM	R2
    00902 B823      OUT	0x03,R2
(0104) 		TCCR2=0x00;
    00903 2422      CLR	R2
    00904 BC25      OUT	0x25,R2
(0105) 		for(i=0;i<5;i++){
    00905 9220 066D STS	i,R2
    00907 C011      RJMP	0x0919
(0106)   		 lcd_write_char(0x00,3,0x30+i);	
    00908 9180 066D LDS	R24,i
    0090A 5D80      SUBI	R24,0xD0
    0090B 8388      ST	Y,R24
    0090C E023      LDI	R18,3
    0090D 2700      CLR	R16
    0090E 940E 049C CALL	_lcd_write_char
(0107) 		 delay_ms(100);		
    00910 E604      LDI	R16,0x64
    00911 E010      LDI	R17,0
    00912 940E 00C9 CALL	_delay_ms
    00914 9180 066D LDS	R24,i
    00916 5F8F      SUBI	R24,0xFF
    00917 9380 066D STS	i,R24
    00919 9180 066D LDS	R24,i
    0091B 3085      CPI	R24,5
    0091C F358      BCS	0x0908
(0108)         }
(0109) 		TCNT2=time_2;
    0091D 9020 066E LDS	R2,time_2
    0091F BC24      OUT	0x24,R2
(0110) 		TCCR2=0x05;
    00920 E085      LDI	R24,5
    00921 BD85      OUT	0x25,R24
(0111) 		return;
    00922 9621      ADIW	R28,1
    00923 9009      LD	R0,Y+
    00924 BE0F      OUT	0x3F,R0
    00925 91F9      LD	R31,Y+
    00926 91E9      LD	R30,Y+
    00927 91B9      LD	R27,Y+
    00928 91A9      LD	R26,Y+
    00929 9199      LD	R25,Y+
    0092A 9189      LD	R24,Y+
    0092B 9139      LD	R19,Y+
    0092C 9129      LD	R18,Y+
    0092D 9119      LD	R17,Y+
    0092E 9109      LD	R16,Y+
    0092F 9099      LD	R9,Y+
    00930 9089      LD	R8,Y+
    00931 9079      LD	R7,Y+
    00932 9069      LD	R6,Y+
    00933 9059      LD	R5,Y+
    00934 9049      LD	R4,Y+
    00935 9039      LD	R3,Y+
    00936 9029      LD	R2,Y+
    00937 9019      LD	R1,Y+
    00938 9009      LD	R0,Y+
    00939 9518      RETI
_int_timer3:
    0093A 920A      ST	-Y,R0
    0093B 921A      ST	-Y,R1
    0093C 922A      ST	-Y,R2
    0093D 923A      ST	-Y,R3
    0093E 924A      ST	-Y,R4
    0093F 925A      ST	-Y,R5
    00940 926A      ST	-Y,R6
    00941 927A      ST	-Y,R7
    00942 928A      ST	-Y,R8
    00943 929A      ST	-Y,R9
    00944 930A      ST	-Y,R16
    00945 931A      ST	-Y,R17
    00946 932A      ST	-Y,R18
    00947 933A      ST	-Y,R19
    00948 938A      ST	-Y,R24
    00949 939A      ST	-Y,R25
    0094A 93AA      ST	-Y,R26
    0094B 93BA      ST	-Y,R27
    0094C 93EA      ST	-Y,R30
    0094D 93FA      ST	-Y,R31
    0094E B60F      IN	R0,0x3F
    0094F 920A      ST	-Y,R0
    00950 9721      SBIW	R28,1
(0112) }
(0113) //16位定时器，定时器3溢出中断。
(0114) #pragma interrupt_handler int_timer3:30
(0115) void int_timer3(void){
(0116)     TCCR1B=0x00;
    00951 2422      CLR	R2
    00952 BC2E      OUT	0x2E,R2
(0117)      for(i=0;i<5;i++){
    00953 9220 066D STS	i,R2
    00955 C011      RJMP	0x0967
(0118)   		 lcd_write_char(0x02,3,0x30+i);	
    00956 9180 066D LDS	R24,i
    00958 5D80      SUBI	R24,0xD0
    00959 8388      ST	Y,R24
    0095A E023      LDI	R18,3
    0095B E002      LDI	R16,2
    0095C 940E 049C CALL	_lcd_write_char
(0119) 		 delay_ms(100);		
    0095E E604      LDI	R16,0x64
    0095F E010      LDI	R17,0
    00960 940E 00C9 CALL	_delay_ms
    00962 9180 066D LDS	R24,i
    00964 5F8F      SUBI	R24,0xFF
    00965 9380 066D STS	i,R24
    00967 9180 066D LDS	R24,i
    00969 3085      CPI	R24,5
    0096A F358      BCS	0x0956
(0120)         }
(0121) 	TCNT3H=time_h_3;
    0096B 9020 0671 LDS	R2,time_h_3
    0096D 9220 0089 STS	0x89,R2
(0122)     TCNT3L=time_l_3;
    0096F 9020 0670 LDS	R2,time_l_3
    00971 9220 0088 STS	0x88,R2
(0123) 	 TCCR1B=0x05;
    00973 E085      LDI	R24,5
    00974 BD8E      OUT	0x2E,R24
    00975 9621      ADIW	R28,1
    00976 9009      LD	R0,Y+
    00977 BE0F      OUT	0x3F,R0
    00978 91F9      LD	R31,Y+
    00979 91E9      LD	R30,Y+
    0097A 91B9      LD	R27,Y+
    0097B 91A9      LD	R26,Y+
    0097C 9199      LD	R25,Y+
    0097D 9189      LD	R24,Y+
    0097E 9139      LD	R19,Y+
    0097F 9129      LD	R18,Y+
    00980 9119      LD	R17,Y+
    00981 9109      LD	R16,Y+
    00982 9099      LD	R9,Y+
    00983 9089      LD	R8,Y+
    00984 9079      LD	R7,Y+
    00985 9069      LD	R6,Y+
    00986 9059      LD	R5,Y+
    00987 9049      LD	R4,Y+
    00988 9039      LD	R3,Y+
    00989 9029      LD	R2,Y+
    0098A 9019      LD	R1,Y+
    0098B 9009      LD	R0,Y+
    0098C 9518      RETI
_readTemp_1:
  i                    --> R20
    0098D 934A      ST	-Y,R20
    0098E 935A      ST	-Y,R21
FILE: E:\ICCDemo\Temp_Control\temp_control\max6675.c
(0001) #include<iom128v.h>
(0002) #include "max6675.h"
(0003) #include "main.h"
(0004) #include "delay.h"
(0005) #define sck_h_1 PORTE|=(1<<PE3) 
(0006) #define sck_l_1 PORTE&=~(1<<PE3) 
(0007) #define cs_h_1 PORTE|=1<<PE4 
(0008) #define cs_l_1 PORTE&=~(1<<PE4) 
(0009) 
(0010) #define sck_h_2 PORTE|=(1<<PE6) 
(0011) #define sck_l_2 PORTE&=~(1<<PE6) 
(0012) #define cs_h_2 PORTE|=1<<PE7 
(0013) #define cs_l_2 PORTE&=~(1<<PE7) 
(0014) 
(0015) #define sck_h_3 PORTF|=(1<<PF0) 
(0016) #define sck_l_3 PORTF&=~(1<<PF0) 
(0017) #define cs_h_3 PORTF|=1<<PF2 
(0018) #define cs_l_3 PORTF&=~(1<<PF2) 
(0019) 
(0020) #define sck_h_4 PORTF|=(1<<PF4) 
(0021) #define sck_l_4 PORTF&=~(1<<PF4) 
(0022) #define cs_h_4 PORTF|=1<<PF5 
(0023) #define cs_l_4 PORTF&=~(1<<PF5) 
(0024) /*
(0025) 仿真中没有读出数据，也没有实物
(0026) 
(0027) */
(0028) void readTemp_1(void){
(0029) 	   uint i;
(0030) 	   DDRE&=0xFB;
    0098F B182      IN	R24,0x02
    00990 7F8B      ANDI	R24,0xFB
    00991 B982      OUT	0x02,R24
(0031) 	   sck_l_1;
    00992 981B      CBI	0x03,3
(0032) 	   cs_l_1;
    00993 981C      CBI	0x03,4
(0033) 	   delay_us(1);
    00994 E001      LDI	R16,1
    00995 E010      LDI	R17,0
    00996 940E 00BF CALL	_delay_us
(0034) 	   for(i=0;i<8;i++){
    00998 2744      CLR	R20
    00999 2755      CLR	R21
    0099A C020      RJMP	0x09BB
(0035) 			sck_h_1;
    0099B 9A1B      SBI	0x03,3
(0036) 			delay_us(10);
    0099C E00A      LDI	R16,0xA
    0099D E010      LDI	R17,0
    0099E 940E 00BF CALL	_delay_us
(0037) 	    	temp_h=temp_h|(PINE&0x04);
    009A0 B181      IN	R24,0x01
    009A1 2799      CLR	R25
    009A2 7084      ANDI	R24,4
    009A3 7090      ANDI	R25,0
    009A4 9020 0113 LDS	R2,temp_h
    009A6 9030 0114 LDS	R3,temp_h+1
    009A8 2A28      OR	R2,R24
    009A9 2A39      OR	R3,R25
    009AA 9230 0114 STS	temp_h+1,R3
    009AC 9220 0113 STS	temp_h,R2
(0038) 			temp_h<<=1;
    009AE 0C22      LSL	R2
    009AF 1C33      ROL	R3
    009B0 9230 0114 STS	temp_h+1,R3
    009B2 9220 0113 STS	temp_h,R2
(0039) 			sck_l_1;
    009B4 981B      CBI	0x03,3
(0040) 			delay_us(1);
    009B5 E001      LDI	R16,1
    009B6 E010      LDI	R17,0
    009B7 940E 00BF CALL	_delay_us
    009B9 5F4F      SUBI	R20,0xFF
    009BA 4F5F      SBCI	R21,0xFF
    009BB 3048      CPI	R20,0x8
    009BC E0E0      LDI	R30,0
    009BD 075E      CPC	R21,R30
    009BE F2E0      BCS	0x099B
(0041) 			
(0042) 	   }
(0043) 	   for(i=0;i<8;i++){
    009BF 2744      CLR	R20
    009C0 2755      CLR	R21
    009C1 C022      RJMP	0x09E4
(0044) 			sck_h_1;
    009C2 9A1B      SBI	0x03,3
(0045) 			delay_us(10);
    009C3 E00A      LDI	R16,0xA
    009C4 E010      LDI	R17,0
    009C5 940E 00BF CALL	_delay_us
(0046) 	    	temp_l=temp_l|(PINE&0x04);
    009C7 B181      IN	R24,0x01
    009C8 2799      CLR	R25
    009C9 7084      ANDI	R24,4
    009CA 7090      ANDI	R25,0
    009CB 9020 0115 LDS	R2,temp_l
    009CD 9030 0116 LDS	R3,temp_l+1
    009CF 2A28      OR	R2,R24
    009D0 2A39      OR	R3,R25
    009D1 9230 0116 STS	temp_l+1,R3
    009D3 9220 0115 STS	temp_l,R2
(0047) 			temp_l<<=temp_l;
    009D5 0191      MOVW	R18,R2
    009D6 0181      MOVW	R16,R2
    009D7 940E 1177 CALL	lsl16
    009D9 9310 0116 STS	temp_l+1,R17
    009DB 9300 0115 STS	temp_l,R16
(0048) 			sck_l_1;
    009DD 981B      CBI	0x03,3
(0049) 			delay_us(1);
    009DE E001      LDI	R16,1
    009DF E010      LDI	R17,0
    009E0 940E 00BF CALL	_delay_us
    009E2 5F4F      SUBI	R20,0xFF
    009E3 4F5F      SBCI	R21,0xFF
    009E4 3048      CPI	R20,0x8
    009E5 E0E0      LDI	R30,0
    009E6 075E      CPC	R21,R30
    009E7 F2D0      BCS	0x09C2
(0050) 	   }
(0051) 	   delay_us(1);
    009E8 E001      LDI	R16,1
    009E9 E010      LDI	R17,0
    009EA 940E 00BF CALL	_delay_us
(0052) 	  // temp_l=0x55;
(0053) 	   return ;
    009EC 9159      LD	R21,Y+
    009ED 9149      LD	R20,Y+
    009EE 9508      RET
_readTemp_2:
  i                    --> R20
    009EF 934A      ST	-Y,R20
    009F0 935A      ST	-Y,R21
(0054) }
(0055) void readTemp_2(void){
(0056) 	   uint i;
(0057) 	   DDRE&=0xDF;
    009F1 B182      IN	R24,0x02
    009F2 7D8F      ANDI	R24,0xDF
    009F3 B982      OUT	0x02,R24
(0058) 	   sck_l_2;
    009F4 981E      CBI	0x03,6
(0059) 	   cs_l_2;
    009F5 981F      CBI	0x03,7
(0060) 	   delay_us(1);
    009F6 E001      LDI	R16,1
    009F7 E010      LDI	R17,0
    009F8 940E 00BF CALL	_delay_us
(0061) 	   for(i=0;i<8;i++){
    009FA 2744      CLR	R20
    009FB 2755      CLR	R21
    009FC C020      RJMP	0x0A1D
(0062) 			sck_h_2;
    009FD 9A1E      SBI	0x03,6
(0063) 			delay_us(10);
    009FE E00A      LDI	R16,0xA
    009FF E010      LDI	R17,0
    00A00 940E 00BF CALL	_delay_us
(0064) 	    	temp_h=temp_h|(PINE&0x20);
    00A02 B181      IN	R24,0x01
    00A03 2799      CLR	R25
    00A04 7280      ANDI	R24,0x20
    00A05 7090      ANDI	R25,0
    00A06 9020 0113 LDS	R2,temp_h
    00A08 9030 0114 LDS	R3,temp_h+1
    00A0A 2A28      OR	R2,R24
    00A0B 2A39      OR	R3,R25
    00A0C 9230 0114 STS	temp_h+1,R3
    00A0E 9220 0113 STS	temp_h,R2
(0065) 			temp_h<<=1;
    00A10 0C22      LSL	R2
    00A11 1C33      ROL	R3
    00A12 9230 0114 STS	temp_h+1,R3
    00A14 9220 0113 STS	temp_h,R2
(0066) 			sck_l_2;
    00A16 981E      CBI	0x03,6
(0067) 			delay_us(1);
    00A17 E001      LDI	R16,1
    00A18 E010      LDI	R17,0
    00A19 940E 00BF CALL	_delay_us
    00A1B 5F4F      SUBI	R20,0xFF
    00A1C 4F5F      SBCI	R21,0xFF
    00A1D 3048      CPI	R20,0x8
    00A1E E0E0      LDI	R30,0
    00A1F 075E      CPC	R21,R30
    00A20 F2E0      BCS	0x09FD
(0068) 			
(0069) 	   }
(0070) 	   for(i=0;i<8;i++){
    00A21 2744      CLR	R20
    00A22 2755      CLR	R21
    00A23 C022      RJMP	0x0A46
(0071) 			sck_h_2;
    00A24 9A1E      SBI	0x03,6
(0072) 			delay_us(10);
    00A25 E00A      LDI	R16,0xA
    00A26 E010      LDI	R17,0
    00A27 940E 00BF CALL	_delay_us
(0073) 	    	temp_l=temp_l|(PINE&0x20);
    00A29 B181      IN	R24,0x01
    00A2A 2799      CLR	R25
    00A2B 7280      ANDI	R24,0x20
    00A2C 7090      ANDI	R25,0
    00A2D 9020 0115 LDS	R2,temp_l
    00A2F 9030 0116 LDS	R3,temp_l+1
    00A31 2A28      OR	R2,R24
    00A32 2A39      OR	R3,R25
    00A33 9230 0116 STS	temp_l+1,R3
    00A35 9220 0115 STS	temp_l,R2
(0074) 			temp_l<<=temp_l;
    00A37 0191      MOVW	R18,R2
    00A38 0181      MOVW	R16,R2
    00A39 940E 1177 CALL	lsl16
    00A3B 9310 0116 STS	temp_l+1,R17
    00A3D 9300 0115 STS	temp_l,R16
(0075) 			sck_l_2;
    00A3F 981E      CBI	0x03,6
(0076) 			delay_us(1);
    00A40 E001      LDI	R16,1
    00A41 E010      LDI	R17,0
    00A42 940E 00BF CALL	_delay_us
    00A44 5F4F      SUBI	R20,0xFF
    00A45 4F5F      SBCI	R21,0xFF
    00A46 3048      CPI	R20,0x8
    00A47 E0E0      LDI	R30,0
    00A48 075E      CPC	R21,R30
    00A49 F2D0      BCS	0x0A24
(0077) 	   }
(0078) 	   delay_us(1);
    00A4A E001      LDI	R16,1
    00A4B E010      LDI	R17,0
    00A4C 940E 00BF CALL	_delay_us
(0079) 	  // temp_l=0x55;
(0080) 	   return ;
    00A4E 9159      LD	R21,Y+
    00A4F 9149      LD	R20,Y+
    00A50 9508      RET
_readTemp_3:
  i                    --> R20
    00A51 934A      ST	-Y,R20
    00A52 935A      ST	-Y,R21
(0081) }
(0082) void readTemp_3(void){
(0083) 	   uint i;
(0084) 	   DDRF&=0xFE;
    00A53 9180 0061 LDS	R24,0x61
    00A55 7F8E      ANDI	R24,0xFE
    00A56 9380 0061 STS	0x61,R24
(0085) 	   sck_l_3;
    00A58 9180 0062 LDS	R24,0x62
    00A5A 7F8E      ANDI	R24,0xFE
    00A5B 9380 0062 STS	0x62,R24
(0086) 	   cs_l_3;
    00A5D 9180 0062 LDS	R24,0x62
    00A5F 7F8B      ANDI	R24,0xFB
    00A60 9380 0062 STS	0x62,R24
(0087) 	   delay_us(1);
    00A62 E001      LDI	R16,1
    00A63 E010      LDI	R17,0
    00A64 940E 00BF CALL	_delay_us
(0088) 	   for(i=0;i<8;i++){
    00A66 2744      CLR	R20
    00A67 2755      CLR	R21
    00A68 C028      RJMP	0x0A91
(0089) 			sck_h_3;
    00A69 9180 0062 LDS	R24,0x62
    00A6B 6081      ORI	R24,1
    00A6C 9380 0062 STS	0x62,R24
(0090) 			delay_us(10);
    00A6E E00A      LDI	R16,0xA
    00A6F E010      LDI	R17,0
    00A70 940E 00BF CALL	_delay_us
(0091) 	    	temp_h=temp_h|(PINF&0x01);
    00A72 B180      IN	R24,0x00
    00A73 2799      CLR	R25
    00A74 7081      ANDI	R24,1
    00A75 7090      ANDI	R25,0
    00A76 9020 0113 LDS	R2,temp_h
    00A78 9030 0114 LDS	R3,temp_h+1
    00A7A 2A28      OR	R2,R24
    00A7B 2A39      OR	R3,R25
    00A7C 9230 0114 STS	temp_h+1,R3
    00A7E 9220 0113 STS	temp_h,R2
(0092) 			temp_h<<=1;
    00A80 0C22      LSL	R2
    00A81 1C33      ROL	R3
    00A82 9230 0114 STS	temp_h+1,R3
    00A84 9220 0113 STS	temp_h,R2
(0093) 			sck_l_3;
    00A86 9180 0062 LDS	R24,0x62
    00A88 7F8E      ANDI	R24,0xFE
    00A89 9380 0062 STS	0x62,R24
(0094) 			delay_us(1);
    00A8B E001      LDI	R16,1
    00A8C E010      LDI	R17,0
    00A8D 940E 00BF CALL	_delay_us
    00A8F 5F4F      SUBI	R20,0xFF
    00A90 4F5F      SBCI	R21,0xFF
    00A91 3048      CPI	R20,0x8
    00A92 E0E0      LDI	R30,0
    00A93 075E      CPC	R21,R30
    00A94 F2A0      BCS	0x0A69
(0095) 			
(0096) 	   }
(0097) 	   for(i=0;i<8;i++){
    00A95 2744      CLR	R20
    00A96 2755      CLR	R21
    00A97 C02A      RJMP	0x0AC2
(0098) 			sck_h_3;
    00A98 9180 0062 LDS	R24,0x62
    00A9A 6081      ORI	R24,1
    00A9B 9380 0062 STS	0x62,R24
(0099) 			delay_us(10);
    00A9D E00A      LDI	R16,0xA
    00A9E E010      LDI	R17,0
    00A9F 940E 00BF CALL	_delay_us
(0100) 	    	temp_l=temp_l|(PINF&0x01);
    00AA1 B180      IN	R24,0x00
    00AA2 2799      CLR	R25
    00AA3 7081      ANDI	R24,1
    00AA4 7090      ANDI	R25,0
    00AA5 9020 0115 LDS	R2,temp_l
    00AA7 9030 0116 LDS	R3,temp_l+1
    00AA9 2A28      OR	R2,R24
    00AAA 2A39      OR	R3,R25
    00AAB 9230 0116 STS	temp_l+1,R3
    00AAD 9220 0115 STS	temp_l,R2
(0101) 			temp_l<<=temp_l;
    00AAF 0191      MOVW	R18,R2
    00AB0 0181      MOVW	R16,R2
    00AB1 940E 1177 CALL	lsl16
    00AB3 9310 0116 STS	temp_l+1,R17
    00AB5 9300 0115 STS	temp_l,R16
(0102) 			sck_l_3;
    00AB7 9180 0062 LDS	R24,0x62
    00AB9 7F8E      ANDI	R24,0xFE
    00ABA 9380 0062 STS	0x62,R24
(0103) 			delay_us(1);
    00ABC E001      LDI	R16,1
    00ABD E010      LDI	R17,0
    00ABE 940E 00BF CALL	_delay_us
    00AC0 5F4F      SUBI	R20,0xFF
    00AC1 4F5F      SBCI	R21,0xFF
    00AC2 3048      CPI	R20,0x8
    00AC3 E0E0      LDI	R30,0
    00AC4 075E      CPC	R21,R30
    00AC5 F290      BCS	0x0A98
(0104) 	   }
(0105) 	   delay_us(1);
    00AC6 E001      LDI	R16,1
    00AC7 E010      LDI	R17,0
    00AC8 940E 00BF CALL	_delay_us
(0106) 	  // temp_l=0x55;
(0107) 	   return ;
    00ACA 9159      LD	R21,Y+
    00ACB 9149      LD	R20,Y+
    00ACC 9508      RET
_readTemp_4:
  i                    --> R20
    00ACD 934A      ST	-Y,R20
    00ACE 935A      ST	-Y,R21
(0108) }
(0109) void readTemp_4(void){
(0110) 	   uint i;
(0111) 	   DDRF&=0xF7;
    00ACF 9180 0061 LDS	R24,0x61
    00AD1 7F87      ANDI	R24,0xF7
    00AD2 9380 0061 STS	0x61,R24
(0112) 	   sck_l_4;
    00AD4 9180 0062 LDS	R24,0x62
    00AD6 7E8F      ANDI	R24,0xEF
    00AD7 9380 0062 STS	0x62,R24
(0113) 	   cs_l_4;
    00AD9 9180 0062 LDS	R24,0x62
    00ADB 7D8F      ANDI	R24,0xDF
    00ADC 9380 0062 STS	0x62,R24
(0114) 	   delay_us(1);
    00ADE E001      LDI	R16,1
    00ADF E010      LDI	R17,0
    00AE0 940E 00BF CALL	_delay_us
(0115) 	   for(i=0;i<8;i++){
    00AE2 2744      CLR	R20
    00AE3 2755      CLR	R21
    00AE4 C028      RJMP	0x0B0D
(0116) 			sck_h_4;
    00AE5 9180 0062 LDS	R24,0x62
    00AE7 6180      ORI	R24,0x10
    00AE8 9380 0062 STS	0x62,R24
(0117) 			delay_us(10);
    00AEA E00A      LDI	R16,0xA
    00AEB E010      LDI	R17,0
    00AEC 940E 00BF CALL	_delay_us
(0118) 	    	temp_h=temp_h|(PINF&0x80);
    00AEE B180      IN	R24,0x00
    00AEF 2799      CLR	R25
    00AF0 7880      ANDI	R24,0x80
    00AF1 7090      ANDI	R25,0
    00AF2 9020 0113 LDS	R2,temp_h
    00AF4 9030 0114 LDS	R3,temp_h+1
    00AF6 2A28      OR	R2,R24
    00AF7 2A39      OR	R3,R25
    00AF8 9230 0114 STS	temp_h+1,R3
    00AFA 9220 0113 STS	temp_h,R2
(0119) 			temp_h<<=1;
    00AFC 0C22      LSL	R2
    00AFD 1C33      ROL	R3
    00AFE 9230 0114 STS	temp_h+1,R3
    00B00 9220 0113 STS	temp_h,R2
(0120) 			sck_l_4;
    00B02 9180 0062 LDS	R24,0x62
    00B04 7E8F      ANDI	R24,0xEF
    00B05 9380 0062 STS	0x62,R24
(0121) 			delay_us(1);
    00B07 E001      LDI	R16,1
    00B08 E010      LDI	R17,0
    00B09 940E 00BF CALL	_delay_us
    00B0B 5F4F      SUBI	R20,0xFF
    00B0C 4F5F      SBCI	R21,0xFF
    00B0D 3048      CPI	R20,0x8
    00B0E E0E0      LDI	R30,0
    00B0F 075E      CPC	R21,R30
    00B10 F2A0      BCS	0x0AE5
(0122) 			
(0123) 	   }
(0124) 	   for(i=0;i<8;i++){
    00B11 2744      CLR	R20
    00B12 2755      CLR	R21
    00B13 C02A      RJMP	0x0B3E
(0125) 			sck_h_4;
    00B14 9180 0062 LDS	R24,0x62
    00B16 6180      ORI	R24,0x10
    00B17 9380 0062 STS	0x62,R24
(0126) 			delay_us(10);
    00B19 E00A      LDI	R16,0xA
    00B1A E010      LDI	R17,0
    00B1B 940E 00BF CALL	_delay_us
(0127) 	    	temp_l=temp_l|(PINF&0x80);
    00B1D B180      IN	R24,0x00
    00B1E 2799      CLR	R25
    00B1F 7880      ANDI	R24,0x80
    00B20 7090      ANDI	R25,0
    00B21 9020 0115 LDS	R2,temp_l
    00B23 9030 0116 LDS	R3,temp_l+1
    00B25 2A28      OR	R2,R24
    00B26 2A39      OR	R3,R25
    00B27 9230 0116 STS	temp_l+1,R3
    00B29 9220 0115 STS	temp_l,R2
(0128) 			temp_l<<=temp_l;
    00B2B 0191      MOVW	R18,R2
    00B2C 0181      MOVW	R16,R2
    00B2D 940E 1177 CALL	lsl16
    00B2F 9310 0116 STS	temp_l+1,R17
    00B31 9300 0115 STS	temp_l,R16
(0129) 			sck_l_4;
    00B33 9180 0062 LDS	R24,0x62
    00B35 7E8F      ANDI	R24,0xEF
    00B36 9380 0062 STS	0x62,R24
(0130) 			delay_us(1);
    00B38 E001      LDI	R16,1
    00B39 E010      LDI	R17,0
    00B3A 940E 00BF CALL	_delay_us
    00B3C 5F4F      SUBI	R20,0xFF
    00B3D 4F5F      SBCI	R21,0xFF
    00B3E 3048      CPI	R20,0x8
    00B3F E0E0      LDI	R30,0
    00B40 075E      CPC	R21,R30
    00B41 F290      BCS	0x0B14
(0131) 	   }
(0132) 	   delay_us(1);
    00B42 E001      LDI	R16,1
    00B43 E010      LDI	R17,0
    00B44 940E 00BF CALL	_delay_us
(0133) 	  // temp_l=0x55;
(0134) 	   return ;
    00B46 9159      LD	R21,Y+
    00B47 9149      LD	R20,Y+
    00B48 9508      RET
(0135) }
(0136) uchar readOC(void){
(0137) 	  DDRD&=0x07;
_readOC:
    00B49 B381      IN	R24,0x11
    00B4A 7087      ANDI	R24,7
    00B4B BB81      OUT	0x11,R24
(0138) 	  return PIND&(0xF8);
    00B4C B300      IN	R16,0x10
    00B4D 7F08      ANDI	R16,0xF8
    00B4E 9508      RET
FILE: E:\ICCDemo\Temp_Control\temp_control\out.c
(0001) #include<iom128v.h>
(0002) #include "out.h"
(0003) 
(0004) void out_all(uchar out){
(0005)   DDRC=0xFF;
_out_all:
  out                  --> R16
    00B4F EF8F      LDI	R24,0xFF
    00B50 BB84      OUT	0x14,R24
(0006)   PORTC=out;
    00B51 BB05      OUT	0x15,R16
    00B52 9508      RET
_out_port:
  port                 --> R10
  out                  --> R20
    00B53 940E 1135 CALL	push_xgset300C
    00B55 0159      MOVW	R10,R18
    00B56 01A8      MOVW	R20,R16
(0007) }
(0008) //0、1的传入。port由0~7
(0009) void out_port(uint out,uint port){
(0010)   DDRC=0xFF;
    00B57 EF8F      LDI	R24,0xFF
    00B58 BB84      OUT	0x14,R24
(0011)   if(out==0){
    00B59 3040      CPI	R20,0
    00B5A 0745      CPC	R20,R21
    00B5B F471      BNE	0x0B6A
(0012)    PORTC&=~(1<<port);
    00B5C E001      LDI	R16,1
    00B5D E010      LDI	R17,0
    00B5E 0195      MOVW	R18,R10
    00B5F 940E 1177 CALL	lsl16
    00B61 0118      MOVW	R2,R16
    00B62 9420      COM	R2
    00B63 9430      COM	R3
    00B64 B245      IN	R4,0x15
    00B65 2455      CLR	R5
    00B66 2042      AND	R4,R2
    00B67 2053      AND	R5,R3
    00B68 BA45      OUT	0x15,R4
(0013)   }else if(out==1){
    00B69 C00E      RJMP	0x0B78
    00B6A 3041      CPI	R20,1
    00B6B E0E0      LDI	R30,0
    00B6C 075E      CPC	R21,R30
    00B6D F451      BNE	0x0B78
(0014)    PORTC|=(1<<port);
    00B6E E001      LDI	R16,1
    00B6F E010      LDI	R17,0
    00B70 0195      MOVW	R18,R10
    00B71 940E 1177 CALL	lsl16
    00B73 B225      IN	R2,0x15
    00B74 2433      CLR	R3
    00B75 2A20      OR	R2,R16
    00B76 2A31      OR	R3,R17
    00B77 BA25      OUT	0x15,R2
(0015)   }
    00B78 940C 113A JMP	pop_xgset300C
_read_port:
  port                 --> R10
    00B7A 92AA      ST	-Y,R10
    00B7B 92BA      ST	-Y,R11
    00B7C 0158      MOVW	R10,R16
(0016) }
(0017) uint read_port(uint port){
(0018)   return PINC&(1<<port);
    00B7D E001      LDI	R16,1
    00B7E E010      LDI	R17,0
    00B7F 0195      MOVW	R18,R10
    00B80 940E 1177 CALL	lsl16
    00B82 B223      IN	R2,0x13
    00B83 2433      CLR	R3
    00B84 2220      AND	R2,R16
    00B85 2231      AND	R3,R17
    00B86 0181      MOVW	R16,R2
    00B87 90B9      LD	R11,Y+
    00B88 90A9      LD	R10,Y+
    00B89 9508      RET
FILE: E:\ICCDemo\Temp_Control\temp_control\uart.c
(0001) #include <iom128v.h>
(0002) #include "uart.h"
(0003) 
(0004) //常量定义
(0005) #define BAUDRATE1       115200	//波特率
(0006) //#define BAUDRATE2       9600	//波特率
(0007) #define F_CPU		7372800//晶振频率
(0008) 
(0009) //变量定义
(0010) extern unsigned char send_buf[600];
(0011) extern unsigned char receive_buf[600];
(0012) extern unsigned int send_len;
(0013) extern unsigned int receive_len;
(0014) 
(0015) unsigned char uart_timeout_flag1;
(0016) unsigned char uart_timeout_flag2;
(0017) 
(0018) //串口1对应程序
(0019) ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
(0020) //USART 初始化
(0021) void init_USART1(void)
(0022) {
(0023)     //USART 115200 8, n,1  PC上位机软件(超级终端等)也要设成同样的设置才能通讯
(0024)     UCSR0C = (1<<USBS0)|(3<<UCSZ00);
_init_USART1:
    00B8A E08E      LDI	R24,0xE
    00B8B 9380 0095 STS	0x95,R24
(0025)     
(0026)   //异步，8位数据，无奇偶校验，一个停止位，无倍速   
(0027)     //U2X=0时的公式计算
(0028)     UBRR0L= (F_CPU/BAUDRATE1/16-1)%256;
    00B8D E083      LDI	R24,3
    00B8E B989      OUT	0x09,R24
(0029)     UBRR0H= (F_CPU/BAUDRATE1/16-1)/256;
    00B8F 2422      CLR	R2
    00B90 9220 0090 STS	0x90,R2
(0030) 
(0031)     UCSR0A = 0x00;
    00B92 B82B      OUT	0x0B,R2
(0032) 
(0033)     //使能接收中断，使能接收，使能发送
(0034)     UCSR0B = (1<<RXEN0)|(1<<TXEN0);
    00B93 E188      LDI	R24,0x18
    00B94 B98A      OUT	0x0A,R24
    00B95 9508      RET
(0035)     
(0036) }
(0037) 
(0038) //向串口1写数
(0039) void put_c1(unsigned char c)
(0040) {
(0041) 	while( !(UCSR0A & (1<<UDRE0)) );
_put_c1:
  c                    --> R16
    00B96 9B5D      SBIS	0x0B,5
    00B97 CFFE      RJMP	_put_c1
(0042) 	UDR0=c;	
    00B98 B90C      OUT	0x0C,R16
    00B99 9508      RET
(0043) }
(0044) 
(0045) //从串口1读数
(0046) unsigned char USART_Receive1( void )
(0047) {
(0048)    unsigned int j=0;
_USART_Receive1:
  j                    --> R16
    00B9A 2700      CLR	R16
    00B9B 2711      CLR	R17
(0049)    uart_timeout_flag1=0; 
    00B9C 2422      CLR	R2
    00B9D 9220 0675 STS	uart_timeout_flag1,R2
    00B9F C00B      RJMP	0x0BAB
(0050)   //等待接受标志
(0051)   while ( !(UCSR0A & (1<<RXC0)) ){
(0052)     if(j==32000) //判断超时，并设置标志
    00BA0 3000      CPI	R16,0
    00BA1 E7ED      LDI	R30,0x7D
    00BA2 071E      CPC	R17,R30
    00BA3 F429      BNE	0x0BA9
(0053)     { uart_timeout_flag1=1;   
    00BA4 E081      LDI	R24,1
    00BA5 9380 0675 STS	uart_timeout_flag1,R24
(0054)     return FAILURE;}
    00BA7 E001      LDI	R16,1
    00BA8 C005      RJMP	0x0BAE
(0055) 	else 
(0056) 		j++;
    00BA9 5F0F      SUBI	R16,0xFF
    00BAA 4F1F      SBCI	R17,0xFF
    00BAB 9B5F      SBIS	0x0B,7
    00BAC CFF3      RJMP	0x0BA0
(0057)     ;}
(0058)   //读接收数据  
(0059)   return UDR0;
    00BAD B10C      IN	R16,0x0C
    00BAE 9508      RET
_receiveStrfromCom:
  k                    --> R20
    00BAF 92AA      ST	-Y,R10
    00BB0 934A      ST	-Y,R20
(0060) }
(0061) 
(0062) //从串口接收数据串
(0063) unsigned char receiveStrfromCom(void)
(0064) {
    00BB1 C03E      RJMP	0x0BF0
(0065)   unsigned char k;
(0066) 
(0067)   while(1)
(0068)   {
(0069)     ///以下为从串口接收数据的过程
(0070)     send_buf[0]=USART_Receive1();
    00BB2 DFE7      RCALL	_USART_Receive1
    00BB3 9300 0407 STS	send_buf,R16
(0071)     //若接收的不是命令头则继续等待
(0072)     if(send_buf[0]!=0x02)continue;
    00BB5 3002      CPI	R16,2
    00BB6 F009      BEQ	0x0BB8
    00BB7 C038      RJMP	0x0BF0
(0073)       
(0074)     for(k=1;k<5;k++)
    00BB8 E041      LDI	R20,1
    00BB9 C00F      RJMP	0x0BC9
(0075)     {
(0076)         send_buf[k]=USART_Receive1(); 
    00BBA DFDF      RCALL	_USART_Receive1
    00BBB E087      LDI	R24,7
    00BBC E094      LDI	R25,4
    00BBD 2FE4      MOV	R30,R20
    00BBE 27FF      CLR	R31
    00BBF 0FE8      ADD	R30,R24
    00BC0 1FF9      ADC	R31,R25
    00BC1 8300      ST	Z,R16
(0077)         if(uart_timeout_flag1==1)
    00BC2 9180 0675 LDS	R24,uart_timeout_flag1
    00BC4 3081      CPI	R24,1
    00BC5 F411      BNE	0x0BC8
(0078)         {  
(0079) //          ComSendResponse(send_buf[3],EXE_TIME_OUT,1);
(0080)           return FAILURE;
    00BC6 E001      LDI	R16,1
    00BC7 C029      RJMP	0x0BF1
    00BC8 9543      INC	R20
    00BC9 3045      CPI	R20,5
    00BCA F378      BCS	0x0BBA
(0081)         }  
(0082)     }
(0083)     
(0084)     send_len=send_buf[4];
    00BCB 9020 040B LDS	R2,send_buf+4
    00BCD 2433      CLR	R3
    00BCE 9230 01AE STS	send_len+1,R3
    00BD0 9220 01AD STS	send_len,R2
(0085)     
(0086)     for(k=5;k<send_len+6;k++)
    00BD2 E045      LDI	R20,5
    00BD3 C010      RJMP	0x0BE4
(0087)     {
(0088)         send_buf[k]=USART_Receive1(); 
    00BD4 DFC5      RCALL	_USART_Receive1
    00BD5 2EA0      MOV	R10,R16
    00BD6 E087      LDI	R24,7
    00BD7 E094      LDI	R25,4
    00BD8 2FE4      MOV	R30,R20
    00BD9 27FF      CLR	R31
    00BDA 0FE8      ADD	R30,R24
    00BDB 1FF9      ADC	R31,R25
    00BDC 82A0      ST	Z,R10
(0089)         if(uart_timeout_flag1==1)
    00BDD 9180 0675 LDS	R24,uart_timeout_flag1
    00BDF 3081      CPI	R24,1
    00BE0 F411      BNE	0x0BE3
(0090)         {  
(0091) //           ComSendResponse(send_buf[3],EXE_TIME_OUT,1);
(0092)            return FAILURE; 
    00BE1 E001      LDI	R16,1
    00BE2 C00E      RJMP	0x0BF1
    00BE3 9543      INC	R20
    00BE4 9180 01AD LDS	R24,send_len
    00BE6 9190 01AE LDS	R25,send_len+1
    00BE8 9606      ADIW	R24,6
    00BE9 2E24      MOV	R2,R20
    00BEA 2433      CLR	R3
    00BEB 1628      CP	R2,R24
    00BEC 0639      CPC	R3,R25
    00BED F330      BCS	0x0BD4
(0093)         }  
(0094)     }  
(0095)     return SUCCESS;
    00BEE 2700      CLR	R16
    00BEF C001      RJMP	0x0BF1
    00BF0 CFC1      RJMP	0x0BB2
    00BF1 9149      LD	R20,Y+
    00BF2 90A9      LD	R10,Y+
    00BF3 9508      RET
_outStrtoCom:
  i                    --> R10
  length               --> R12
  pData                --> R14
    00BF4 940E 112E CALL	push_xgset00FC
    00BF6 0169      MOVW	R12,R18
    00BF7 0178      MOVW	R14,R16
(0096) 
(0097)   }  
(0098)   return FAILURE;
(0099) } 
(0100) 
(0101) //向串口输出数据串
(0102) void outStrtoCom(unsigned char *pData,unsigned int length)
(0103) {
(0104) 	unsigned char i;
(0105) 	for(i=0;i<length;i++)
    00BF8 24AA      CLR	R10
    00BF9 C007      RJMP	0x0C01
(0106) 		put_c1(pData[i]);
    00BFA 2DEA      MOV	R30,R10
    00BFB 27FF      CLR	R31
    00BFC 0DEE      ADD	R30,R14
    00BFD 1DFF      ADC	R31,R15
    00BFE 8100      LD	R16,Z
    00BFF DF96      RCALL	_put_c1
    00C00 94A3      INC	R10
    00C01 2C2A      MOV	R2,R10
    00C02 2433      CLR	R3
    00C03 142C      CP	R2,R12
    00C04 043D      CPC	R3,R13
    00C05 F3A0      BCS	0x0BFA
    00C06 940C 110F JMP	pop_xgset00FC
_MAC_CalCrc16:
  i                    --> R10
  j                    --> R22
  value_CRC            --> R20
  ucLen                --> R12
  pCrc16               --> R18
  pInput               --> R16
    00C08 940E 1165 CALL	push_xgsetF03C
    00C0A 84C8      LDD	R12,Y+8
(0107) }
(0108) /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
(0109) 
(0110) /*-----------------------------------------------
(0111) 函数名： 　MAC_CalCrc16
(0112) 功  能：  以字节为单位计算len个数的CRC16校验和，首字节
(0113) 		  为pInput[0].
(0114) 参  数：  pInput			为需要计算CRC的数据的指针
(0115)           pCrc16			为指向存储CRC值的数组
(0116)           ucLen				为需要计算CRC的数据长度
(0117) 返回值：　无　
(0118) 作  者：　lz
(0119) 日  期：  2008-06-18
(0120) ------------------------------------------------*/
(0121) void MAC_CalCrc16(unsigned char  *pInput, unsigned char * pCrc16, unsigned char ucLen)   
(0122) {   
(0123)     unsigned int value_CRC=0xffff;
    00C0B EF4F      LDI	R20,0xFF
    00C0C EF5F      LDI	R21,0xFF
(0124)     unsigned char i;
(0125)     unsigned char j;
(0126) 
(0127) 	for( i=0; i<ucLen; i++ )
    00C0D 24AA      CLR	R10
    00C0E C01B      RJMP	0x0C2A
(0128) 	{	
(0129) 		value_CRC = value_CRC ^((unsigned int)pInput[i]);
    00C0F 2DEA      MOV	R30,R10
    00C10 27FF      CLR	R31
    00C11 0FE0      ADD	R30,R16
    00C12 1FF1      ADC	R31,R17
    00C13 8020      LD	R2,Z
    00C14 2433      CLR	R3
    00C15 2542      EOR	R20,R2
    00C16 2553      EOR	R21,R3
(0130) 		for (j = 0; j < 8; j++)
    00C17 2766      CLR	R22
    00C18 C00E      RJMP	0x0C27
(0131) 		{
(0132) 			if (value_CRC & 0x0001)
    00C19 FF40      SBRS	R20,0
    00C1A C009      RJMP	0x0C24
(0133) 			{
(0134) 				value_CRC = (value_CRC >> 1) ^ 0x8408;
    00C1B E088      LDI	R24,0x8
    00C1C E894      LDI	R25,0x84
    00C1D 011A      MOVW	R2,R20
    00C1E 9436      LSR	R3
    00C1F 9427      ROR	R2
    00C20 2628      EOR	R2,R24
    00C21 2639      EOR	R3,R25
    00C22 01A1      MOVW	R20,R2
(0135) 			}
    00C23 C002      RJMP	0x0C26
(0136) 			else
(0137) 			{
(0138) 				value_CRC = (value_CRC >> 1);
    00C24 9556      LSR	R21
    00C25 9547      ROR	R20
    00C26 9563      INC	R22
    00C27 3068      CPI	R22,0x8
    00C28 F380      BCS	0x0C19
    00C29 94A3      INC	R10
    00C2A 14AC      CP	R10,R12
    00C2B F318      BCS	0x0C0F
(0139) 			}
(0140) 		}
(0141) 	}
(0142) 	
(0143)   	pCrc16[0] = (unsigned char)(value_CRC>>8);
    00C2C 011A      MOVW	R2,R20
    00C2D 2C23      MOV	R2,R3
    00C2E 2433      CLR	R3
    00C2F 01F9      MOVW	R30,R18
    00C30 8220      ST	Z,R2
(0144) 	pCrc16[1] = (unsigned char)(value_CRC);
    00C31 8341      STD	Z+1,R20
(0145) 	
(0146) 	return;
    00C32 940C 116E JMP	pop_xgsetF03C
_MAC_CheckCrc16:
  CrcChk               --> Y,+1
  ucLen                --> R20
  pInput               --> R10
    00C34 940E 1135 CALL	push_xgset300C
    00C36 2F42      MOV	R20,R18
    00C37 0158      MOVW	R10,R16
    00C38 9723      SBIW	R28,3
(0147) }
(0148) 
(0149) 
(0150) /*-----------------------------------------------
(0151) 函数名：	MAC_CheckCrc16
(0152) 功  能：  校验一帧长度为ucLen的数据，pInput[ucLen]
(0153)           pInput[ucLen+1]是这帧数据的校验字节。
(0154) 参  数：  pInput      校验帧的首地址
(0155)           ucLen 　　　需校验的数据帧的长度 
(0156) 返回值：　0表示校验通过，1表示校验失败　
(0157) 作  者：　lz
(0158) 日  期：  2008-06-18
(0159) ------------------------------------------------*/
(0160) unsigned char MAC_CheckCrc16(unsigned char * pInput, unsigned char ucLen)
(0161) {
(0162) 	unsigned char CrcChk[2];
(0163) 
(0164) 	MAC_CalCrc16(pInput,CrcChk,ucLen-2);
    00C39 2F84      MOV	R24,R20
    00C3A 5082      SUBI	R24,2
    00C3B 8388      ST	Y,R24
    00C3C 019E      MOVW	R18,R28
    00C3D 5F2F      SUBI	R18,0xFF
    00C3E 4F3F      SBCI	R19,0xFF
    00C3F 0185      MOVW	R16,R10
    00C40 DFC7      RCALL	_MAC_CalCrc16
(0165) 
(0166) 	if (CrcChk[0]!=pInput[ucLen-2] || CrcChk[1]!=pInput[ucLen-1])
    00C41 2FE4      MOV	R30,R20
    00C42 27FF      CLR	R31
    00C43 9732      SBIW	R30,2
    00C44 0DEA      ADD	R30,R10
    00C45 1DFB      ADC	R31,R11
    00C46 8020      LD	R2,Z
    00C47 8039      LDD	R3,Y+1
    00C48 1432      CP	R3,R2
    00C49 F449      BNE	0x0C53
    00C4A 2FE4      MOV	R30,R20
    00C4B 27FF      CLR	R31
    00C4C 9731      SBIW	R30,1
    00C4D 0DEA      ADD	R30,R10
    00C4E 1DFB      ADC	R31,R11
    00C4F 8020      LD	R2,Z
    00C50 803A      LDD	R3,Y+2
    00C51 1432      CP	R3,R2
    00C52 F011      BEQ	0x0C55
(0167) 	{
(0168) 		return FAILURE; // crc16 fail!
    00C53 E001      LDI	R16,1
    00C54 C001      RJMP	0x0C56
(0169) 	}
(0170) 	
(0171) 	return SUCCESS; // crc16 ok!
    00C55 2700      CLR	R16
    00C56 9623      ADIW	R28,3
    00C57 940C 113A JMP	pop_xgset300C
_ComSendResponse:
  crc_buf              --> Y,+1
  LenData              --> R20
  statusdata           --> R12
  CmdData              --> R10
    00C59 940E 1157 CALL	push_xgset303C
    00C5B 2EC2      MOV	R12,R18
    00C5C 2EA0      MOV	R10,R16
    00C5D 9723      SBIW	R28,3
    00C5E 8549      LDD	R20,Y+9
(0172) }
(0173) /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
(0174) //发送命令响应结果
(0175) void ComSendResponse(unsigned char CmdData,unsigned char statusdata,unsigned char LenData)
(0176) {
(0177)     unsigned char crc_buf[2];
(0178)     
(0179)     receive_buf[5]= statusdata;
    00C5F 92C0 01B4 STS	receive_buf+5,R12
(0180) 
(0181)     receive_buf[4]=LenData;
    00C61 9340 01B3 STS	receive_buf+4,R20
(0182) 
(0183)     receive_buf[3]=CmdData;
    00C63 92A0 01B2 STS	receive_buf+3,R10
(0184)     
(0185)     receive_buf[1]=0x00;receive_buf[2]=0x01;
    00C65 2422      CLR	R2
    00C66 9220 01B0 STS	receive_buf+1,R2
    00C68 E081      LDI	R24,1
    00C69 9380 01B1 STS	receive_buf+2,R24
(0186) 
(0187)     receive_buf[0]=0x02;
    00C6B E082      LDI	R24,2
    00C6C 9380 01AF STS	receive_buf,R24
(0188)     
(0189)     MAC_CalCrc16(receive_buf, crc_buf,LenData+5); 
    00C6E 2F84      MOV	R24,R20
    00C6F 5F8B      SUBI	R24,0xFB
    00C70 8388      ST	Y,R24
    00C71 019E      MOVW	R18,R28
    00C72 5F2F      SUBI	R18,0xFF
    00C73 4F3F      SBCI	R19,0xFF
    00C74 EA0F      LDI	R16,0xAF
    00C75 E011      LDI	R17,1
    00C76 DF91      RCALL	_MAC_CalCrc16
(0190)     
(0191)     receive_buf[LenData+5]=crc_buf[0];
    00C77 EB84      LDI	R24,0xB4
    00C78 E091      LDI	R25,1
    00C79 2FE4      MOV	R30,R20
    00C7A 27FF      CLR	R31
    00C7B 0FE8      ADD	R30,R24
    00C7C 1FF9      ADC	R31,R25
    00C7D 8029      LDD	R2,Y+1
    00C7E 8220      ST	Z,R2
(0192)     
(0193)     receive_buf[LenData+6]=crc_buf[1];//数据包尾 
    00C7F EB85      LDI	R24,0xB5
    00C80 E091      LDI	R25,1
    00C81 2FE4      MOV	R30,R20
    00C82 27FF      CLR	R31
    00C83 0FE8      ADD	R30,R24
    00C84 1FF9      ADC	R31,R25
    00C85 802A      LDD	R2,Y+2
    00C86 8220      ST	Z,R2
(0194)     
(0195)     init_USART1(); 
    00C87 DF02      RCALL	_init_USART1
(0196)     outStrtoCom(receive_buf,LenData+7); 
    00C88 2F24      MOV	R18,R20
    00C89 2733      CLR	R19
    00C8A 5F29      SUBI	R18,0xF9
    00C8B 4F3F      SBCI	R19,0xFF
    00C8C EA0F      LDI	R16,0xAF
    00C8D E011      LDI	R17,1
    00C8E DF65      RCALL	_outStrtoCom
(0197)    
(0198)     return;
    00C8F 9623      ADIW	R28,3
    00C90 940C 115E JMP	pop_xgset303C
_EEPROM_write:
  data                 --> R10
  addr_l               --> R14
  addr_h               --> R12
    00C92 940E 112E CALL	push_xgset00FC
    00C94 0179      MOVW	R14,R18
    00C95 0168      MOVW	R12,R16
    00C96 80AE      LDD	R10,Y+6
    00C97 80BF      LDD	R11,Y+7
FILE: E:\ICCDemo\Temp_Control\temp_control\eeprom.c
(0001) #include<iom128v.h>
(0002) #include "eeprom.h"
(0003) #include "delay.h"
(0004) void EEPROM_write(uint addr_h,uint addr_l,uint data){
(0005)    SREG&=0x7F;//关中断
    00C98 B78F      IN	R24,0x3F
    00C99 778F      ANDI	R24,0x7F
    00C9A BF8F      OUT	0x3F,R24
(0006)     while(EECR & (1<<EEWE)){
    00C9B 99E1      SBIC	0x1C,1
    00C9C CFFE      RJMP	0x0C9B
(0007) 	 			 
(0008) 	 }
(0009) 	 EEARL=addr_l;
    00C9D BAEE      OUT	0x1E,R14
(0010) 	 EEARH=addr_h;
    00C9E BACF      OUT	0x1F,R12
(0011) 	 
(0012) 	 EEDR=data;
    00C9F BAAD      OUT	0x1D,R10
(0013) 	 EECR|=(1<<EEMWE);
    00CA0 9AE2      SBI	0x1C,2
(0014) 	 EECR|=(1<<EEWE);
    00CA1 9AE1      SBI	0x1C,1
(0015) 	  delay_us(1);
    00CA2 E001      LDI	R16,1
    00CA3 E010      LDI	R17,0
    00CA4 940E 00BF CALL	_delay_us
(0016) 	 SREG|=0x80;//开中断
    00CA6 9478      BSET	7
(0017) 	 return;
    00CA7 940C 110F JMP	pop_xgset00FC
_EEPROM_read:
  data                 --> R10
  addr_l               --> R12
  addr_h               --> R10
    00CA9 92AA      ST	-Y,R10
    00CAA 92CA      ST	-Y,R12
    00CAB 0169      MOVW	R12,R18
    00CAC 0158      MOVW	R10,R16
(0018) }
(0019) uchar EEPROM_read(uint addr_h,uint addr_l){
(0020)    uchar data;
(0021)    SREG&=0x7F;//关中断
    00CAD B78F      IN	R24,0x3F
    00CAE 778F      ANDI	R24,0x7F
    00CAF BF8F      OUT	0x3F,R24
(0022)     while(EECR & (1<<EEWE)){ 			 
    00CB0 99E1      SBIC	0x1C,1
    00CB1 CFFE      RJMP	0x0CB0
(0023) 	 }
(0024) 	 EEARL=addr_l;
    00CB2 BACE      OUT	0x1E,R12
(0025) 	 EEARH=addr_h;
    00CB3 BAAF      OUT	0x1F,R10
(0026) 	 
(0027) 	 EECR|=(1<<EERE);
    00CB4 9AE0      SBI	0x1C,0
(0028) 	 delay_us(1);
    00CB5 E001      LDI	R16,1
    00CB6 E010      LDI	R17,0
    00CB7 940E 00BF CALL	_delay_us
(0029) 	 data=EEDR;
    00CB9 B2AD      IN	R10,0x1D
(0030) 	 SREG|=0x80;//开中断
    00CBA 9478      BSET	7
(0031) 	 return data;
    00CBB 2D0A      MOV	R16,R10
    00CBC 90C9      LD	R12,Y+
    00CBD 90A9      LD	R10,Y+
    00CBE 9508      RET
_pageUtil:
    00CBF 9722      SBIW	R28,2
FILE: E:\ICCDemo\Temp_Control\temp_control\pages.c
(0001) #include<iom128v.h>
(0002) #include "main.h"
(0003) #include "lcd.h"
(0004) #include "time.h"
(0005) #include "timertask.h"
(0006) #include "key.h"
(0007) //************************
(0008) // 所有界面信息在这里,用到全局变量， 
(0009) // unsigned int pageNum;//当前页面，如需跳转改变这个值就行
(0010) // unsigned int pageParam[5];//传递参数。界面间参数暂存
(0011) // unsigned int prePageNum;
(0012) //************************
(0013) 
(0014) //用于显第一行日期信息，其中Page1、Page3 、Page8使用，
(0015) //由定时器触发该函数，进入这三个界面是启动定时器，退出时关闭
(0016) void pageUtil(void){
(0017)                 //关定时器
(0018)    lcd_write_str(0,0,"时间:");
    00CC0 EA85      LDI	R24,0xA5
    00CC1 E091      LDI	R25,1
    00CC2 8399      STD	Y+1,R25
    00CC3 8388      ST	Y,R24
    00CC4 2722      CLR	R18
    00CC5 2700      CLR	R16
    00CC6 940E 04C2 CALL	_lcd_write_str
(0019)    showTime_page();
    00CC8 940E 01E3 CALL	_showTime_page
    00CCA 9622      ADIW	R28,2
    00CCB 9508      RET
_page1:
  cur                  --> R20
  keyV                 --> R10
  y                    --> R22
  i                    --> R10
    00CCC 940E 1165 CALL	push_xgsetF03C
    00CCE 9722      SBIW	R28,2
(0020)                  //开定时器 
(0021) }
(0022) //page1,首页的界面
(0023) void page1(void){
(0024)    uint cur=0;
(0025)    uchar keyV;
(0026)    uint i;//用于循环
(0027)    uint y;//确定是那个半屏幕
(0028)    //初始化起始选择
(0029) 	 
(0030)    
(0031)    
(0032)    lcd_write_str(1,1," T1:100");
    00CCF E98D      LDI	R24,0x9D
    00CD0 E091      LDI	R25,1
    00CD1 8399      STD	Y+1,R25
    00CD2 8388      ST	Y,R24
    00CD3 E021      LDI	R18,1
    00CD4 E001      LDI	R16,1
    00CD5 940E 04C2 CALL	_lcd_write_str
(0033)    lcd_write_char(5,1,0xA1);
    00CD7 EA81      LDI	R24,0xA1
    00CD8 8388      ST	Y,R24
    00CD9 E021      LDI	R18,1
    00CDA E005      LDI	R16,5
    00CDB 940E 049C CALL	_lcd_write_char
(0034)    lcd_write_char_con(1,0xE6);
    00CDD EE26      LDI	R18,0xE6
    00CDE E001      LDI	R16,1
    00CDF 940E 046A CALL	_lcd_write_char_con
(0035) 	
(0036)    
(0037)     lcd_write_str(6,1," T2:800");
    00CE1 E985      LDI	R24,0x95
    00CE2 E091      LDI	R25,1
    00CE3 8399      STD	Y+1,R25
    00CE4 8388      ST	Y,R24
    00CE5 E021      LDI	R18,1
    00CE6 E006      LDI	R16,6
    00CE7 940E 04C2 CALL	_lcd_write_str
(0038) 	lcd_write_char(10,1,0xA1);
    00CE9 EA81      LDI	R24,0xA1
    00CEA 8388      ST	Y,R24
    00CEB E021      LDI	R18,1
    00CEC E00A      LDI	R16,0xA
    00CED 940E 049C CALL	_lcd_write_char
(0039) 	lcd_write_char_con(1,0xE6);
    00CEF EE26      LDI	R18,0xE6
    00CF0 E001      LDI	R16,1
    00CF1 940E 046A CALL	_lcd_write_char_con
(0040) 	
(0041)     lcd_write_str(1,2," T3:停止");
    00CF3 E88C      LDI	R24,0x8C
    00CF4 E091      LDI	R25,1
    00CF5 8399      STD	Y+1,R25
    00CF6 8388      ST	Y,R24
    00CF7 E022      LDI	R18,2
    00CF8 E001      LDI	R16,1
    00CF9 940E 04C2 CALL	_lcd_write_str
(0042) 
(0043)     lcd_write_str(6,2," T4:故障");
    00CFB E883      LDI	R24,0x83
    00CFC E091      LDI	R25,1
    00CFD 8399      STD	Y+1,R25
    00CFE 8388      ST	Y,R24
    00CFF E022      LDI	R18,2
    00D00 E006      LDI	R16,6
    00D01 940E 04C2 CALL	_lcd_write_str
(0044) 
(0045) 	
(0046) 	lcd_write_str(1,3,"开始    ");
    00D03 E78A      LDI	R24,0x7A
    00D04 E091      LDI	R25,1
    00D05 8399      STD	Y+1,R25
    00D06 8388      ST	Y,R24
    00D07 E023      LDI	R18,3
    00D08 E001      LDI	R16,1
    00D09 940E 04C2 CALL	_lcd_write_str
(0047)     lcd_write_str_con(3,"停止    ");
    00D0B E721      LDI	R18,0x71
    00D0C E031      LDI	R19,1
    00D0D E003      LDI	R16,3
    00D0E 940E 050C CALL	_lcd_write_str_con
(0048) 	lcd_write_str_con(3,"设置");
    00D10 E62C      LDI	R18,0x6C
    00D11 E031      LDI	R19,1
    00D12 E003      LDI	R16,3
    00D13 940E 050C CALL	_lcd_write_str_con
(0049) 	
(0050) 	
(0051) 	
(0052) 	 
(0053) 	cur=0;
    00D15 2744      CLR	R20
    00D16 2755      CLR	R21
(0054) 	Set_White(2,1,3);
    00D17 E083      LDI	R24,3
    00D18 8388      ST	Y,R24
    00D19 E021      LDI	R18,1
    00D1A E002      LDI	R16,2
    00D1B 940E 0727 CALL	_Set_White
    00D1D C2BA      RJMP	0x0FD8
(0055) 	while(1){
(0056) 	for(i=0;i<4;i++){
    00D1E 24AA      CLR	R10
    00D1F 24BB      CLR	R11
    00D20 C081      RJMP	0x0DA2
(0057) 	  if(i==0){
    00D21 20AA      TST	R10
    00D22 F449      BNE	0x0D2C
    00D23 20BB      TST	R11
    00D24 F439      BNE	0x0D2C
(0058) 	    y=1;
    00D25 E061      LDI	R22,1
    00D26 E070      LDI	R23,0
(0059) 	    lcd_write_pos(3,1);
    00D27 E021      LDI	R18,1
    00D28 E003      LDI	R16,3
    00D29 940E 047E CALL	_lcd_write_pos
(0060) 	  }else if(i==1){
    00D2B C023      RJMP	0x0D4F
    00D2C 01C5      MOVW	R24,R10
    00D2D 3081      CPI	R24,1
    00D2E E0E0      LDI	R30,0
    00D2F 079E      CPC	R25,R30
    00D30 F439      BNE	0x0D38
(0061) 	    y=1;
    00D31 E061      LDI	R22,1
    00D32 E070      LDI	R23,0
(0062) 	    lcd_write_pos(8,1);
    00D33 E021      LDI	R18,1
    00D34 E008      LDI	R16,0x8
    00D35 940E 047E CALL	_lcd_write_pos
(0063) 	  }else if(i==2){
    00D37 C017      RJMP	0x0D4F
    00D38 01C5      MOVW	R24,R10
    00D39 3082      CPI	R24,2
    00D3A E0E0      LDI	R30,0
    00D3B 079E      CPC	R25,R30
    00D3C F439      BNE	0x0D44
(0064) 	    y=2;
    00D3D E062      LDI	R22,2
    00D3E E070      LDI	R23,0
(0065) 	    lcd_write_pos(3,2);
    00D3F E022      LDI	R18,2
    00D40 E003      LDI	R16,3
    00D41 940E 047E CALL	_lcd_write_pos
(0066) 	  }else if(i==3){
    00D43 C00B      RJMP	0x0D4F
    00D44 01C5      MOVW	R24,R10
    00D45 3083      CPI	R24,3
    00D46 E0E0      LDI	R30,0
    00D47 079E      CPC	R25,R30
    00D48 F431      BNE	0x0D4F
(0067) 	    y=2;
    00D49 E062      LDI	R22,2
    00D4A E070      LDI	R23,0
(0068) 	    lcd_write_pos(8,2);
    00D4B E022      LDI	R18,2
    00D4C E008      LDI	R16,0x8
    00D4D 940E 047E CALL	_lcd_write_pos
(0069) 	  }
(0070) 	   switch(temps[i].flag){
    00D4F E187      LDI	R24,0x17
    00D50 E091      LDI	R25,1
    00D51 01F5      MOVW	R30,R10
    00D52 0FEE      LSL	R30
    00D53 1FFF      ROL	R31
    00D54 0FE8      ADD	R30,R24
    00D55 1FF9      ADC	R31,R25
    00D56 80C0      LD	R12,Z
    00D57 80D1      LDD	R13,Z+1
    00D58 20CC      TST	R12
    00D59 F411      BNE	0x0D5C
    00D5A 20DD      TST	R13
    00D5B F0D1      BEQ	0x0D76
    00D5C 01C6      MOVW	R24,R12
    00D5D 3081      CPI	R24,1
    00D5E E0E0      LDI	R30,0
    00D5F 079E      CPC	R25,R30
    00D60 F0D9      BEQ	0x0D7C
    00D61 3082      CPI	R24,2
    00D62 E0E0      LDI	R30,0
    00D63 079E      CPC	R25,R30
    00D64 F0E9      BEQ	0x0D82
    00D65 3083      CPI	R24,3
    00D66 E0E0      LDI	R30,0
    00D67 079E      CPC	R25,R30
    00D68 F0F9      BEQ	0x0D88
    00D69 3084      CPI	R24,4
    00D6A E0E0      LDI	R30,0
    00D6B 079E      CPC	R25,R30
    00D6C F109      BEQ	0x0D8E
    00D6D 3085      CPI	R24,5
    00D6E E0E0      LDI	R30,0
    00D6F 079E      CPC	R25,R30
    00D70 F119      BEQ	0x0D94
    00D71 3086      CPI	R24,6
    00D72 E0E0      LDI	R30,0
    00D73 079E      CPC	R25,R30
    00D74 F129      BEQ	0x0D9A
    00D75 C029      RJMP	0x0D9F
(0071) 	     case 0:
(0072) 		   lcd_write_str_con(y,"停止");
    00D76 E627      LDI	R18,0x67
    00D77 E031      LDI	R19,1
    00D78 2F06      MOV	R16,R22
    00D79 940E 050C CALL	_lcd_write_str_con
(0073) 		   break;
    00D7B C023      RJMP	0x0D9F
(0074) 		 case 1:
(0075) 		   lcd_write_str_con(y,"150");
    00D7C E623      LDI	R18,0x63
    00D7D E031      LDI	R19,1
    00D7E 2F06      MOV	R16,R22
    00D7F 940E 050C CALL	_lcd_write_str_con
(0076) 		   break;
    00D81 C01D      RJMP	0x0D9F
(0077) 		 case 2:
(0078) 		   lcd_write_str_con(y,"故障");
    00D82 E52E      LDI	R18,0x5E
    00D83 E031      LDI	R19,1
    00D84 2F06      MOV	R16,R22
    00D85 940E 050C CALL	_lcd_write_str_con
(0079) 		   break;
    00D87 C017      RJMP	0x0D9F
(0080) 		 case 3:
(0081) 		   lcd_write_str_con(y,"暂停");
    00D88 E529      LDI	R18,0x59
    00D89 E031      LDI	R19,1
    00D8A 2F06      MOV	R16,R22
    00D8B 940E 050C CALL	_lcd_write_str_con
(0082) 		   break;
    00D8D C011      RJMP	0x0D9F
(0083) 		 case 4:
(0084) 		   lcd_write_str_con(y,"结束");
    00D8E E524      LDI	R18,0x54
    00D8F E031      LDI	R19,1
    00D90 2F06      MOV	R16,R22
    00D91 940E 050C CALL	_lcd_write_str_con
(0085) 		   break;
    00D93 C00B      RJMP	0x0D9F
(0086) 		 case 5:
(0087) 		   lcd_write_str_con(y,"等待");
    00D94 E42F      LDI	R18,0x4F
    00D95 E031      LDI	R19,1
    00D96 2F06      MOV	R16,R22
    00D97 940E 050C CALL	_lcd_write_str_con
(0088) 		   break;
    00D99 C005      RJMP	0x0D9F
(0089) 		 case 6:
(0090) 		   lcd_write_str_con(y,"加载");
    00D9A E42A      LDI	R18,0x4A
    00D9B E031      LDI	R19,1
    00D9C 2F06      MOV	R16,R22
    00D9D 940E 050C CALL	_lcd_write_str_con
    00D9F 01C5      MOVW	R24,R10
    00DA0 9601      ADIW	R24,1
    00DA1 015C      MOVW	R10,R24
    00DA2 01C5      MOVW	R24,R10
    00DA3 3084      CPI	R24,4
    00DA4 E0E0      LDI	R30,0
    00DA5 079E      CPC	R25,R30
    00DA6 F408      BCC	0x0DA8
    00DA7 CF79      RJMP	0x0D21
(0091) 		   break;
(0092) 		   break;
(0093) 		 default:
(0094) 		   break;
(0095) 	   }
(0096) 	}
(0097) 	 pageUtil();
    00DA8 DF16      RCALL	_pageUtil
(0098) 	 keyV=KeyScan_once();
    00DA9 940E 0343 CALL	_KeyScan_once
    00DAB 2EA0      MOV	R10,R16
(0099) 	 if(keyV=='a'){
    00DAC 3601      CPI	R16,0x61
    00DAD F409      BNE	0x0DAF
(0100) 	      //pageNum=8;//跳转到设置时间的界面
(0101) 	}else if(keyV=='d'){
    00DAE C229      RJMP	0x0FD8
    00DAF 2D8A      MOV	R24,R10
    00DB0 3684      CPI	R24,0x64
    00DB1 F009      BEQ	0x0DB3
    00DB2 C04C      RJMP	0x0DFF
(0102) 	     switch(cur){
    00DB3 3040      CPI	R20,0
    00DB4 0745      CPC	R20,R21
    00DB5 F069      BEQ	0x0DC3
    00DB6 3041      CPI	R20,1
    00DB7 E0E0      LDI	R30,0
    00DB8 075E      CPC	R21,R30
    00DB9 F0C1      BEQ	0x0DD2
    00DBA 3042      CPI	R20,2
    00DBB E0E0      LDI	R30,0
    00DBC 075E      CPC	R21,R30
    00DBD F119      BEQ	0x0DE1
    00DBE 3043      CPI	R20,3
    00DBF E0E0      LDI	R30,0
    00DC0 075E      CPC	R21,R30
    00DC1 F171      BEQ	0x0DF0
    00DC2 C215      RJMP	0x0FD8
(0103) 		  case 0:
(0104) 		   Set_White_off(2,1,3);
    00DC3 E083      LDI	R24,3
    00DC4 8388      ST	Y,R24
    00DC5 E021      LDI	R18,1
    00DC6 E002      LDI	R16,2
    00DC7 940E 06AB CALL	_Set_White_off
(0105) 		   Set_White(2,2,3);
    00DC9 E083      LDI	R24,3
    00DCA 8388      ST	Y,R24
    00DCB E022      LDI	R18,2
    00DCC E002      LDI	R16,2
    00DCD 940E 0727 CALL	_Set_White
(0106) 		   cur=2;
    00DCF E042      LDI	R20,2
    00DD0 E050      LDI	R21,0
(0107) 		   break;
    00DD1 C206      RJMP	0x0FD8
(0108) 		  case 1:
(0109) 		   Set_White_off(7,1,8);
    00DD2 E088      LDI	R24,0x8
    00DD3 8388      ST	Y,R24
    00DD4 E021      LDI	R18,1
    00DD5 E007      LDI	R16,7
    00DD6 940E 06AB CALL	_Set_White_off
(0110) 		   Set_White(7,2,8);
    00DD8 E088      LDI	R24,0x8
    00DD9 8388      ST	Y,R24
    00DDA E022      LDI	R18,2
    00DDB E007      LDI	R16,7
    00DDC 940E 0727 CALL	_Set_White
(0111) 		   cur=3;
    00DDE E043      LDI	R20,3
    00DDF E050      LDI	R21,0
(0112) 		   break;
    00DE0 C1F7      RJMP	0x0FD8
(0113) 		  case 2:
(0114) 		   Set_White_off(2,2,3);
    00DE1 E083      LDI	R24,3
    00DE2 8388      ST	Y,R24
    00DE3 E022      LDI	R18,2
    00DE4 E002      LDI	R16,2
    00DE5 940E 06AB CALL	_Set_White_off
(0115) 		   Set_White(2,3,3);
    00DE7 E083      LDI	R24,3
    00DE8 8388      ST	Y,R24
    00DE9 E023      LDI	R18,3
    00DEA E002      LDI	R16,2
    00DEB 940E 0727 CALL	_Set_White
(0116) 		   cur=4;
    00DED E044      LDI	R20,4
    00DEE E050      LDI	R21,0
(0117) 		   break;
    00DEF C1E8      RJMP	0x0FD8
(0118) 		  case 3:
(0119) 		   Set_White_off(7,2,8);
    00DF0 E088      LDI	R24,0x8
    00DF1 8388      ST	Y,R24
    00DF2 E022      LDI	R18,2
    00DF3 E007      LDI	R16,7
    00DF4 940E 06AB CALL	_Set_White_off
(0120) 		   Set_White(6,3,7);
    00DF6 E087      LDI	R24,7
    00DF7 8388      ST	Y,R24
    00DF8 E023      LDI	R18,3
    00DF9 E006      LDI	R16,6
    00DFA 940E 0727 CALL	_Set_White
(0121) 		   cur=5;
    00DFC E045      LDI	R20,5
    00DFD E050      LDI	R21,0
(0122) 		   break;
(0123) 		  default:
(0124) 		   break;
(0125) 		 }
(0126) 	}else if(keyV=='u'){switch(cur){
    00DFE C1D9      RJMP	0x0FD8
    00DFF 2D8A      MOV	R24,R10
    00E00 3785      CPI	R24,0x75
    00E01 F009      BEQ	0x0E03
    00E02 C061      RJMP	0x0E64
    00E03 3042      CPI	R20,2
    00E04 E0E0      LDI	R30,0
    00E05 075E      CPC	R21,R30
    00E06 F091      BEQ	0x0E19
    00E07 3043      CPI	R20,3
    00E08 E0E0      LDI	R30,0
    00E09 075E      CPC	R21,R30
    00E0A F0E9      BEQ	0x0E28
    00E0B 3044      CPI	R20,4
    00E0C E0E0      LDI	R30,0
    00E0D 075E      CPC	R21,R30
    00E0E F141      BEQ	0x0E37
    00E0F 3045      CPI	R20,5
    00E10 E0E0      LDI	R30,0
    00E11 075E      CPC	R21,R30
    00E12 F199      BEQ	0x0E46
    00E13 3046      CPI	R20,6
    00E14 E0E0      LDI	R30,0
    00E15 075E      CPC	R21,R30
    00E16 F409      BNE	0x0E18
    00E17 C03D      RJMP	0x0E55
    00E18 C1BF      RJMP	0x0FD8
(0127) 		  case 2:
(0128) 		   Set_White_off(2,2,3);
    00E19 E083      LDI	R24,3
    00E1A 8388      ST	Y,R24
    00E1B E022      LDI	R18,2
    00E1C E002      LDI	R16,2
    00E1D 940E 06AB CALL	_Set_White_off
(0129) 		   Set_White(2,1,3);
    00E1F E083      LDI	R24,3
    00E20 8388      ST	Y,R24
    00E21 E021      LDI	R18,1
    00E22 E002      LDI	R16,2
    00E23 940E 0727 CALL	_Set_White
(0130) 		   cur=0;
    00E25 2744      CLR	R20
    00E26 2755      CLR	R21
(0131) 		   break;
    00E27 C1B0      RJMP	0x0FD8
(0132) 		  case 3:
(0133) 		   Set_White_off(7,2,8);
    00E28 E088      LDI	R24,0x8
    00E29 8388      ST	Y,R24
    00E2A E022      LDI	R18,2
    00E2B E007      LDI	R16,7
    00E2C 940E 06AB CALL	_Set_White_off
(0134) 		   Set_White(7,1,8);
    00E2E E088      LDI	R24,0x8
    00E2F 8388      ST	Y,R24
    00E30 E021      LDI	R18,1
    00E31 E007      LDI	R16,7
    00E32 940E 0727 CALL	_Set_White
(0135) 		   cur=1;
    00E34 E041      LDI	R20,1
    00E35 E050      LDI	R21,0
(0136) 		   break;
    00E36 C1A1      RJMP	0x0FD8
(0137) 		  case 4:
(0138) 		   Set_White_off(2,3,5);
    00E37 E085      LDI	R24,5
    00E38 8388      ST	Y,R24
    00E39 E023      LDI	R18,3
    00E3A E002      LDI	R16,2
    00E3B 940E 06AB CALL	_Set_White_off
(0139) 		   Set_White(2,2,3);
    00E3D E083      LDI	R24,3
    00E3E 8388      ST	Y,R24
    00E3F E022      LDI	R18,2
    00E40 E002      LDI	R16,2
    00E41 940E 0727 CALL	_Set_White
(0140) 		   cur=2;
    00E43 E042      LDI	R20,2
    00E44 E050      LDI	R21,0
(0141) 		   break;
    00E45 C192      RJMP	0x0FD8
(0142) 		  case 5:
(0143) 		   Set_White_off(6,3,7);
    00E46 E087      LDI	R24,7
    00E47 8388      ST	Y,R24
    00E48 E023      LDI	R18,3
    00E49 E006      LDI	R16,6
    00E4A 940E 06AB CALL	_Set_White_off
(0144) 		   Set_White(7,2,8);
    00E4C E088      LDI	R24,0x8
    00E4D 8388      ST	Y,R24
    00E4E E022      LDI	R18,2
    00E4F E007      LDI	R16,7
    00E50 940E 0727 CALL	_Set_White
(0145) 		   cur=3;
    00E52 E043      LDI	R20,3
    00E53 E050      LDI	R21,0
(0146) 		   break;
    00E54 C183      RJMP	0x0FD8
(0147) 		  case 6:
(0148) 		   Set_White_off(10,3,11);
    00E55 E08B      LDI	R24,0xB
    00E56 8388      ST	Y,R24
    00E57 E023      LDI	R18,3
    00E58 E00A      LDI	R16,0xA
    00E59 940E 06AB CALL	_Set_White_off
(0149) 		   Set_White(7,2,8);
    00E5B E088      LDI	R24,0x8
    00E5C 8388      ST	Y,R24
    00E5D E022      LDI	R18,2
    00E5E E007      LDI	R16,7
    00E5F 940E 0727 CALL	_Set_White
(0150) 		   cur=3;
    00E61 E043      LDI	R20,3
    00E62 E050      LDI	R21,0
(0151) 		   break;
(0152) 		  default:
(0153) 		   break;
(0154) 		 }
(0155) 	}else if(keyV=='l'){switch(cur){
    00E63 C174      RJMP	0x0FD8
    00E64 2D8A      MOV	R24,R10
    00E65 368C      CPI	R24,0x6C
    00E66 F009      BEQ	0x0E68
    00E67 C04D      RJMP	0x0EB5
    00E68 3041      CPI	R20,1
    00E69 E0E0      LDI	R30,0
    00E6A 075E      CPC	R21,R30
    00E6B F069      BEQ	0x0E79
    00E6C 3043      CPI	R20,3
    00E6D E0E0      LDI	R30,0
    00E6E 075E      CPC	R21,R30
    00E6F F0C1      BEQ	0x0E88
    00E70 3045      CPI	R20,5
    00E71 E0E0      LDI	R30,0
    00E72 075E      CPC	R21,R30
    00E73 F119      BEQ	0x0E97
    00E74 3046      CPI	R20,6
    00E75 E0E0      LDI	R30,0
    00E76 075E      CPC	R21,R30
    00E77 F171      BEQ	0x0EA6
    00E78 C15F      RJMP	0x0FD8
(0156) 		  case 1:
(0157) 		   Set_White_off(7,1,8);
    00E79 E088      LDI	R24,0x8
    00E7A 8388      ST	Y,R24
    00E7B E021      LDI	R18,1
    00E7C E007      LDI	R16,7
    00E7D 940E 06AB CALL	_Set_White_off
(0158) 		   Set_White(2,1,3);
    00E7F E083      LDI	R24,3
    00E80 8388      ST	Y,R24
    00E81 E021      LDI	R18,1
    00E82 E002      LDI	R16,2
    00E83 940E 0727 CALL	_Set_White
(0159) 		   cur=0;
    00E85 2744      CLR	R20
    00E86 2755      CLR	R21
(0160) 		   break;
    00E87 C150      RJMP	0x0FD8
(0161) 		  case 3:
(0162) 		   Set_White_off(7,2,8);
    00E88 E088      LDI	R24,0x8
    00E89 8388      ST	Y,R24
    00E8A E022      LDI	R18,2
    00E8B E007      LDI	R16,7
    00E8C 940E 06AB CALL	_Set_White_off
(0163) 		   Set_White(2,2,3);
    00E8E E083      LDI	R24,3
    00E8F 8388      ST	Y,R24
    00E90 E022      LDI	R18,2
    00E91 E002      LDI	R16,2
    00E92 940E 0727 CALL	_Set_White
(0164) 		   cur=2;
    00E94 E042      LDI	R20,2
    00E95 E050      LDI	R21,0
(0165) 		   break;
    00E96 C141      RJMP	0x0FD8
(0166) 		  case 5:
(0167) 		   Set_White_off(6,3,7);
    00E97 E087      LDI	R24,7
    00E98 8388      ST	Y,R24
    00E99 E023      LDI	R18,3
    00E9A E006      LDI	R16,6
    00E9B 940E 06AB CALL	_Set_White_off
(0168) 		   Set_White(2,3,3);
    00E9D E083      LDI	R24,3
    00E9E 8388      ST	Y,R24
    00E9F E023      LDI	R18,3
    00EA0 E002      LDI	R16,2
    00EA1 940E 0727 CALL	_Set_White
(0169) 		   cur=4;
    00EA3 E044      LDI	R20,4
    00EA4 E050      LDI	R21,0
(0170) 		   break;
    00EA5 C132      RJMP	0x0FD8
(0171) 		  case 6:
(0172) 		   Set_White_off(10,3,11);
    00EA6 E08B      LDI	R24,0xB
    00EA7 8388      ST	Y,R24
    00EA8 E023      LDI	R18,3
    00EA9 E00A      LDI	R16,0xA
    00EAA 940E 06AB CALL	_Set_White_off
(0173) 		   Set_White(6,3,7);
    00EAC E087      LDI	R24,7
    00EAD 8388      ST	Y,R24
    00EAE E023      LDI	R18,3
    00EAF E006      LDI	R16,6
    00EB0 940E 0727 CALL	_Set_White
(0174) 		   cur=5;
    00EB2 E045      LDI	R20,5
    00EB3 E050      LDI	R21,0
(0175) 		   break;
(0176) 		  default:
(0177) 		   break;
(0178) 		 }
(0179) 	}else if(keyV=='r'){
    00EB4 C123      RJMP	0x0FD8
    00EB5 2D8A      MOV	R24,R10
    00EB6 3782      CPI	R24,0x72
    00EB7 F009      BEQ	0x0EB9
    00EB8 C04C      RJMP	0x0F05
(0180) 	switch(cur){
    00EB9 3040      CPI	R20,0
    00EBA 0745      CPC	R20,R21
    00EBB F069      BEQ	0x0EC9
    00EBC 3042      CPI	R20,2
    00EBD E0E0      LDI	R30,0
    00EBE 075E      CPC	R21,R30
    00EBF F0C1      BEQ	0x0ED8
    00EC0 3044      CPI	R20,4
    00EC1 E0E0      LDI	R30,0
    00EC2 075E      CPC	R21,R30
    00EC3 F119      BEQ	0x0EE7
    00EC4 3045      CPI	R20,5
    00EC5 E0E0      LDI	R30,0
    00EC6 075E      CPC	R21,R30
    00EC7 F171      BEQ	0x0EF6
    00EC8 C10F      RJMP	0x0FD8
(0181) 		  case 0:
(0182) 		   Set_White_off(2,1,3);
    00EC9 E083      LDI	R24,3
    00ECA 8388      ST	Y,R24
    00ECB E021      LDI	R18,1
    00ECC E002      LDI	R16,2
    00ECD 940E 06AB CALL	_Set_White_off
(0183) 		   Set_White(7,1,8);
    00ECF E088      LDI	R24,0x8
    00ED0 8388      ST	Y,R24
    00ED1 E021      LDI	R18,1
    00ED2 E007      LDI	R16,7
    00ED3 940E 0727 CALL	_Set_White
(0184) 		   cur=1;
    00ED5 E041      LDI	R20,1
    00ED6 E050      LDI	R21,0
(0185) 		   break;
    00ED7 C100      RJMP	0x0FD8
(0186) 		  case 2:
(0187) 		   Set_White_off(2,2,3);
    00ED8 E083      LDI	R24,3
    00ED9 8388      ST	Y,R24
    00EDA E022      LDI	R18,2
    00EDB E002      LDI	R16,2
    00EDC 940E 06AB CALL	_Set_White_off
(0188) 		   Set_White(7,2,8);
    00EDE E088      LDI	R24,0x8
    00EDF 8388      ST	Y,R24
    00EE0 E022      LDI	R18,2
    00EE1 E007      LDI	R16,7
    00EE2 940E 0727 CALL	_Set_White
(0189) 		   cur=3;
    00EE4 E043      LDI	R20,3
    00EE5 E050      LDI	R21,0
(0190) 		   break;
    00EE6 C0F1      RJMP	0x0FD8
(0191) 		  case 4:
(0192) 		   Set_White_off(2,3,3);
    00EE7 E083      LDI	R24,3
    00EE8 8388      ST	Y,R24
    00EE9 E023      LDI	R18,3
    00EEA E002      LDI	R16,2
    00EEB 940E 06AB CALL	_Set_White_off
(0193) 		   Set_White(6,3,7);
    00EED E087      LDI	R24,7
    00EEE 8388      ST	Y,R24
    00EEF E023      LDI	R18,3
    00EF0 E006      LDI	R16,6
    00EF1 940E 0727 CALL	_Set_White
(0194) 		   cur=5;
    00EF3 E045      LDI	R20,5
    00EF4 E050      LDI	R21,0
(0195) 		   break;
    00EF5 C0E2      RJMP	0x0FD8
(0196) 		  case 5:
(0197) 		   Set_White_off(6,3,7);
    00EF6 E087      LDI	R24,7
    00EF7 8388      ST	Y,R24
    00EF8 E023      LDI	R18,3
    00EF9 E006      LDI	R16,6
    00EFA 940E 06AB CALL	_Set_White_off
(0198) 		   Set_White(10,3,11);
    00EFC E08B      LDI	R24,0xB
    00EFD 8388      ST	Y,R24
    00EFE E023      LDI	R18,3
    00EFF E00A      LDI	R16,0xA
    00F00 940E 0727 CALL	_Set_White
(0199) 		   cur=6;
    00F02 E046      LDI	R20,6
    00F03 E050      LDI	R21,0
(0200) 		   break;
(0201) 		  default:
(0202) 		   break;
(0203) 		 }
(0204) 	}else if(keyV=='s'){
    00F04 C0D3      RJMP	0x0FD8
    00F05 2D8A      MOV	R24,R10
    00F06 3783      CPI	R24,0x73
    00F07 F009      BEQ	0x0F09
    00F08 C03D      RJMP	0x0F46
(0205) 	   pageNum=5;
    00F09 E085      LDI	R24,5
    00F0A E090      LDI	R25,0
    00F0B 9390 066C STS	pageNum+1,R25
    00F0D 9380 066B STS	pageNum,R24
(0206) 	   switch(cur){
    00F0F 3040      CPI	R20,0
    00F10 0745      CPC	R20,R21
    00F11 F089      BEQ	0x0F23
    00F12 3041      CPI	R20,1
    00F13 E0E0      LDI	R30,0
    00F14 075E      CPC	R21,R30
    00F15 F0A1      BEQ	0x0F2A
    00F16 3042      CPI	R20,2
    00F17 E0E0      LDI	R30,0
    00F18 075E      CPC	R21,R30
    00F19 F0B9      BEQ	0x0F31
    00F1A 3043      CPI	R20,3
    00F1B E0E0      LDI	R30,0
    00F1C 075E      CPC	R21,R30
    00F1D F0D1      BEQ	0x0F38
    00F1E 3046      CPI	R20,6
    00F1F E0E0      LDI	R30,0
    00F20 075E      CPC	R21,R30
    00F21 F0E9      BEQ	0x0F3F
    00F22 C0B6      RJMP	0x0FD9
(0207) 		 case 0: 
(0208) 		    Set_White_off(2,1,3);
    00F23 E083      LDI	R24,3
    00F24 8388      ST	Y,R24
    00F25 E021      LDI	R18,1
    00F26 E002      LDI	R16,2
    00F27 940E 06AB CALL	_Set_White_off
(0209) 		    break;
    00F29 C0AF      RJMP	0x0FD9
(0210) 		 case 1:
(0211) 		   Set_White_off(7,1,8);
    00F2A E088      LDI	R24,0x8
    00F2B 8388      ST	Y,R24
    00F2C E021      LDI	R18,1
    00F2D E007      LDI	R16,7
    00F2E 940E 06AB CALL	_Set_White_off
(0212) 		   break;
    00F30 C0A8      RJMP	0x0FD9
(0213) 		 case 2:
(0214) 		  Set_White_off(2,2,3);
    00F31 E083      LDI	R24,3
    00F32 8388      ST	Y,R24
    00F33 E022      LDI	R18,2
    00F34 E002      LDI	R16,2
    00F35 940E 06AB CALL	_Set_White_off
(0215) 		  break;
    00F37 C0A1      RJMP	0x0FD9
(0216) 		 case 3:
(0217) 		   Set_White_off(7,2,8);
    00F38 E088      LDI	R24,0x8
    00F39 8388      ST	Y,R24
    00F3A E022      LDI	R18,2
    00F3B E007      LDI	R16,7
    00F3C 940E 06AB CALL	_Set_White_off
(0218) 		    break;
    00F3E C09A      RJMP	0x0FD9
(0219) 		 case 6:
(0220) 		   Set_White_off(10,3,11);
    00F3F E08B      LDI	R24,0xB
    00F40 8388      ST	Y,R24
    00F41 E023      LDI	R18,3
    00F42 E00A      LDI	R16,0xA
    00F43 940E 06AB CALL	_Set_White_off
(0221) 		    break;
(0222) 		  default:
(0223) 		   break;
(0224) 		 }
(0225) 	   return ;
    00F45 C093      RJMP	0x0FD9
(0226) 	}else if(keyV=='t'){
    00F46 2D8A      MOV	R24,R10
    00F47 3784      CPI	R24,0x74
    00F48 F009      BEQ	0x0F4A
    00F49 C08E      RJMP	0x0FD8
(0227) 	   switch(cur){
    00F4A 3040      CPI	R20,0
    00F4B 0745      CPC	R20,R21
    00F4C F0F1      BEQ	0x0F6B
    00F4D 3041      CPI	R20,1
    00F4E E0E0      LDI	R30,0
    00F4F 075E      CPC	R21,R30
    00F50 F191      BEQ	0x0F83
    00F51 3042      CPI	R20,2
    00F52 E0E0      LDI	R30,0
    00F53 075E      CPC	R21,R30
    00F54 F409      BNE	0x0F56
    00F55 C043      RJMP	0x0F99
    00F56 3043      CPI	R20,3
    00F57 E0E0      LDI	R30,0
    00F58 075E      CPC	R21,R30
    00F59 F409      BNE	0x0F5B
    00F5A C055      RJMP	0x0FB0
    00F5B 3044      CPI	R20,4
    00F5C E0E0      LDI	R30,0
    00F5D 075E      CPC	R21,R30
    00F5E F409      BNE	0x0F60
    00F5F C078      RJMP	0x0FD8
    00F60 3045      CPI	R20,5
    00F61 E0E0      LDI	R30,0
    00F62 075E      CPC	R21,R30
    00F63 F409      BNE	0x0F65
    00F64 C073      RJMP	0x0FD8
    00F65 3046      CPI	R20,6
    00F66 E0E0      LDI	R30,0
    00F67 075E      CPC	R21,R30
    00F68 F409      BNE	0x0F6A
    00F69 C05C      RJMP	0x0FC6
    00F6A C06D      RJMP	0x0FD8
(0228) 		 case 0: 
(0229) 		    Set_White_off(2,1,3);
    00F6B E083      LDI	R24,3
    00F6C 8388      ST	Y,R24
    00F6D E021      LDI	R18,1
    00F6E E002      LDI	R16,2
    00F6F 940E 06AB CALL	_Set_White_off
(0230) 		    prePageNum=1;
    00F71 E081      LDI	R24,1
    00F72 E090      LDI	R25,0
    00F73 9390 0660 STS	prePageNum+1,R25
    00F75 9380 065F STS	prePageNum,R24
(0231) 		    pageParam[0]=0;//传递使用第一个，对应不同的温度
    00F77 2422      CLR	R2
    00F78 2433      CLR	R3
    00F79 9230 0662 STS	pageParam+1,R3
    00F7B 9220 0661 STS	pageParam,R2
(0232) 		    pageNum=3;
    00F7D E083      LDI	R24,3
    00F7E 9390 066C STS	pageNum+1,R25
    00F80 9380 066B STS	pageNum,R24
(0233) 		    return;
    00F82 C056      RJMP	0x0FD9
(0234) 		 case 1:
(0235) 		   Set_White_off(7,1,8);
    00F83 E088      LDI	R24,0x8
    00F84 8388      ST	Y,R24
    00F85 E021      LDI	R18,1
    00F86 E007      LDI	R16,7
    00F87 940E 06AB CALL	_Set_White_off
(0236) 		    prePageNum=1;
    00F89 E081      LDI	R24,1
    00F8A E090      LDI	R25,0
    00F8B 9390 0660 STS	prePageNum+1,R25
    00F8D 9380 065F STS	prePageNum,R24
(0237) 		   pageParam[0]=1;//传递使用第一个，对应不同的温度
    00F8F 9390 0662 STS	pageParam+1,R25
    00F91 9380 0661 STS	pageParam,R24
(0238) 		    pageNum=3;
    00F93 E083      LDI	R24,3
    00F94 9390 066C STS	pageNum+1,R25
    00F96 9380 066B STS	pageNum,R24
(0239) 		    return;
    00F98 C040      RJMP	0x0FD9
(0240) 		 case 2:
(0241) 		  Set_White_off(2,2,3);
    00F99 E083      LDI	R24,3
    00F9A 8388      ST	Y,R24
    00F9B E022      LDI	R18,2
    00F9C E002      LDI	R16,2
    00F9D 940E 06AB CALL	_Set_White_off
(0242) 		    prePageNum=1;
    00F9F E081      LDI	R24,1
    00FA0 E090      LDI	R25,0
    00FA1 9390 0660 STS	prePageNum+1,R25
    00FA3 9380 065F STS	prePageNum,R24
(0243) 		    pageParam[0]=2;//传递使用第一个，对应不同的温度
    00FA5 E082      LDI	R24,2
    00FA6 9390 0662 STS	pageParam+1,R25
    00FA8 9380 0661 STS	pageParam,R24
(0244) 		   pageNum=3;
    00FAA E083      LDI	R24,3
    00FAB 9390 066C STS	pageNum+1,R25
    00FAD 9380 066B STS	pageNum,R24
(0245) 		   return;
    00FAF C029      RJMP	0x0FD9
(0246) 		 case 3:
(0247) 		   Set_White_off(7,2,8);
    00FB0 E088      LDI	R24,0x8
    00FB1 8388      ST	Y,R24
    00FB2 E022      LDI	R18,2
    00FB3 E007      LDI	R16,7
    00FB4 940E 06AB CALL	_Set_White_off
(0248) 		     prePageNum=1;
    00FB6 E081      LDI	R24,1
    00FB7 E090      LDI	R25,0
    00FB8 9390 0660 STS	prePageNum+1,R25
    00FBA 9380 065F STS	prePageNum,R24
(0249) 		    pageParam[0]=3;//传递使用第一个，对应不同的温度
    00FBC E083      LDI	R24,3
    00FBD 9390 0662 STS	pageParam+1,R25
    00FBF 9380 0661 STS	pageParam,R24
(0250) 		    pageNum=3;
    00FC1 9390 066C STS	pageNum+1,R25
    00FC3 9380 066B STS	pageNum,R24
(0251) 		    return;
    00FC5 C013      RJMP	0x0FD9
(0252) 		 case 4:
(0253) 		    //调用函数全部开始，参数正确的
(0254) 		   break;
(0255) 		 case 5:
(0256) 		    //全部停止
(0257) 		   break;
(0258) 		 case 6:
(0259) 		   Set_White_off(10,3,11);
    00FC6 E08B      LDI	R24,0xB
    00FC7 8388      ST	Y,R24
    00FC8 E023      LDI	R18,3
    00FC9 E00A      LDI	R16,0xA
    00FCA 940E 06AB CALL	_Set_White_off
(0260) 		    prePageNum=1;
    00FCC E081      LDI	R24,1
    00FCD E090      LDI	R25,0
    00FCE 9390 0660 STS	prePageNum+1,R25
    00FD0 9380 065F STS	prePageNum,R24
(0261) 		   pageNum=5;
    00FD2 E085      LDI	R24,5
    00FD3 9390 066C STS	pageNum+1,R25
    00FD5 9380 066B STS	pageNum,R24
(0262) 		    return;
    00FD7 C001      RJMP	0x0FD9
    00FD8 CD45      RJMP	0x0D1E
    00FD9 9622      ADIW	R28,2
    00FDA 940C 116E JMP	pop_xgsetF03C
_page3:
    00FDC 9722      SBIW	R28,2
(0263) 		  default:
(0264) 		   break;
(0265) 		 }
(0266) 	
(0267) 	}
(0268)   }
(0269)    return;
(0270) }
(0271)  void page3(void){
(0272)    lcd_write_str(1,1,"Page3");
    00FDD E484      LDI	R24,0x44
    00FDE E091      LDI	R25,1
    00FDF 8399      STD	Y+1,R25
    00FE0 8388      ST	Y,R24
    00FE1 E021      LDI	R18,1
    00FE2 E001      LDI	R16,1
    00FE3 940E 04C2 CALL	_lcd_write_str
    00FE5 9622      ADIW	R28,2
    00FE6 9508      RET
_page5:
  cur                  --> R20
  keyV                 --> R22
    00FE7 940E 113F CALL	push_xgsetF000
    00FE9 9722      SBIW	R28,2
(0273)  }
(0274)  void page5(void){
(0275)   uint cur=0;
(0276)    uchar keyV;
(0277)    lcd_write_str(4,0,"断电自动重置");
    00FEA E387      LDI	R24,0x37
    00FEB E091      LDI	R25,1
    00FEC 8399      STD	Y+1,R25
    00FED 8388      ST	Y,R24
    00FEE 2722      CLR	R18
    00FEF E004      LDI	R16,4
    00FF0 940E 04C2 CALL	_lcd_write_str
(0278)    lcd_write_str(4,1,"设置时间");
    00FF2 E28E      LDI	R24,0x2E
    00FF3 E091      LDI	R25,1
    00FF4 8399      STD	Y+1,R25
    00FF5 8388      ST	Y,R24
    00FF6 E021      LDI	R18,1
    00FF7 E004      LDI	R16,4
    00FF8 940E 04C2 CALL	_lcd_write_str
(0279)    lcd_write_str(4,2,"重置系统");
    00FFA E285      LDI	R24,0x25
    00FFB E091      LDI	R25,1
    00FFC 8399      STD	Y+1,R25
    00FFD 8388      ST	Y,R24
    00FFE E022      LDI	R18,2
    00FFF E004      LDI	R16,4
    01000 940E 04C2 CALL	_lcd_write_str
(0280)    lcd_write_char(3,0,0xA1);
    01002 EA81      LDI	R24,0xA1
    01003 8388      ST	Y,R24
    01004 2722      CLR	R18
    01005 E003      LDI	R16,3
    01006 940E 049C CALL	_lcd_write_char
(0281)    lcd_write_char_con(0,0xC1);
    01008 EC21      LDI	R18,0xC1
    01009 2700      CLR	R16
    0100A 940E 046A CALL	_lcd_write_char_con
(0282)    
(0283)    /* lcd_write_char(1,0,0xA1);
(0284)    lcd_write_char_con(0,0xCC);*/
(0285)    cur=0;
    0100C 2744      CLR	R20
    0100D 2755      CLR	R21
(0286)    Set_White(5,0,10);
    0100E E08A      LDI	R24,0xA
    0100F 8388      ST	Y,R24
    01010 2722      CLR	R18
    01011 E005      LDI	R16,5
    01012 940E 0727 CALL	_Set_White
    01014 C097      RJMP	0x10AC
(0287)    while(1){
(0288)       keyV=KeyScan_once();
    01015 940E 0343 CALL	_KeyScan_once
    01017 2F60      MOV	R22,R16
(0289) 	  if(keyV=='u'){
    01018 3705      CPI	R16,0x75
    01019 F539      BNE	0x1041
(0290) 	    switch(cur){
    0101A 3041      CPI	R20,1
    0101B E0E0      LDI	R30,0
    0101C 075E      CPC	R21,R30
    0101D F029      BEQ	0x1023
    0101E 3042      CPI	R20,2
    0101F E0E0      LDI	R30,0
    01020 075E      CPC	R21,R30
    01021 F081      BEQ	0x1032
    01022 C089      RJMP	0x10AC
(0291) 		  case 1:
(0292) 		   Set_White_off(5,1,8);
    01023 E088      LDI	R24,0x8
    01024 8388      ST	Y,R24
    01025 E021      LDI	R18,1
    01026 E005      LDI	R16,5
    01027 940E 06AB CALL	_Set_White_off
(0293) 		   Set_White(5,0,10);
    01029 E08A      LDI	R24,0xA
    0102A 8388      ST	Y,R24
    0102B 2722      CLR	R18
    0102C E005      LDI	R16,5
    0102D 940E 0727 CALL	_Set_White
(0294) 		   cur=0;
    0102F 2744      CLR	R20
    01030 2755      CLR	R21
(0295) 		   break;
    01031 C07A      RJMP	0x10AC
(0296) 		  case 2: 
(0297) 		   Set_White_off(5,2,8);
    01032 E088      LDI	R24,0x8
    01033 8388      ST	Y,R24
    01034 E022      LDI	R18,2
    01035 E005      LDI	R16,5
    01036 940E 06AB CALL	_Set_White_off
(0298) 		   Set_White(5,1,8);
    01038 E088      LDI	R24,0x8
    01039 8388      ST	Y,R24
    0103A E021      LDI	R18,1
    0103B E005      LDI	R16,5
    0103C 940E 0727 CALL	_Set_White
(0299) 		   cur=1;
    0103E E041      LDI	R20,1
    0103F E050      LDI	R21,0
(0300) 		   break;
(0301) 		}
(0302) 	  }else if(keyV=='d'){
    01040 C06B      RJMP	0x10AC
    01041 3664      CPI	R22,0x64
    01042 F531      BNE	0x1069
(0303) 	      switch(cur){
    01043 3040      CPI	R20,0
    01044 0745      CPC	R20,R21
    01045 F029      BEQ	0x104B
    01046 3041      CPI	R20,1
    01047 E0E0      LDI	R30,0
    01048 075E      CPC	R21,R30
    01049 F081      BEQ	0x105A
    0104A C061      RJMP	0x10AC
(0304) 		  case 0:
(0305) 		   Set_White_off(5,0,10);
    0104B E08A      LDI	R24,0xA
    0104C 8388      ST	Y,R24
    0104D 2722      CLR	R18
    0104E E005      LDI	R16,5
    0104F 940E 06AB CALL	_Set_White_off
(0306) 		   Set_White(5,1,8);
    01051 E088      LDI	R24,0x8
    01052 8388      ST	Y,R24
    01053 E021      LDI	R18,1
    01054 E005      LDI	R16,5
    01055 940E 0727 CALL	_Set_White
(0307) 		   cur=1;
    01057 E041      LDI	R20,1
    01058 E050      LDI	R21,0
(0308) 		   break;
    01059 C052      RJMP	0x10AC
(0309) 		  case 1: 
(0310) 		   Set_White_off(5,1,8);
    0105A E088      LDI	R24,0x8
    0105B 8388      ST	Y,R24
    0105C E021      LDI	R18,1
    0105D E005      LDI	R16,5
    0105E 940E 06AB CALL	_Set_White_off
(0311) 		   Set_White(5,2,8);
    01060 E088      LDI	R24,0x8
    01061 8388      ST	Y,R24
    01062 E022      LDI	R18,2
    01063 E005      LDI	R16,5
    01064 940E 0727 CALL	_Set_White
(0312) 		   cur=2;
    01066 E042      LDI	R20,2
    01067 E050      LDI	R21,0
(0313) 		   break;
(0314) 		}
(0315) 	  }else if(keyV=='e'){
    01068 C043      RJMP	0x10AC
    01069 3665      CPI	R22,0x65
    0106A F539      BNE	0x1092
(0316) 	     switch(cur){
    0106B 3040      CPI	R20,0
    0106C 0745      CPC	R20,R21
    0106D F049      BEQ	0x1077
    0106E 3041      CPI	R20,1
    0106F E0E0      LDI	R30,0
    01070 075E      CPC	R21,R30
    01071 F061      BEQ	0x107E
    01072 3042      CPI	R20,2
    01073 E0E0      LDI	R30,0
    01074 075E      CPC	R21,R30
    01075 F079      BEQ	0x1085
    01076 C014      RJMP	0x108B
(0317) 		 case 0: 
(0318) 		   Set_White_off(5,0,10);
    01077 E08A      LDI	R24,0xA
    01078 8388      ST	Y,R24
    01079 2722      CLR	R18
    0107A E005      LDI	R16,5
    0107B 940E 06AB CALL	_Set_White_off
(0319) 		    break;
    0107D C00D      RJMP	0x108B
(0320) 		 case 1:
(0321) 		   Set_White_off(5,1,8);
    0107E E088      LDI	R24,0x8
    0107F 8388      ST	Y,R24
    01080 E021      LDI	R18,1
    01081 E005      LDI	R16,5
    01082 940E 06AB CALL	_Set_White_off
(0322) 		   break;
    01084 C006      RJMP	0x108B
(0323) 		 case 2:
(0324) 		  Set_White_off(5,2,8);
    01085 E088      LDI	R24,0x8
    01086 8388      ST	Y,R24
    01087 E022      LDI	R18,2
    01088 E005      LDI	R16,5
    01089 940E 06AB CALL	_Set_White_off
(0325) 		  break;
(0326) 	
(0327) 		  default:
(0328) 		   break;
(0329) 		 }
(0330) 	    pageNum=1;
    0108B E081      LDI	R24,1
    0108C E090      LDI	R25,0
    0108D 9390 066C STS	pageNum+1,R25
    0108F 9380 066B STS	pageNum,R24
(0331) 		return;
    01091 C01B      RJMP	0x10AD
(0332) 	  }else if(keyV=='t'){
    01092 3764      CPI	R22,0x74
    01093 F4C1      BNE	0x10AC
(0333) 	    switch(cur){
    01094 3040      CPI	R20,0
    01095 0745      CPC	R20,R21
    01096 F0A9      BEQ	0x10AC
    01097 3041      CPI	R20,1
    01098 E0E0      LDI	R30,0
    01099 075E      CPC	R21,R30
    0109A F029      BEQ	0x10A0
    0109B 3042      CPI	R20,2
    0109C E0E0      LDI	R30,0
    0109D 075E      CPC	R21,R30
    0109E F069      BEQ	0x10AC
    0109F C00C      RJMP	0x10AC
(0334) 		  case 0:
(0335) 		     //执行EEPROM操作
(0336) 		    break;
(0337) 		  case 1:
(0338) 		   pageNum=8;
    010A0 E088      LDI	R24,0x8
    010A1 E090      LDI	R25,0
    010A2 9390 066C STS	pageNum+1,R25
    010A4 9380 066B STS	pageNum,R24
(0339) 		   Set_White_off(5,1,8);
    010A6 8388      ST	Y,R24
    010A7 E021      LDI	R18,1
    010A8 E005      LDI	R16,5
    010A9 940E 06AB CALL	_Set_White_off
(0340) 		   return;
    010AB C001      RJMP	0x10AD
    010AC CF68      RJMP	0x1015
    010AD 9622      ADIW	R28,2
    010AE 940C 1144 JMP	pop_xgsetF000
_page8:
    010B0 9722      SBIW	R28,2
(0341) 		  
(0342) 		  case 2:
(0343) 		    //重置系统
(0344) 		    break;
(0345) 		}
(0346) 	    
(0347) 	  }
(0348)    }
(0349)    
(0350)  }
(0351)  void page8(void){
(0352)    lcd_write_str(1,1,"Page8");
    010B1 E18F      LDI	R24,0x1F
    010B2 E091      LDI	R25,1
    010B3 8399      STD	Y+1,R25
    010B4 8388      ST	Y,R24
    010B5 E021      LDI	R18,1
    010B6 E001      LDI	R16,1
    010B7 940E 04C2 CALL	_lcd_write_str
(0353)    while(1){
    010B9 CFFF      RJMP	0x10B9
    010BA 9622      ADIW	R28,2
    010BB 9508      RET
(0354)    
(0355)    }
(0356)  }
(0357) //分发Pages
(0358) void dispatchPages(void){
(0359)       lcd_clear();//清屏幕
_dispatchPages:
    010BC 940E 0579 CALL	_lcd_clear
(0360)       if(pageNum==1){
    010BE 9180 066B LDS	R24,pageNum
    010C0 9190 066C LDS	R25,pageNum+1
    010C2 3081      CPI	R24,1
    010C3 E0E0      LDI	R30,0
    010C4 079E      CPC	R25,R30
    010C5 F411      BNE	0x10C8
(0361) 	    page1();
    010C6 DC05      RCALL	_page1
(0362) 	  }else if(pageNum==2){
    010C7 C041      RJMP	0x1109
    010C8 9180 066B LDS	R24,pageNum
    010CA 9190 066C LDS	R25,pageNum+1
    010CC 3082      CPI	R24,2
    010CD E0E0      LDI	R30,0
    010CE 079E      CPC	R25,R30
    010CF F409      BNE	0x10D1
(0363) 	   // page2();
(0364) 	  }else if(pageNum==3){
    010D0 C038      RJMP	0x1109
    010D1 9180 066B LDS	R24,pageNum
    010D3 9190 066C LDS	R25,pageNum+1
    010D5 3083      CPI	R24,3
    010D6 E0E0      LDI	R30,0
    010D7 079E      CPC	R25,R30
    010D8 F411      BNE	0x10DB
(0365) 	    page3();
    010D9 DF02      RCALL	_page3
(0366) 	  }else if(pageNum==4){
    010DA C02E      RJMP	0x1109
    010DB 9180 066B LDS	R24,pageNum
    010DD 9190 066C LDS	R25,pageNum+1
    010DF 3084      CPI	R24,4
    010E0 E0E0      LDI	R30,0
    010E1 079E      CPC	R25,R30
    010E2 F409      BNE	0x10E4
(0367) 	   // page4();
(0368) 	  }else if(pageNum==5){
    010E3 C025      RJMP	0x1109
    010E4 9180 066B LDS	R24,pageNum
    010E6 9190 066C LDS	R25,pageNum+1
    010E8 3085      CPI	R24,5
    010E9 E0E0      LDI	R30,0
    010EA 079E      CPC	R25,R30
    010EB F411      BNE	0x10EE
(0369) 	    page5();
    010EC DEFA      RCALL	_page5
(0370) 	  }else if(pageNum==6){
    010ED C01B      RJMP	0x1109
    010EE 9180 066B LDS	R24,pageNum
    010F0 9190 066C LDS	R25,pageNum+1
    010F2 3086      CPI	R24,6
    010F3 E0E0      LDI	R30,0
    010F4 079E      CPC	R25,R30
    010F5 F409      BNE	0x10F7
(0371) 	   // page6();
(0372) 	  }else if(pageNum==7){
    010F6 C012      RJMP	0x1109
    010F7 9180 066B LDS	R24,pageNum
    010F9 9190 066C LDS	R25,pageNum+1
    010FB 3087      CPI	R24,7
    010FC E0E0      LDI	R30,0
    010FD 079E      CPC	R25,R30
    010FE F409      BNE	0x1100
(0373) 	    //page7();
(0374) 	  }else if(pageNum==8){
    010FF C009      RJMP	0x1109
    01100 9180 066B LDS	R24,pageNum
    01102 9190 066C LDS	R25,pageNum+1
    01104 3088      CPI	R24,0x8
    01105 E0E0      LDI	R30,0
    01106 079E      CPC	R25,R30
    01107 F409      BNE	0x1109
(0375) 	    page8();
    01108 DFA7      RCALL	_page8
(0376) 	  }
FILE: <library>
    01109 9508      RET
push_arg4:
    0110A 933A      ST	-Y,R19
    0110B 932A      ST	-Y,R18
push_arg2:
    0110C 931A      ST	-Y,R17
    0110D 930A      ST	-Y,R16
    0110E 9508      RET
pop_xgset00FC:
    0110F 90A9      LD	R10,Y+
    01110 90B9      LD	R11,Y+
    01111 90C9      LD	R12,Y+
    01112 90D9      LD	R13,Y+
    01113 90E9      LD	R14,Y+
    01114 90F9      LD	R15,Y+
    01115 9508      RET
pop_xgset30FC:
    01116 90A9      LD	R10,Y+
    01117 90B9      LD	R11,Y+
    01118 90C9      LD	R12,Y+
    01119 90D9      LD	R13,Y+
    0111A 90E9      LD	R14,Y+
    0111B 90F9      LD	R15,Y+
    0111C 9149      LD	R20,Y+
    0111D 9159      LD	R21,Y+
    0111E 9508      RET
pop_xgsetF0FC:
    0111F 90A9      LD	R10,Y+
    01120 90B9      LD	R11,Y+
    01121 90C9      LD	R12,Y+
    01122 90D9      LD	R13,Y+
    01123 90E9      LD	R14,Y+
    01124 90F9      LD	R15,Y+
    01125 9149      LD	R20,Y+
    01126 9159      LD	R21,Y+
    01127 9169      LD	R22,Y+
    01128 9179      LD	R23,Y+
    01129 9508      RET
push_xgsetF0FC:
    0112A 937A      ST	-Y,R23
    0112B 936A      ST	-Y,R22
push_xgset30FC:
    0112C 935A      ST	-Y,R21
    0112D 934A      ST	-Y,R20
push_xgset00FC:
    0112E 92FA      ST	-Y,R15
    0112F 92EA      ST	-Y,R14
push_xgset003C:
    01130 92DA      ST	-Y,R13
    01131 92CA      ST	-Y,R12
    01132 92BA      ST	-Y,R11
    01133 92AA      ST	-Y,R10
    01134 9508      RET
push_xgset300C:
    01135 935A      ST	-Y,R21
    01136 934A      ST	-Y,R20
    01137 92BA      ST	-Y,R11
    01138 92AA      ST	-Y,R10
    01139 9508      RET
pop_xgset300C:
    0113A 90A9      LD	R10,Y+
    0113B 90B9      LD	R11,Y+
    0113C 9149      LD	R20,Y+
    0113D 9159      LD	R21,Y+
    0113E 9508      RET
push_xgsetF000:
    0113F 937A      ST	-Y,R23
    01140 936A      ST	-Y,R22
    01141 935A      ST	-Y,R21
    01142 934A      ST	-Y,R20
    01143 9508      RET
pop_xgsetF000:
    01144 9149      LD	R20,Y+
    01145 9159      LD	R21,Y+
    01146 9169      LD	R22,Y+
    01147 9179      LD	R23,Y+
    01148 9508      RET
push_xgsetF00C:
    01149 937A      ST	-Y,R23
    0114A 936A      ST	-Y,R22
    0114B 935A      ST	-Y,R21
    0114C 934A      ST	-Y,R20
    0114D 92BA      ST	-Y,R11
    0114E 92AA      ST	-Y,R10
    0114F 9508      RET
pop_xgsetF00C:
    01150 90A9      LD	R10,Y+
    01151 90B9      LD	R11,Y+
    01152 9149      LD	R20,Y+
    01153 9159      LD	R21,Y+
    01154 9169      LD	R22,Y+
    01155 9179      LD	R23,Y+
    01156 9508      RET
push_xgset303C:
    01157 935A      ST	-Y,R21
    01158 934A      ST	-Y,R20
    01159 92DA      ST	-Y,R13
    0115A 92CA      ST	-Y,R12
    0115B 92BA      ST	-Y,R11
    0115C 92AA      ST	-Y,R10
    0115D 9508      RET
pop_xgset303C:
    0115E 90A9      LD	R10,Y+
    0115F 90B9      LD	R11,Y+
    01160 90C9      LD	R12,Y+
    01161 90D9      LD	R13,Y+
    01162 9149      LD	R20,Y+
    01163 9159      LD	R21,Y+
    01164 9508      RET
push_xgsetF03C:
    01165 937A      ST	-Y,R23
    01166 936A      ST	-Y,R22
    01167 935A      ST	-Y,R21
    01168 934A      ST	-Y,R20
    01169 92DA      ST	-Y,R13
    0116A 92CA      ST	-Y,R12
    0116B 92BA      ST	-Y,R11
    0116C 92AA      ST	-Y,R10
    0116D 9508      RET
pop_xgsetF03C:
    0116E 90A9      LD	R10,Y+
    0116F 90B9      LD	R11,Y+
    01170 90C9      LD	R12,Y+
    01171 90D9      LD	R13,Y+
    01172 9149      LD	R20,Y+
    01173 9159      LD	R21,Y+
    01174 9169      LD	R22,Y+
    01175 9179      LD	R23,Y+
    01176 9508      RET
lsl16:
    01177 2322      TST	R18
    01178 F021      BEQ	0x117D
    01179 0F00      LSL	R16
    0117A 1F11      ROL	R17
    0117B 952A      DEC	R18
    0117C CFFA      RJMP	lsl16
    0117D 9508      RET
lsl8:
    0117E 2311      TST	R17
    0117F F019      BEQ	0x1183
    01180 0F00      LSL	R16
    01181 951A      DEC	R17
    01182 CFFB      RJMP	lsl8
    01183 9508      RET
