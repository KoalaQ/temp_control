Interrupt Vectors
    00000 940C 0050 JMP	__start|__text_start
    00014 940C 07B1 JMP	_int_timer2
    0001C 940C 0760 JMP	_int_timer1
    00020 940C 0712 JMP	_int_timer0
    0003A 940C 0802 JMP	_int_timer3

Program Code (text area)
__start|__text_start:
    00050 EFCF      LDI	R28,0xFF
    00051 E1D0      LDI	R29,0x10
    00052 BFCD      OUT	0x3D,R28
    00053 BFDE      OUT	0x3E,R29
    00054 51CE      SUBI	R28,0x1E
    00055 40D0      SBCI	R29,0
    00056 EA0A      LDI	R16,0xAA
    00057 8308      ST	Y,R16
    00058 2400      CLR	R0
    00059 E1E3      LDI	R30,0x13
    0005A E0F1      LDI	R31,1
    0005B E015      LDI	R17,5
    0005C 3DE0      CPI	R30,0xD0
    0005D 07F1      CPC	R31,R17
    0005E F011      BEQ	0x0061
    0005F 9201      ST	Z+,R0
    00060 CFFB      RJMP	0x005C
    00061 8300      ST	Z,R16
    00062 E8EC      LDI	R30,0x8C
    00063 E0F0      LDI	R31,0
    00064 E0A0      LDI	R26,0
    00065 E0B1      LDI	R27,1
    00066 E010      LDI	R17,0
    00067 E000      LDI	R16,0
    00068 BF0B      OUT	0x3B,R16
    00069 39EF      CPI	R30,0x9F
    0006A 07F1      CPC	R31,R17
    0006B F021      BEQ	0x0070
    0006C 95C8      LPM
    0006D 9631      ADIW	R30,1
    0006E 920D      ST	X+,R0
    0006F CFF9      RJMP	0x0069
    00070 940E 06A8 CALL	_main
_exit:
    00072 CFFF      RJMP	_exit
FILE: E:\ICCDemo\Temp_Control\temp_control\delay.c
(0001) #include<iom128v.h>
(0002) #include "delay.h"
(0003) 
(0004) 
(0005) void delay_us(uint n)//延时us
(0006) {
(0007)   n=2*n;
_delay_us:
  n                    --> R16
    00073 0F00      LSL	R16
    00074 1F11      ROL	R17
(0008)   do{ n--;
    00075 5001      SUBI	R16,1
    00076 4010      SBCI	R17,0
(0009)   }while(n>1);
    00077 E081      LDI	R24,1
    00078 E090      LDI	R25,0
    00079 1780      CP	R24,R16
    0007A 0791      CPC	R25,R17
    0007B F3C8      BCS	0x0075
    0007C 9508      RET
_delay_ms:
  j                    --> R20
    0007D 934A      ST	-Y,R20
    0007E 935A      ST	-Y,R21
    0007F 01A8      MOVW	R20,R16
(0010) }
(0011) void delay_ms(uint j)//延时ms
(0012) {
(0013)    do{j--;
    00080 5041      SUBI	R20,1
    00081 4050      SBCI	R21,0
(0014)      delay_us(1141);
    00082 E705      LDI	R16,0x75
    00083 E014      LDI	R17,4
    00084 DFEE      RCALL	_delay_us
(0015)    }while(j>1);
    00085 E081      LDI	R24,1
    00086 E090      LDI	R25,0
    00087 1784      CP	R24,R20
    00088 0795      CPC	R25,R21
    00089 F3B0      BCS	0x0080
    0008A 9159      LD	R21,Y+
    0008B 9149      LD	R20,Y+
    0008C 9508      RET
_delay_s:
  i                    --> R20
    0008D 934A      ST	-Y,R20
    0008E 935A      ST	-Y,R21
    0008F 01A8      MOVW	R20,R16
(0016) }
(0017) void delay_s(uint i)
(0018) {
(0019)    do{
(0020)    i--;
    00090 5041      SUBI	R20,1
    00091 4050      SBCI	R21,0
(0021)    delay_ms(1000);
    00092 EE08      LDI	R16,0xE8
    00093 E013      LDI	R17,3
    00094 DFE8      RCALL	_delay_ms
(0022)    }while(i>1);
    00095 E081      LDI	R24,1
    00096 E090      LDI	R25,0
    00097 1784      CP	R24,R20
    00098 0795      CPC	R25,R21
    00099 F3B0      BCS	0x0090
    0009A 9159      LD	R21,Y+
    0009B 9149      LD	R20,Y+
    0009C 9508      RET
_Write1302:
  temp                 --> R10
  i                    --> R20
  dat                  --> R18
  addr                 --> R16
    0009D 92AA      ST	-Y,R10
    0009E 934A      ST	-Y,R20
FILE: E:\ICCDemo\Temp_Control\temp_control\time.c
(0001) #include<iom128v.h>
(0002) #include "time.h"
(0003) #include "delay.h"
(0004) #include "lcd.h"
(0005) //寄存器宏定义
(0006) #define WRITE_SECOND 0x80
(0007) #define WRITE_MINUTE 0x82 
(0008) #define WRITE_HOUR 0x84
(0009) #define WRITE_DAY 0x86
(0010) #define WRITE_MONTH 0x88 
(0011) #define WRITE_WEEK 0x8A
(0012) #define WRITE_YEAE 0x8C
(0013) #define WRITE_PROTECT 0x8E 
(0014) 
(0015) #define READ_SECOND 0x81 
(0016) #define READ_MINUTE 0x83 
(0017) #define READ_HOUR 0x85 
(0018) #define READ_DAY 0x87
(0019) #define READ_MONTH 0x89
(0020) #define READ_WEEK 0x8B
(0021) #define READ_YEAE 0x8D
(0022) #define READ_PROTECT 0x8F
(0023) 
(0024) 
(0025) #define  SCLK_H  PORTD|=1<<PD0 //
(0026) #define  SCLK_L  PORTD&=~(1<<PD0) //
(0027) #define  DIO    PORTD&(~(1<<PD1)) //会获得PB1的值，判断是否等于0来确定值
(0028) #define  DIO_H   PORTD|=1<<PD1 //
(0029) #define  DIO_L  PORTD&=~(1<<PD1)  //
(0030) #define  CE_H    PORTD|=1<<PD2
(0031) #define  CE_L   PORTD&=~(1<<PD2) 
(0032) //地址、数据发送子程序
(0033) void Write1302  ( unsigned char  addr,unsigned char dat )
(0034) { 
(0035)   unsigned char  i,temp; 
(0036)   CE_L; //CE引脚为低，数据传送中止
    0009F 9892      CBI	0x12,2
(0037)   SCLK_L;//清零时钟总线?
    000A0 9890      CBI	0x12,0
(0038)   CE_H;//CE引脚为高，逻辑控制有效
    000A1 9A92      SBI	0x12,2
(0039)   //发送地址?
(0040)     for ( i=8; i>0; i-- ) //循环8次移位
    000A2 E048      LDI	R20,0x8
    000A3 C00A      RJMP	0x00AE
(0041)     { 
(0042)        SCLK_L;
    000A4 9890      CBI	0x12,0
(0043) 	   temp=addr;
    000A5 2EA0      MOV	R10,R16
(0044)        if((temp&0x01))//每次传输低字节
    000A6 FF00      SBRS	R16,0
    000A7 C002      RJMP	0x00AA
(0045) 	   {
(0046) 	   	DIO_H;
    000A8 9A91      SBI	0x12,1
(0047) 	   }else{
    000A9 C001      RJMP	0x00AB
(0048) 	   DIO_L;
    000AA 9891      CBI	0x12,1
(0049) 	   }
(0050)        addr>>=1;//右移一位
    000AB 9506      LSR	R16
(0051) 			  SCLK_H;
    000AC 9A90      SBI	0x12,0
    000AD 954A      DEC	R20
    000AE E080      LDI	R24,0
    000AF 1784      CP	R24,R20
    000B0 F398      BCS	0x00A4
(0052)  }
(0053) //发送数据?
(0054) for(i=8;i>0;i--){
    000B1 E048      LDI	R20,0x8
    000B2 C00A      RJMP	0x00BD
(0055)    SCLK_L; 
    000B3 9890      CBI	0x12,0
(0056)    temp=dat;
    000B4 2EA2      MOV	R10,R18
(0057)    if((temp&0x01))//每次传输低字节
    000B5 FF20      SBRS	R18,0
    000B6 C002      RJMP	0x00B9
(0058) 	   {
(0059) 	   	DIO_H;
    000B7 9A91      SBI	0x12,1
(0060) 	   }else{
    000B8 C001      RJMP	0x00BA
(0061) 	   DIO_L;
    000B9 9891      CBI	0x12,1
(0062) 	   }
(0063) 	dat>>=1;
    000BA 9526      LSR	R18
(0064)     SCLK_H;
    000BB 9A90      SBI	0x12,0
    000BC 954A      DEC	R20
    000BD E080      LDI	R24,0
    000BE 1784      CP	R24,R20
    000BF F398      BCS	0x00B3
(0065)   }
(0066)    CE_L;
    000C0 9892      CBI	0x12,2
    000C1 9149      LD	R20,Y+
    000C2 90A9      LD	R10,Y+
    000C3 9508      RET
_Read1302:
  data                 --> R10
  temp                 --> R14
  i                    --> R20
  addr                 --> R12
    000C4 940E 0BA9 CALL	push_xgset30FC
    000C6 2EC0      MOV	R12,R16
(0067) }
(0068) //数据读取子程序
(0069) unsigned char Read1302( unsigned char addr ){
(0070)    unsigned char i,temp,data=0;
    000C7 24AA      CLR	R10
(0071)    CE_L;
    000C8 9892      CBI	0x12,2
(0072)    SCLK_L;
    000C9 9890      CBI	0x12,0
(0073)    CE_H;//发送地址?
    000CA 9A92      SBI	0x12,2
(0074)    for(i=8;i>0;i--)//循环8次移位
    000CB E048      LDI	R20,0x8
    000CC C00A      RJMP	0x00D7
(0075)    {
(0076)       
(0077) 	   temp=addr;
    000CD 2CEC      MOV	R14,R12
(0078)       if((temp&0x01))//每次传输低字节
    000CE FEC0      SBRS	R12,0
    000CF C002      RJMP	0x00D2
(0079) 	   {
(0080) 	   	DIO_H;
    000D0 9A91      SBI	0x12,1
(0081) 	   }else{
    000D1 C001      RJMP	0x00D3
(0082) 	   DIO_L;
    000D2 9891      CBI	0x12,1
(0083) 	   }
(0084) 	   SCLK_L;
    000D3 9890      CBI	0x12,0
(0085)        addr>>=1;//右移一位
    000D4 94C6      LSR	R12
(0086) 	  SCLK_H;
    000D5 9A90      SBI	0x12,0
    000D6 954A      DEC	R20
    000D7 E080      LDI	R24,0
    000D8 1784      CP	R24,R20
    000D9 F398      BCS	0x00CD
(0087)    }
(0088) //读取数据
(0089) DDRD&=0xFD;
    000DA B381      IN	R24,0x11
    000DB 7F8D      ANDI	R24,0xFD
    000DC BB81      OUT	0x11,R24
(0090)  for(i=0;i<8;i++)
    000DD 2744      CLR	R20
    000DE C00E      RJMP	0x00ED
(0091)   {
(0092)      SCLK_H;
    000DF 9A90      SBI	0x12,0
(0093) 	 SCLK_L;
    000E0 9890      CBI	0x12,0
(0094) 	 delay_ms(1);
    000E1 E001      LDI	R16,1
    000E2 E010      LDI	R17,0
    000E3 940E 007D CALL	_delay_ms
(0095)    	 data |=(((PIND&(1<<PD1))>>1)<<i);
    000E5 B300      IN	R16,0x10
    000E6 7002      ANDI	R16,2
    000E7 9506      LSR	R16
    000E8 2F14      MOV	R17,R20
    000E9 940E 0BF1 CALL	lsl8
    000EB 2AA0      OR	R10,R16
    000EC 9543      INC	R20
    000ED 3048      CPI	R20,0x8
    000EE F380      BCS	0x00DF
(0096)            
(0097)     }
(0098) 	///PORTE=data;
(0099)    DDRD|=0x07;
    000EF B381      IN	R24,0x11
    000F0 6087      ORI	R24,7
    000F1 BB81      OUT	0x11,R24
(0100)     CE_L;
    000F2 9892      CBI	0x12,2
(0101)     // temp = data>>4;
(0102)    // data &= 0x0f;
(0103)     //data = temp*10 + data;
(0104) 	
(0105)     return(data);
    000F3 2D0A      MOV	R16,R10
    000F4 940C 0B93 JMP	pop_xgset30FC
(0106) }
(0107) //初始化DS1302?
(0108) void Initial_time(void) {
(0109)    DDRD|=0x07;
_Initial_time:
    000F6 B381      IN	R24,0x11
    000F7 6087      ORI	R24,7
    000F8 BB81      OUT	0x11,R24
(0110)    PORTD=0x00;
    000F9 2422      CLR	R2
    000FA BA22      OUT	0x12,R2
(0111)   // Write1302(WRITE_PROTECT,0X00);//禁止写保护
(0112)    //Write1302(WRITE_SECOND,0x00);//秒位初始化
(0113)    //Write1302(WRITE_MINUTE,0x50);//分钟初始化
(0114)   // Write1302(WRITE_HOUR,0xa4);//小时初始化
(0115)    Write1302(WRITE_PROTECT,0x80);//写保护
    000FB E820      LDI	R18,0x80
    000FC E80E      LDI	R16,0x8E
    000FD CF9F      RJMP	_Write1302
_showTimeLcd:
    000FE 92AA      ST	-Y,R10
    000FF 934A      ST	-Y,R20
    00100 9721      SBIW	R28,1
(0116) }
(0117) //显示时间，时分秒
(0118) void showTimeLcd(void){
(0119)    //PORTE=~Read1302(0x81);
(0120) 	if(Read1302(0x85)&0x80){
    00101 E805      LDI	R16,0x85
    00102 DFC1      RCALL	_Read1302
    00103 FF07      SBRS	R16,7
    00104 C048      RJMP	0x014D
(0121) 	if( (Read1302(0x85)>>4)&0x01 )
    00105 E805      LDI	R16,0x85
    00106 DFBD      RCALL	_Read1302
    00107 2F80      MOV	R24,R16
    00108 9582      SWAP	R24
    00109 708F      ANDI	R24,0xF
    0010A 7081      ANDI	R24,1
    0010B F0B9      BEQ	0x0123
(0122) 	{
(0123) 	 lcd_write_char(0x00,1,0x30|((Read1302(0x85)>>4)&0x01));
    0010C E805      LDI	R16,0x85
    0010D DFB6      RCALL	_Read1302
    0010E 2EA0      MOV	R10,R16
    0010F 2D8A      MOV	R24,R10
    00110 9582      SWAP	R24
    00111 708F      ANDI	R24,0xF
    00112 7081      ANDI	R24,1
    00113 6380      ORI	R24,0x30
    00114 8388      ST	Y,R24
    00115 E021      LDI	R18,1
    00116 2700      CLR	R16
    00117 940E 03D6 CALL	_lcd_write_char
(0124) 	 lcd_write_char_con(1,0x30|(Read1302(0x85)&0x0F));
    00119 E805      LDI	R16,0x85
    0011A DFA9      RCALL	_Read1302
    0011B 2F40      MOV	R20,R16
    0011C 2F24      MOV	R18,R20
    0011D 702F      ANDI	R18,0xF
    0011E 6320      ORI	R18,0x30
    0011F E001      LDI	R16,1
    00120 940E 039E CALL	_lcd_write_char_con
(0125) 	}else{
    00122 C00F      RJMP	0x0132
(0126) 	 lcd_write_char(0x00,1,' ' );
    00123 E280      LDI	R24,0x20
    00124 8388      ST	Y,R24
    00125 E021      LDI	R18,1
    00126 2700      CLR	R16
    00127 940E 03D6 CALL	_lcd_write_char
(0127) 	 lcd_write_char_con(1,0x30|(Read1302(0x85)&0x0F));
    00129 E805      LDI	R16,0x85
    0012A DF99      RCALL	_Read1302
    0012B 2F40      MOV	R20,R16
    0012C 2F24      MOV	R18,R20
    0012D 702F      ANDI	R18,0xF
    0012E 6320      ORI	R18,0x30
    0012F E001      LDI	R16,1
    00130 940E 039E CALL	_lcd_write_char_con
(0128) 	}
(0129) 
(0130) 	   if(((Read1302(0x85))&0x20)){
    00132 E805      LDI	R16,0x85
    00133 DF90      RCALL	_Read1302
    00134 2EA0      MOV	R10,R16
    00135 FF05      SBRS	R16,5
    00136 C00B      RJMP	0x0142
(0131) 	      lcd_write_char(0x05,1, 'P');
    00137 E580      LDI	R24,0x50
    00138 8388      ST	Y,R24
    00139 E021      LDI	R18,1
    0013A E005      LDI	R16,5
    0013B 940E 03D6 CALL	_lcd_write_char
(0132) 	     lcd_write_char_con(1, 'M');
    0013D E42D      LDI	R18,0x4D
    0013E E001      LDI	R16,1
    0013F 940E 039E CALL	_lcd_write_char_con
(0133) 	   }else{
    00141 C021      RJMP	0x0163
(0134) 	     lcd_write_char(0x05,1, 'A');
    00142 E481      LDI	R24,0x41
    00143 8388      ST	Y,R24
    00144 E021      LDI	R18,1
    00145 E005      LDI	R16,5
    00146 940E 03D6 CALL	_lcd_write_char
(0135) 	     lcd_write_char_con(1, 'M');
    00148 E42D      LDI	R18,0x4D
    00149 E001      LDI	R16,1
    0014A 940E 039E CALL	_lcd_write_char_con
(0136) 	    }
(0137) 	}else{
    0014C C016      RJMP	0x0163
(0138) 	 lcd_write_char(0x00,1, 0x30|((Read1302(0x85)>>4)&0x03));
    0014D E805      LDI	R16,0x85
    0014E DF75      RCALL	_Read1302
    0014F 2EA0      MOV	R10,R16
    00150 2D8A      MOV	R24,R10
    00151 9582      SWAP	R24
    00152 708F      ANDI	R24,0xF
    00153 7083      ANDI	R24,3
    00154 6380      ORI	R24,0x30
    00155 8388      ST	Y,R24
    00156 E021      LDI	R18,1
    00157 2700      CLR	R16
    00158 940E 03D6 CALL	_lcd_write_char
(0139) 	 lcd_write_char_con(1,0x30|(Read1302(0x85)&0x0F)); 
    0015A E805      LDI	R16,0x85
    0015B DF68      RCALL	_Read1302
    0015C 2F40      MOV	R20,R16
    0015D 2F24      MOV	R18,R20
    0015E 702F      ANDI	R18,0xF
    0015F 6320      ORI	R18,0x30
    00160 E001      LDI	R16,1
    00161 940E 039E CALL	_lcd_write_char_con
(0140) 	}
(0141) 	
(0142) 	lcd_write_char(0x01,1,':');
    00163 E38A      LDI	R24,0x3A
    00164 8388      ST	Y,R24
    00165 E021      LDI	R18,1
    00166 E001      LDI	R16,1
    00167 940E 03D6 CALL	_lcd_write_char
(0143) 	
(0144) 	lcd_write_char_con(1, 0x30|Read1302(0x83)>>4);
    00169 E803      LDI	R16,0x83
    0016A DF59      RCALL	_Read1302
    0016B 2EA0      MOV	R10,R16
    0016C 2D2A      MOV	R18,R10
    0016D 9522      SWAP	R18
    0016E 702F      ANDI	R18,0xF
    0016F 6320      ORI	R18,0x30
    00170 E001      LDI	R16,1
    00171 940E 039E CALL	_lcd_write_char_con
(0145) 	lcd_write_char_con(1,0x30|(Read1302(0x83)&0x0F));
    00173 E803      LDI	R16,0x83
    00174 DF4F      RCALL	_Read1302
    00175 2F40      MOV	R20,R16
    00176 2F24      MOV	R18,R20
    00177 702F      ANDI	R18,0xF
    00178 6320      ORI	R18,0x30
    00179 E001      LDI	R16,1
    0017A 940E 039E CALL	_lcd_write_char_con
(0146) 
(0147) 	lcd_write_char_con(1,':');
    0017C E32A      LDI	R18,0x3A
    0017D E001      LDI	R16,1
    0017E 940E 039E CALL	_lcd_write_char_con
(0148) 	
(0149) 	 lcd_write_char_con(1, 0x30|(Read1302(0x81)>>4));
    00180 E801      LDI	R16,0x81
    00181 DF42      RCALL	_Read1302
    00182 2EA0      MOV	R10,R16
    00183 2D2A      MOV	R18,R10
    00184 9522      SWAP	R18
    00185 702F      ANDI	R18,0xF
    00186 6320      ORI	R18,0x30
    00187 E001      LDI	R16,1
    00188 940E 039E CALL	_lcd_write_char_con
(0150) 	lcd_write_char_con(1,0x30|(Read1302(0x81)&0x0F));
    0018A E801      LDI	R16,0x81
    0018B DF38      RCALL	_Read1302
    0018C 2F40      MOV	R20,R16
    0018D 2F24      MOV	R18,R20
    0018E 702F      ANDI	R18,0xF
    0018F 6320      ORI	R18,0x30
    00190 E001      LDI	R16,1
    00191 940E 039E CALL	_lcd_write_char_con
    00193 9621      ADIW	R28,1
    00194 9149      LD	R20,Y+
    00195 90A9      LD	R10,Y+
    00196 9508      RET
FILE: E:\ICCDemo\Temp_Control\temp_control\key.c
(0001) #include<iom128v.h>
(0002) #include "delay.h"
(0003) #include "lcd.h"
(0004) void KeyInit(void){
_KeyInit:
    00197 9508      RET
_KeyScan:
    00198 934A      ST	-Y,R20
    00199 935A      ST	-Y,R21
(0005)    
(0006) 
(0007) }
(0008) uchar KeyScan(void){
(0009)   //初始化端口
(0010)    DDRC=0xE0;
    0019A EE80      LDI	R24,0xE0
    0019B BB84      OUT	0x14,R24
(0011)    DDRG|=0x10;
    0019C 9180 0064 LDS	R24,0x64
    0019E 6180      ORI	R24,0x10
    0019F 9380 0064 STS	0x64,R24
(0012)    
(0013)    //第一次扫描
(0014)    PORTC=0xDF;
    001A1 ED8F      LDI	R24,0xDF
    001A2 BB85      OUT	0x15,R24
(0015)    PORTG|=0x10;
    001A3 9180 0065 LDS	R24,0x65
    001A5 6180      ORI	R24,0x10
    001A6 9380 0065 STS	0x65,R24
(0016)    delay_us(1);
    001A8 E001      LDI	R16,1
    001A9 E010      LDI	R17,0
    001AA 940E 0073 CALL	_delay_us
(0017)    switch(PINC)
    001AC B343      IN	R20,0x13
    001AD 2755      CLR	R21
    001AE 3C4F      CPI	R20,0xCF
    001AF E0E0      LDI	R30,0
    001B0 075E      CPC	R21,R30
    001B1 F0E9      BEQ	0x01CF
    001B2 3C4F      CPI	R20,0xCF
    001B3 E0E0      LDI	R30,0
    001B4 075E      CPC	R21,R30
    001B5 F0DC      BLT	0x01D1
    001B6 3D47      CPI	R20,0xD7
    001B7 E0E0      LDI	R30,0
    001B8 075E      CPC	R21,R30
    001B9 F099      BEQ	0x01CD
    001BA 3D4B      CPI	R20,0xDB
    001BB E0E0      LDI	R30,0
    001BC 075E      CPC	R21,R30
    001BD F069      BEQ	0x01CB
    001BE 3D4D      CPI	R20,0xDD
    001BF E0E0      LDI	R30,0
    001C0 075E      CPC	R21,R30
    001C1 F039      BEQ	0x01C9
    001C2 3D4E      CPI	R20,0xDE
    001C3 E0E0      LDI	R30,0
    001C4 075E      CPC	R21,R30
    001C5 F009      BEQ	0x01C7
    001C6 C00A      RJMP	0x01D1
(0018)    {
(0019)    		case 0xDE:return  'e';//'esc';
    001C7 E605      LDI	R16,0x65
    001C8 C099      RJMP	0x0262
(0020) 		case 0xdd:return  'a';//'alm';
    001C9 E601      LDI	R16,0x61
    001CA C097      RJMP	0x0262
(0021) 		case 0xdb:return  'd';//'down';  
    001CB E604      LDI	R16,0x64
    001CC C095      RJMP	0x0262
(0022) 		case 0xd7:return  'u';//'up';
    001CD E705      LDI	R16,0x75
    001CE C093      RJMP	0x0262
(0023) 		case 0xcf:return  'l';//'left';
    001CF E60C      LDI	R16,0x6C
    001D0 C091      RJMP	0x0262
(0024) 		default:break;	   
(0025)    } 
(0026)     //第二次扫描
(0027)    PORTC=0xBF;
    001D1 EB8F      LDI	R24,0xBF
    001D2 BB85      OUT	0x15,R24
(0028)    PORTG|=0x10;
    001D3 9180 0065 LDS	R24,0x65
    001D5 6180      ORI	R24,0x10
    001D6 9380 0065 STS	0x65,R24
(0029)    delay_us(1);
    001D8 E001      LDI	R16,1
    001D9 E010      LDI	R17,0
    001DA 940E 0073 CALL	_delay_us
(0030)    switch(PINC)
    001DC B343      IN	R20,0x13
    001DD 2755      CLR	R21
    001DE 3A4F      CPI	R20,0xAF
    001DF E0E0      LDI	R30,0
    001E0 075E      CPC	R21,R30
    001E1 F0E9      BEQ	0x01FF
    001E2 3A4F      CPI	R20,0xAF
    001E3 E0E0      LDI	R30,0
    001E4 075E      CPC	R21,R30
    001E5 F0DC      BLT	0x0201
    001E6 3B47      CPI	R20,0xB7
    001E7 E0E0      LDI	R30,0
    001E8 075E      CPC	R21,R30
    001E9 F099      BEQ	0x01FD
    001EA 3B4B      CPI	R20,0xBB
    001EB E0E0      LDI	R30,0
    001EC 075E      CPC	R21,R30
    001ED F069      BEQ	0x01FB
    001EE 3B4D      CPI	R20,0xBD
    001EF E0E0      LDI	R30,0
    001F0 075E      CPC	R21,R30
    001F1 F039      BEQ	0x01F9
    001F2 3B4E      CPI	R20,0xBE
    001F3 E0E0      LDI	R30,0
    001F4 075E      CPC	R21,R30
    001F5 F009      BEQ	0x01F7
    001F6 C00A      RJMP	0x0201
(0031)    {
(0032)    		case 0xbE:return 's';//'set';
    001F7 E703      LDI	R16,0x73
    001F8 C069      RJMP	0x0262
(0033) 		case 0xbd:return 'r';//'right';
    001F9 E702      LDI	R16,0x72
    001FA C067      RJMP	0x0262
(0034) 		case 0xbb:return 't';//'ent';  
    001FB E704      LDI	R16,0x74
    001FC C065      RJMP	0x0262
(0035) 		case 0xb7:return 'c';//'clr';
    001FD E603      LDI	R16,0x63
    001FE C063      RJMP	0x0262
(0036) 		case 0xaf:return '+';//'+/-';
    001FF E20B      LDI	R16,0x2B
    00200 C061      RJMP	0x0262
(0037) 		default:break;	   
(0038)    } 
(0039)     //第三次扫描
(0040)    PORTC=0x7F;
    00201 E78F      LDI	R24,0x7F
    00202 BB85      OUT	0x15,R24
(0041)    PORTG|=0x10;
    00203 9180 0065 LDS	R24,0x65
    00205 6180      ORI	R24,0x10
    00206 9380 0065 STS	0x65,R24
(0042)    delay_us(1);
    00208 E001      LDI	R16,1
    00209 E010      LDI	R17,0
    0020A 940E 0073 CALL	_delay_us
(0043)    switch(PINC)
    0020C B343      IN	R20,0x13
    0020D 2755      CLR	R21
    0020E 364F      CPI	R20,0x6F
    0020F E0E0      LDI	R30,0
    00210 075E      CPC	R21,R30
    00211 F0E9      BEQ	0x022F
    00212 364F      CPI	R20,0x6F
    00213 E0E0      LDI	R30,0
    00214 075E      CPC	R21,R30
    00215 F0DC      BLT	0x0231
    00216 3747      CPI	R20,0x77
    00217 E0E0      LDI	R30,0
    00218 075E      CPC	R21,R30
    00219 F099      BEQ	0x022D
    0021A 374B      CPI	R20,0x7B
    0021B E0E0      LDI	R30,0
    0021C 075E      CPC	R21,R30
    0021D F069      BEQ	0x022B
    0021E 374D      CPI	R20,0x7D
    0021F E0E0      LDI	R30,0
    00220 075E      CPC	R21,R30
    00221 F039      BEQ	0x0229
    00222 374E      CPI	R20,0x7E
    00223 E0E0      LDI	R30,0
    00224 075E      CPC	R21,R30
    00225 F009      BEQ	0x0227
    00226 C00A      RJMP	0x0231
(0044)    {
(0045)    		case 0x7E:return '0';
    00227 E300      LDI	R16,0x30
    00228 C039      RJMP	0x0262
(0046) 		case 0x7d:return '3';
    00229 E303      LDI	R16,0x33
    0022A C037      RJMP	0x0262
(0047) 		case 0x7b:return '2';  
    0022B E302      LDI	R16,0x32
    0022C C035      RJMP	0x0262
(0048) 		case 0x77:return '1';
    0022D E301      LDI	R16,0x31
    0022E C033      RJMP	0x0262
(0049) 		case 0x6f:return '6';
    0022F E306      LDI	R16,0x36
    00230 C031      RJMP	0x0262
(0050) 		default:break;	   
(0051)    } 
(0052)       //第四次扫描
(0053)    PORTC=0xFF;
    00231 EF8F      LDI	R24,0xFF
    00232 BB85      OUT	0x15,R24
(0054)    PORTG&=0x0F;
    00233 9180 0065 LDS	R24,0x65
    00235 708F      ANDI	R24,0xF
    00236 9380 0065 STS	0x65,R24
(0055)    delay_us(1);
    00238 E001      LDI	R16,1
    00239 E010      LDI	R17,0
    0023A 940E 0073 CALL	_delay_us
(0056)    switch(PINC)
    0023C B343      IN	R20,0x13
    0023D 2755      CLR	R21
    0023E 3E4F      CPI	R20,0xEF
    0023F E0E0      LDI	R30,0
    00240 075E      CPC	R21,R30
    00241 F0E9      BEQ	0x025F
    00242 3E4F      CPI	R20,0xEF
    00243 E0E0      LDI	R30,0
    00244 075E      CPC	R21,R30
    00245 F0DC      BLT	0x0261
    00246 3F47      CPI	R20,0xF7
    00247 E0E0      LDI	R30,0
    00248 075E      CPC	R21,R30
    00249 F099      BEQ	0x025D
    0024A 3F4B      CPI	R20,0xFB
    0024B E0E0      LDI	R30,0
    0024C 075E      CPC	R21,R30
    0024D F069      BEQ	0x025B
    0024E 3F4D      CPI	R20,0xFD
    0024F E0E0      LDI	R30,0
    00250 075E      CPC	R21,R30
    00251 F039      BEQ	0x0259
    00252 3F4E      CPI	R20,0xFE
    00253 E0E0      LDI	R30,0
    00254 075E      CPC	R21,R30
    00255 F009      BEQ	0x0257
    00256 C00A      RJMP	0x0261
(0057)    {
(0058)    		case 0xFE:return '7';
    00257 E307      LDI	R16,0x37
    00258 C009      RJMP	0x0262
(0059) 		case 0xFd:return '8';
    00259 E308      LDI	R16,0x38
    0025A C007      RJMP	0x0262
(0060) 		case 0xFb:return '9';  
    0025B E309      LDI	R16,0x39
    0025C C005      RJMP	0x0262
(0061) 		case 0xF7:return '4';
    0025D E304      LDI	R16,0x34
    0025E C003      RJMP	0x0262
(0062) 		case 0xEf:return '5';
    0025F E305      LDI	R16,0x35
    00260 C001      RJMP	0x0262
(0063) 		default:break;	   
(0064)    }
(0065)  return 'n';
    00261 E60E      LDI	R16,0x6E
    00262 9159      LD	R21,Y+
    00263 9149      LD	R20,Y+
    00264 9508      RET
_KeyScan_once:
  keyValue2            --> R10
  keyValue             --> R20
    00265 92AA      ST	-Y,R10
    00266 934A      ST	-Y,R20
    00267 9721      SBIW	R28,1
(0066)    
(0067) }
(0068) //********************************
(0069) //		加上延时抖动的读取，一次读取一个
(0070) //********************************
(0071) uchar KeyScan_once(void){
(0072) 	  uchar keyValue,keyValue2;
(0073) 	  keyValue=KeyScan();
    00268 DF2F      RCALL	_KeyScan
    00269 2F40      MOV	R20,R16
(0074) 	  delay_ms(2);
    0026A E002      LDI	R16,2
    0026B E010      LDI	R17,0
    0026C 940E 007D CALL	_delay_ms
(0075) 	  keyValue2=KeyScan();
    0026E DF29      RCALL	_KeyScan
    0026F 2EA0      MOV	R10,R16
(0076) 	if(keyValue==keyValue2){
    00270 1740      CP	R20,R16
    00271 F4F9      BNE	0x0291
(0077) 	   if(keyValue=='r'){
    00272 3742      CPI	R20,0x72
    00273 F469      BNE	0x0281
(0078) 	   Set_White_off(5,1,6); 
    00274 E086      LDI	R24,6
    00275 8388      ST	Y,R24
    00276 E021      LDI	R18,1
    00277 E005      LDI	R16,5
    00278 940E 05BE CALL	_Set_White_off
(0079) 	    Set_White(1,1,2); 
    0027A E082      LDI	R24,2
    0027B 8388      ST	Y,R24
    0027C E021      LDI	R18,1
    0027D E001      LDI	R16,1
    0027E 940E 061C CALL	_Set_White
(0080) 	   }else if(keyValue=='l'){
    00280 C00E      RJMP	0x028F
    00281 364C      CPI	R20,0x6C
    00282 F461      BNE	0x028F
(0081) 	   Set_White_off(1,1,2); 
    00283 E082      LDI	R24,2
    00284 8388      ST	Y,R24
    00285 E021      LDI	R18,1
    00286 E001      LDI	R16,1
    00287 940E 05BE CALL	_Set_White_off
(0082) 	   		Set_White(5,1,6);  
    00289 E086      LDI	R24,6
    0028A 8388      ST	Y,R24
    0028B E021      LDI	R18,1
    0028C E005      LDI	R16,5
    0028D 940E 061C CALL	_Set_White
(0083) 	   }
(0084) 	 return keyValue;
    0028F 2F04      MOV	R16,R20
    00290 C001      RJMP	0x0292
(0085) 	}
(0086) 	return 'n';
    00291 E60E      LDI	R16,0x6E
    00292 9621      ADIW	R28,1
    00293 9149      LD	R20,Y+
    00294 90A9      LD	R10,Y+
    00295 9508      RET
_lcd_bz_1:
  result               --> R20
    00296 934A      ST	-Y,R20
    00297 935A      ST	-Y,R21
FILE: E:\ICCDemo\Temp_Control\temp_control\lcd.c
(0001) #include<iom128v.h>
(0002) #include "lcd.h"
(0003) #include "delay.h" 
(0004) #define rs_l PORTG&=~(1<<PG1)
(0005) #define rs_h PORTG|=1<<PG1
(0006) #define rw_l PORTG&=~(1<<PG0)
(0007) #define rw_h PORTG|=1<<PG0
(0008) #define ep1_l PORTG&=~(1<<PG3)
(0009) #define ep1_h PORTG|=1<<PG3
(0010) #define ep2_l PORTF&=~(1<<PF0)
(0011) #define ep2_h PORTF|=1<<PF0
(0012) //***********************************
(0013) //上半屏幕
(0014) //**********************************
(0015) /*
(0016)  读忙程序。命令后，读入BF
(0017) */
(0018) uint lcd_bz_1(void){
(0019) 	uint result;
(0020) 	DDRA=0x00;
    00298 2422      CLR	R2
    00299 BA2A      OUT	0x1A,R2
(0021) 	rs_l;
    0029A 9180 0065 LDS	R24,0x65
    0029C 7F8D      ANDI	R24,0xFD
    0029D 9380 0065 STS	0x65,R24
(0022) 	rw_h;
    0029F 9180 0065 LDS	R24,0x65
    002A1 6081      ORI	R24,1
    002A2 9380 0065 STS	0x65,R24
(0023) 	ep1_h;
    002A4 9180 0065 LDS	R24,0x65
    002A6 6088      ORI	R24,0x8
    002A7 9380 0065 STS	0x65,R24
(0024) 	delay_ms(1);
    002A9 E001      LDI	R16,1
    002AA E010      LDI	R17,0
    002AB 940E 007D CALL	_delay_ms
(0025) 	result=PINA&(1<<PINA7);
    002AD B349      IN	R20,0x19
    002AE 2755      CLR	R21
    002AF 7840      ANDI	R20,0x80
    002B0 7050      ANDI	R21,0
(0026) 	DDRA=0xFF;
    002B1 EF8F      LDI	R24,0xFF
    002B2 BB8A      OUT	0x1A,R24
(0027) 	ep1_l;
    002B3 9180 0065 LDS	R24,0x65
    002B5 7F87      ANDI	R24,0xF7
    002B6 9380 0065 STS	0x65,R24
(0028) 	return result;
    002B8 018A      MOVW	R16,R20
    002B9 9159      LD	R21,Y+
    002BA 9149      LD	R20,Y+
    002BB 9508      RET
_lcd_wcmd_1:
  cmd                  --> R10
    002BC 92AA      ST	-Y,R10
    002BD 2EA0      MOV	R10,R16
(0029) }
(0030) void lcd_wcmd_1(uchar cmd){
(0031) 	 while(lcd_bz_1());
    002BE DFD7      RCALL	_lcd_bz_1
    002BF 3000      CPI	R16,0
    002C0 0701      CPC	R16,R17
    002C1 F7E1      BNE	0x02BE
(0032) 	 rs_l;
    002C2 9180 0065 LDS	R24,0x65
    002C4 7F8D      ANDI	R24,0xFD
    002C5 9380 0065 STS	0x65,R24
(0033) 	 rw_l;
    002C7 9180 0065 LDS	R24,0x65
    002C9 7F8E      ANDI	R24,0xFE
    002CA 9380 0065 STS	0x65,R24
(0034) 	 ep1_l;
    002CC 9180 0065 LDS	R24,0x65
    002CE 7F87      ANDI	R24,0xF7
    002CF 9380 0065 STS	0x65,R24
(0035) 	 delay_ms(1);
    002D1 E001      LDI	R16,1
    002D2 E010      LDI	R17,0
    002D3 940E 007D CALL	_delay_ms
(0036) 	 PORTA=cmd;
    002D5 BAAB      OUT	0x1B,R10
(0037) 	 delay_ms(2);
    002D6 E002      LDI	R16,2
    002D7 E010      LDI	R17,0
    002D8 940E 007D CALL	_delay_ms
(0038) 	 ep1_h;
    002DA 9180 0065 LDS	R24,0x65
    002DC 6088      ORI	R24,0x8
    002DD 9380 0065 STS	0x65,R24
(0039) 	 delay_ms(1);
    002DF E001      LDI	R16,1
    002E0 E010      LDI	R17,0
    002E1 940E 007D CALL	_delay_ms
(0040) 	 ep1_l;
    002E3 9180 0065 LDS	R24,0x65
    002E5 7F87      ANDI	R24,0xF7
    002E6 9380 0065 STS	0x65,R24
(0041) 	 return;
    002E8 90A9      LD	R10,Y+
    002E9 9508      RET
_lcd_wdat_1:
  dat                  --> R10
    002EA 92AA      ST	-Y,R10
    002EB 2EA0      MOV	R10,R16
(0042) }
(0043) /*
(0044) 写输出数据,char
(0045) */
(0046) void lcd_wdat_1(uchar dat){
(0047) 	 while(lcd_bz_1());
    002EC DFA9      RCALL	_lcd_bz_1
    002ED 3000      CPI	R16,0
    002EE 0701      CPC	R16,R17
    002EF F7E1      BNE	0x02EC
(0048) 	 rs_h;
    002F0 9180 0065 LDS	R24,0x65
    002F2 6082      ORI	R24,2
    002F3 9380 0065 STS	0x65,R24
(0049) 	 rw_l;
    002F5 9180 0065 LDS	R24,0x65
    002F7 7F8E      ANDI	R24,0xFE
    002F8 9380 0065 STS	0x65,R24
(0050) 	 ep1_l;
    002FA 9180 0065 LDS	R24,0x65
    002FC 7F87      ANDI	R24,0xF7
    002FD 9380 0065 STS	0x65,R24
(0051) 	 PORTA=dat;
    002FF BAAB      OUT	0x1B,R10
(0052) 	 delay_ms(2);
    00300 E002      LDI	R16,2
    00301 E010      LDI	R17,0
    00302 940E 007D CALL	_delay_ms
(0053) 	 ep1_h;
    00304 9180 0065 LDS	R24,0x65
    00306 6088      ORI	R24,0x8
    00307 9380 0065 STS	0x65,R24
(0054) 	 delay_ms(2);
    00309 E002      LDI	R16,2
    0030A E010      LDI	R17,0
    0030B 940E 007D CALL	_delay_ms
(0055) 	 ep1_l;
    0030D 9180 0065 LDS	R24,0x65
    0030F 7F87      ANDI	R24,0xF7
    00310 9380 0065 STS	0x65,R24
    00312 90A9      LD	R10,Y+
    00313 9508      RET
(0056) }
(0057) 
(0058) /*清显示*/
(0059) void lcd_clear_1(void) 
(0060) {
(0061) 	lcd_wcmd_1(0x01);
_lcd_clear_1:
    00314 E001      LDI	R16,1
    00315 DFA6      RCALL	_lcd_wcmd_1
(0062) 	delay_ms(5);
    00316 E005      LDI	R16,5
    00317 E010      LDI	R17,0
    00318 940C 007D JMP	_delay_ms
_lcd_bz_2:
  result               --> R20
    0031A 934A      ST	-Y,R20
    0031B 935A      ST	-Y,R21
(0063) }
(0064) //***********************************
(0065) //    下半屏幕
(0066) //***********************************
(0067) uint lcd_bz_2(void){
(0068) 	uint result;
(0069) 	DDRA=0x00;
    0031C 2422      CLR	R2
    0031D BA2A      OUT	0x1A,R2
(0070) 	rs_l;
    0031E 9180 0065 LDS	R24,0x65
    00320 7F8D      ANDI	R24,0xFD
    00321 9380 0065 STS	0x65,R24
(0071) 	rw_h;
    00323 9180 0065 LDS	R24,0x65
    00325 6081      ORI	R24,1
    00326 9380 0065 STS	0x65,R24
(0072) 	ep2_h;
    00328 9180 0062 LDS	R24,0x62
    0032A 6081      ORI	R24,1
    0032B 9380 0062 STS	0x62,R24
(0073) 	delay_ms(1);
    0032D E001      LDI	R16,1
    0032E E010      LDI	R17,0
    0032F 940E 007D CALL	_delay_ms
(0074) 	result=PINA&(1<<PINA7);
    00331 B349      IN	R20,0x19
    00332 2755      CLR	R21
    00333 7840      ANDI	R20,0x80
    00334 7050      ANDI	R21,0
(0075) 	DDRA=0xFF;
    00335 EF8F      LDI	R24,0xFF
    00336 BB8A      OUT	0x1A,R24
(0076) 	ep2_l;
    00337 9180 0062 LDS	R24,0x62
    00339 7F8E      ANDI	R24,0xFE
    0033A 9380 0062 STS	0x62,R24
(0077) 	return result;
    0033C 018A      MOVW	R16,R20
    0033D 9159      LD	R21,Y+
    0033E 9149      LD	R20,Y+
    0033F 9508      RET
_lcd_wcmd_2:
  cmd                  --> R10
    00340 92AA      ST	-Y,R10
    00341 2EA0      MOV	R10,R16
(0078) }
(0079) void lcd_wcmd_2(uchar cmd){
(0080) 	 while(lcd_bz_2());
    00342 DFD7      RCALL	_lcd_bz_2
    00343 3000      CPI	R16,0
    00344 0701      CPC	R16,R17
    00345 F7E1      BNE	0x0342
(0081) 	 rs_l;
    00346 9180 0065 LDS	R24,0x65
    00348 7F8D      ANDI	R24,0xFD
    00349 9380 0065 STS	0x65,R24
(0082) 	 rw_l;
    0034B 9180 0065 LDS	R24,0x65
    0034D 7F8E      ANDI	R24,0xFE
    0034E 9380 0065 STS	0x65,R24
(0083) 	 ep2_l;
    00350 9180 0062 LDS	R24,0x62
    00352 7F8E      ANDI	R24,0xFE
    00353 9380 0062 STS	0x62,R24
(0084) 	 delay_ms(1);
    00355 E001      LDI	R16,1
    00356 E010      LDI	R17,0
    00357 940E 007D CALL	_delay_ms
(0085) 	 PORTA=cmd;
    00359 BAAB      OUT	0x1B,R10
(0086) 	 delay_ms(2);
    0035A E002      LDI	R16,2
    0035B E010      LDI	R17,0
    0035C 940E 007D CALL	_delay_ms
(0087) 	 ep2_h;
    0035E 9180 0062 LDS	R24,0x62
    00360 6081      ORI	R24,1
    00361 9380 0062 STS	0x62,R24
(0088) 	 delay_ms(1);
    00363 E001      LDI	R16,1
    00364 E010      LDI	R17,0
    00365 940E 007D CALL	_delay_ms
(0089) 	 ep2_l;
    00367 9180 0062 LDS	R24,0x62
    00369 7F8E      ANDI	R24,0xFE
    0036A 9380 0062 STS	0x62,R24
    0036C 90A9      LD	R10,Y+
    0036D 9508      RET
_lcd_wdat_2:
  dat                  --> R10
    0036E 92AA      ST	-Y,R10
    0036F 2EA0      MOV	R10,R16
(0090) }
(0091) //  写输出数据,char
(0092) void lcd_wdat_2(uchar dat){
(0093) 	 while(lcd_bz_2());
    00370 DFA9      RCALL	_lcd_bz_2
    00371 3000      CPI	R16,0
    00372 0701      CPC	R16,R17
    00373 F7E1      BNE	0x0370
(0094) 	 rs_h;
    00374 9180 0065 LDS	R24,0x65
    00376 6082      ORI	R24,2
    00377 9380 0065 STS	0x65,R24
(0095) 	 rw_l;
    00379 9180 0065 LDS	R24,0x65
    0037B 7F8E      ANDI	R24,0xFE
    0037C 9380 0065 STS	0x65,R24
(0096) 	 ep2_l;
    0037E 9180 0062 LDS	R24,0x62
    00380 7F8E      ANDI	R24,0xFE
    00381 9380 0062 STS	0x62,R24
(0097) 	 PORTA=dat;
    00383 BAAB      OUT	0x1B,R10
(0098) 	 delay_ms(2);
    00384 E002      LDI	R16,2
    00385 E010      LDI	R17,0
    00386 940E 007D CALL	_delay_ms
(0099) 	 ep2_h;
    00388 9180 0062 LDS	R24,0x62
    0038A 6081      ORI	R24,1
    0038B 9380 0062 STS	0x62,R24
(0100) 	 delay_ms(2);
    0038D E002      LDI	R16,2
    0038E E010      LDI	R17,0
    0038F 940E 007D CALL	_delay_ms
(0101) 	 ep2_l;
    00391 9180 0062 LDS	R24,0x62
    00393 7F8E      ANDI	R24,0xFE
    00394 9380 0062 STS	0x62,R24
    00396 90A9      LD	R10,Y+
    00397 9508      RET
(0102) }
(0103) /*清显示*/
(0104) void lcd_clear_2(void) 
(0105) {
(0106) 	
(0107) 	lcd_wcmd_2(0x01);
_lcd_clear_2:
    00398 E001      LDI	R16,1
    00399 DFA6      RCALL	_lcd_wcmd_2
(0108) 
(0109) 	delay_ms(5);
    0039A E005      LDI	R16,5
    0039B E010      LDI	R17,0
    0039C 940C 007D JMP	_delay_ms
_lcd_write_char_con:
  data                 --> R10
  y                    --> R20
    0039E 92AA      ST	-Y,R10
    0039F 934A      ST	-Y,R20
    003A0 2EA2      MOV	R10,R18
    003A1 2F40      MOV	R20,R16
(0110) 
(0111) }
(0112) 
(0113) //*************************************************
(0114) //					写字符
(0115) //***************************************************
(0116) /*
(0117)   附带y。调用 lcd_wdat（）方法。传入时转换为char。直接连续写入使用
(0118) */
(0119) void lcd_write_char_con(unsigned char y,unsigned char data) 
(0120) {
(0121) 	
(0122)     if (y == 0) 
    003A2 2344      TST	R20
    003A3 F419      BNE	0x03A7
(0123)     {
(0124)     	
(0125) 		 lcd_wdat_1( data);
    003A4 2D0A      MOV	R16,R10
    003A5 DF44      RCALL	_lcd_wdat_1
(0126)     }
    003A6 C00E      RJMP	0x03B5
(0127)     else  if(y==1)
    003A7 3041      CPI	R20,1
    003A8 F419      BNE	0x03AC
(0128)     {
(0129)     	
(0130) 		 lcd_wdat_1( data);
    003A9 2D0A      MOV	R16,R10
    003AA DF3F      RCALL	_lcd_wdat_1
(0131)     }else  if(y==2)
    003AB C009      RJMP	0x03B5
    003AC 3042      CPI	R20,2
    003AD F419      BNE	0x03B1
(0132)     {
(0133)     	
(0134) 		 lcd_wdat_2( data);
    003AE 2D0A      MOV	R16,R10
    003AF DFBE      RCALL	_lcd_wdat_2
(0135)     }else  if(y==3)
    003B0 C004      RJMP	0x03B5
    003B1 3043      CPI	R20,3
    003B2 F411      BNE	0x03B5
(0136)     {
(0137)     	
(0138) 		 lcd_wdat_2( data);
    003B3 2D0A      MOV	R16,R10
    003B4 DFB9      RCALL	_lcd_wdat_2
(0139)     }
(0140)    return; 
    003B5 9149      LD	R20,Y+
    003B6 90A9      LD	R10,Y+
    003B7 9508      RET
_lcd_write_pos:
  y                    --> R22
  x                    --> R20
    003B8 934A      ST	-Y,R20
    003B9 936A      ST	-Y,R22
    003BA 2F62      MOV	R22,R18
    003BB 2F40      MOV	R20,R16
(0141) }
(0142) /*
(0143)   附带x,y。写光标位置
(0144) */
(0145) void lcd_write_pos(unsigned char x,unsigned char y) 
(0146) {
(0147) 	
(0148)     if (y == 0) 
    003BC 2366      TST	R22
    003BD F421      BNE	0x03C2
(0149)     {
(0150)     	lcd_wcmd_1(0x80 + x);
    003BE 2F04      MOV	R16,R20
    003BF 5800      SUBI	R16,0x80
    003C0 DEFB      RCALL	_lcd_wcmd_1
(0151)     }
    003C1 C011      RJMP	0x03D3
(0152)     else  if(y==1)
    003C2 3061      CPI	R22,1
    003C3 F421      BNE	0x03C8
(0153)     {
(0154)     	lcd_wcmd_1(0x90 + x);
    003C4 2F04      MOV	R16,R20
    003C5 5700      SUBI	R16,0x70
    003C6 DEF5      RCALL	_lcd_wcmd_1
(0155)     }else  if(y==2)
    003C7 C00B      RJMP	0x03D3
    003C8 3062      CPI	R22,2
    003C9 F421      BNE	0x03CE
(0156)     {
(0157)     	lcd_wcmd_2(0x80 + x);
    003CA 2F04      MOV	R16,R20
    003CB 5800      SUBI	R16,0x80
    003CC DF73      RCALL	_lcd_wcmd_2
(0158)     }else  if(y==3)
    003CD C005      RJMP	0x03D3
    003CE 3063      CPI	R22,3
    003CF F419      BNE	0x03D3
(0159)     {
(0160)     	lcd_wcmd_2(0x90 + x);
    003D0 2F04      MOV	R16,R20
    003D1 5700      SUBI	R16,0x70
    003D2 DF6D      RCALL	_lcd_wcmd_2
(0161)     }
(0162)    return; 
    003D3 9169      LD	R22,Y+
    003D4 9149      LD	R20,Y+
    003D5 9508      RET
_lcd_write_char:
  data                 --> R10
  y                    --> R22
  x                    --> R20
    003D6 940E 0BBC CALL	push_xgsetF00C
    003D8 2F62      MOV	R22,R18
    003D9 2F40      MOV	R20,R16
    003DA 80AE      LDD	R10,Y+6
(0163) }
(0164) /*
(0165)   附带x,y。调用 lcd_wdat（）方法。传入时转换为char
(0166) */
(0167) void lcd_write_char(unsigned char x,unsigned char y,unsigned char data) 
(0168) {
(0169) 	
(0170)     if (y == 0) 
    003DB 2366      TST	R22
    003DC F431      BNE	0x03E3
(0171)     {
(0172)     	lcd_wcmd_1(0x80 + x);
    003DD 2F04      MOV	R16,R20
    003DE 5800      SUBI	R16,0x80
    003DF DEDC      RCALL	_lcd_wcmd_1
(0173) 		 lcd_wdat_1( data);
    003E0 2D0A      MOV	R16,R10
    003E1 DF08      RCALL	_lcd_wdat_1
(0174)     }
    003E2 C017      RJMP	0x03FA
(0175)     else  if(y==1)
    003E3 3061      CPI	R22,1
    003E4 F431      BNE	0x03EB
(0176)     {
(0177)     	lcd_wcmd_1(0x90 + x);
    003E5 2F04      MOV	R16,R20
    003E6 5700      SUBI	R16,0x70
    003E7 DED4      RCALL	_lcd_wcmd_1
(0178) 		 lcd_wdat_1( data);
    003E8 2D0A      MOV	R16,R10
    003E9 DF00      RCALL	_lcd_wdat_1
(0179)     }else  if(y==2)
    003EA C00F      RJMP	0x03FA
    003EB 3062      CPI	R22,2
    003EC F431      BNE	0x03F3
(0180)     {
(0181)     	lcd_wcmd_2(0x80 + x);
    003ED 2F04      MOV	R16,R20
    003EE 5800      SUBI	R16,0x80
    003EF DF50      RCALL	_lcd_wcmd_2
(0182) 		 lcd_wdat_2( data);
    003F0 2D0A      MOV	R16,R10
    003F1 DF7C      RCALL	_lcd_wdat_2
(0183)     }else  if(y==3)
    003F2 C007      RJMP	0x03FA
    003F3 3063      CPI	R22,3
    003F4 F429      BNE	0x03FA
(0184)     {
(0185)     	lcd_wcmd_2(0x90 + x);
    003F5 2F04      MOV	R16,R20
    003F6 5700      SUBI	R16,0x70
    003F7 DF48      RCALL	_lcd_wcmd_2
(0186) 		 lcd_wdat_2( data);
    003F8 2D0A      MOV	R16,R10
    003F9 DF74      RCALL	_lcd_wdat_2
(0187)     }
(0188)    return; 
    003FA 940C 0BC3 JMP	pop_xgsetF00C
_lcd_write_str:
  s                    --> R20
  y                    --> R10
  x                    --> R22
    003FC 940E 0BBC CALL	push_xgsetF00C
    003FE 2EA2      MOV	R10,R18
    003FF 2F60      MOV	R22,R16
    00400 814E      LDD	R20,Y+6
    00401 815F      LDD	R21,Y+7
(0189) }
(0190) /*
(0191)   附带x,y。调用 lcd_wdat（）方法，会通过指针遍历字符串。不太好，还是自己循环遍历
(0192) */
(0193) void lcd_write_str(unsigned char x,unsigned char y,unsigned char *s) 
(0194) {
(0195) 	
(0196)     if (y == 0) 
    00402 20AA      TST	R10
    00403 F471      BNE	0x0412
(0197)     {
(0198)     	lcd_wcmd_1(0x80 + x);
    00404 2F06      MOV	R16,R22
    00405 5800      SUBI	R16,0x80
    00406 DEB5      RCALL	_lcd_wcmd_1
    00407 C005      RJMP	0x040D
(0199) 		 while (*s) 
(0200)        {
(0201)     	lcd_wdat_1( *s);
    00408 01FA      MOVW	R30,R20
    00409 8100      LD	R16,Z
    0040A DEDF      RCALL	_lcd_wdat_1
(0202)     	s ++;
    0040B 5F4F      SUBI	R20,0xFF
    0040C 4F5F      SBCI	R21,0xFF
    0040D 01FA      MOVW	R30,R20
    0040E 8020      LD	R2,Z
    0040F 2022      TST	R2
    00410 F7B9      BNE	0x0408
(0203)         }
(0204)     }
    00411 C032      RJMP	0x0444
(0205)     else  if(y==1)
    00412 2D8A      MOV	R24,R10
    00413 3081      CPI	R24,1
    00414 F471      BNE	0x0423
(0206)     {
(0207)     	lcd_wcmd_1(0x90 + x);
    00415 2F06      MOV	R16,R22
    00416 5700      SUBI	R16,0x70
    00417 DEA4      RCALL	_lcd_wcmd_1
    00418 C005      RJMP	0x041E
(0208) 		 while (*s) 
(0209)         {
(0210)     	lcd_wdat_1( *s);
    00419 01FA      MOVW	R30,R20
    0041A 8100      LD	R16,Z
    0041B DECE      RCALL	_lcd_wdat_1
(0211)     	s ++;
    0041C 5F4F      SUBI	R20,0xFF
    0041D 4F5F      SBCI	R21,0xFF
    0041E 01FA      MOVW	R30,R20
    0041F 8020      LD	R2,Z
    00420 2022      TST	R2
    00421 F7B9      BNE	0x0419
(0212)        }
(0213)     }else  if(y==2)
    00422 C021      RJMP	0x0444
    00423 2D8A      MOV	R24,R10
    00424 3082      CPI	R24,2
    00425 F471      BNE	0x0434
(0214)     {
(0215)     	lcd_wcmd_2(0x80 + x);
    00426 2F06      MOV	R16,R22
    00427 5800      SUBI	R16,0x80
    00428 DF17      RCALL	_lcd_wcmd_2
    00429 C005      RJMP	0x042F
(0216) 		  while (*s) 
(0217)        {
(0218)     	lcd_wdat_2( *s);
    0042A 01FA      MOVW	R30,R20
    0042B 8100      LD	R16,Z
    0042C DF41      RCALL	_lcd_wdat_2
(0219)     	s ++;
    0042D 5F4F      SUBI	R20,0xFF
    0042E 4F5F      SBCI	R21,0xFF
    0042F 01FA      MOVW	R30,R20
    00430 8020      LD	R2,Z
    00431 2022      TST	R2
    00432 F7B9      BNE	0x042A
(0220)        }
(0221)     }else  if(y==3)
    00433 C010      RJMP	0x0444
    00434 2D8A      MOV	R24,R10
    00435 3083      CPI	R24,3
    00436 F469      BNE	0x0444
(0222)     {
(0223)     	lcd_wcmd_2(0x90 + x);
    00437 2F06      MOV	R16,R22
    00438 5700      SUBI	R16,0x70
    00439 DF06      RCALL	_lcd_wcmd_2
    0043A C005      RJMP	0x0440
(0224) 		  while (*s) 
(0225)        {
(0226)     	lcd_wdat_2( *s);
    0043B 01FA      MOVW	R30,R20
    0043C 8100      LD	R16,Z
    0043D DF30      RCALL	_lcd_wdat_2
(0227)     	s ++;
    0043E 5F4F      SUBI	R20,0xFF
    0043F 4F5F      SBCI	R21,0xFF
    00440 01FA      MOVW	R30,R20
    00441 8020      LD	R2,Z
    00442 2022      TST	R2
    00443 F7B9      BNE	0x043B
(0228)        }
(0229)     }
    00444 940C 0BC3 JMP	pop_xgsetF00C
_read_ac_1:
  result               --> R20
    00446 934A      ST	-Y,R20
    00447 935A      ST	-Y,R21
(0230)    
(0231) }
(0232) //****************************
(0233) //  读出数据,.不知道有没有用，先放在这
(0234) //****************************
(0235) /**
(0236)  读程序。命令后，读AC地址
(0237) */
(0238) uchar read_ac_1(void){
(0239) 	uint result;
(0240) 	DDRA=0x00;
    00448 2422      CLR	R2
    00449 BA2A      OUT	0x1A,R2
(0241) 	rs_l;
    0044A 9180 0065 LDS	R24,0x65
    0044C 7F8D      ANDI	R24,0xFD
    0044D 9380 0065 STS	0x65,R24
(0242) 	rw_h;
    0044F 9180 0065 LDS	R24,0x65
    00451 6081      ORI	R24,1
    00452 9380 0065 STS	0x65,R24
(0243) 	ep1_h;
    00454 9180 0065 LDS	R24,0x65
    00456 6088      ORI	R24,0x8
    00457 9380 0065 STS	0x65,R24
(0244) 	delay_ms(1);
    00459 E001      LDI	R16,1
    0045A E010      LDI	R17,0
    0045B 940E 007D CALL	_delay_ms
(0245) 	result=PINA&(~(1<<PINA7));
    0045D B349      IN	R20,0x19
    0045E 2755      CLR	R21
    0045F 774F      ANDI	R20,0x7F
(0246) 	DDRA=0xFF;
    00460 EF8F      LDI	R24,0xFF
    00461 BB8A      OUT	0x1A,R24
(0247) 	ep1_l;
    00462 9180 0065 LDS	R24,0x65
    00464 7F87      ANDI	R24,0xF7
    00465 9380 0065 STS	0x65,R24
(0248) 	return result;
    00467 2F04      MOV	R16,R20
    00468 9159      LD	R21,Y+
    00469 9149      LD	R20,Y+
    0046A 9508      RET
_read_ac_2:
  result               --> R20
    0046B 934A      ST	-Y,R20
    0046C 935A      ST	-Y,R21
(0249) }
(0250) uchar read_ac_2(void){
(0251) 	uint result;
(0252) 	DDRA=0x00;
    0046D 2422      CLR	R2
    0046E BA2A      OUT	0x1A,R2
(0253) 	rs_l;
    0046F 9180 0065 LDS	R24,0x65
    00471 7F8D      ANDI	R24,0xFD
    00472 9380 0065 STS	0x65,R24
(0254) 	rw_h;
    00474 9180 0065 LDS	R24,0x65
    00476 6081      ORI	R24,1
    00477 9380 0065 STS	0x65,R24
(0255) 	ep2_h;
    00479 9180 0062 LDS	R24,0x62
    0047B 6081      ORI	R24,1
    0047C 9380 0062 STS	0x62,R24
(0256) 	delay_ms(1);
    0047E E001      LDI	R16,1
    0047F E010      LDI	R17,0
    00480 940E 007D CALL	_delay_ms
(0257) 	result=PINA&(~(1<<PINA7));
    00482 B349      IN	R20,0x19
    00483 2755      CLR	R21
    00484 774F      ANDI	R20,0x7F
(0258) 	DDRA=0xFF;
    00485 EF8F      LDI	R24,0xFF
    00486 BB8A      OUT	0x1A,R24
(0259) 	ep2_l;
    00487 9180 0062 LDS	R24,0x62
    00489 7F8E      ANDI	R24,0xFE
    0048A 9380 0062 STS	0x62,R24
(0260) 	return result;
    0048C 2F04      MOV	R16,R20
    0048D 9159      LD	R21,Y+
    0048E 9149      LD	R20,Y+
    0048F 9508      RET
(0261) }
(0262) 
(0263) void lcd_clear(void){
(0264)    lcd_clear_1();
_lcd_clear:
    00490 DE83      RCALL	_lcd_clear_1
(0265)     lcd_clear_2();
    00491 CF06      RJMP	_lcd_clear_2
_date_cmd_1:
  result               --> R10
    00492 92AA      ST	-Y,R10
    00493 92BA      ST	-Y,R11
(0266) }
(0267) /*
(0268)  读数据程序。命令后，读入。使用read_data函数会是设定的值，再吃调用本函数会使ac
(0269)  移动一次，8读取位的数据
(0270) */
(0271) uchar date_cmd_1(void){
(0272) 	uint result;
(0273) 	DDRA=0x00;
    00494 2422      CLR	R2
    00495 BA2A      OUT	0x1A,R2
(0274) 	rs_h;
    00496 9180 0065 LDS	R24,0x65
    00498 6082      ORI	R24,2
    00499 9380 0065 STS	0x65,R24
(0275) 	rw_h;
    0049B 9180 0065 LDS	R24,0x65
    0049D 6081      ORI	R24,1
    0049E 9380 0065 STS	0x65,R24
(0276) 	ep1_h;
    004A0 9180 0065 LDS	R24,0x65
    004A2 6088      ORI	R24,0x8
    004A3 9380 0065 STS	0x65,R24
(0277) 	delay_ms(1);
    004A5 E001      LDI	R16,1
    004A6 E010      LDI	R17,0
    004A7 940E 007D CALL	_delay_ms
(0278) 	result=PINA;
    004A9 B2A9      IN	R10,0x19
    004AA 24BB      CLR	R11
(0279) 	DDRA=0xFF;
    004AB EF8F      LDI	R24,0xFF
    004AC BB8A      OUT	0x1A,R24
(0280) 	ep1_l;
    004AD 9180 0065 LDS	R24,0x65
    004AF 7F87      ANDI	R24,0xF7
    004B0 9380 0065 STS	0x65,R24
(0281) 	return result;
    004B2 2D0A      MOV	R16,R10
    004B3 90B9      LD	R11,Y+
    004B4 90A9      LD	R10,Y+
    004B5 9508      RET
_date_cmd_2:
  result               --> R10
    004B6 92AA      ST	-Y,R10
    004B7 92BA      ST	-Y,R11
(0282) }
(0283) uchar date_cmd_2(void){
(0284) 	uint result;
(0285) 	DDRA=0x00;
    004B8 2422      CLR	R2
    004B9 BA2A      OUT	0x1A,R2
(0286) 	rs_h;
    004BA 9180 0065 LDS	R24,0x65
    004BC 6082      ORI	R24,2
    004BD 9380 0065 STS	0x65,R24
(0287) 	rw_h;
    004BF 9180 0065 LDS	R24,0x65
    004C1 6081      ORI	R24,1
    004C2 9380 0065 STS	0x65,R24
(0288) 	ep2_h;
    004C4 9180 0062 LDS	R24,0x62
    004C6 6081      ORI	R24,1
    004C7 9380 0062 STS	0x62,R24
(0289) 	delay_ms(1);
    004C9 E001      LDI	R16,1
    004CA E010      LDI	R17,0
    004CB 940E 007D CALL	_delay_ms
(0290) 	result=PINA;
    004CD B2A9      IN	R10,0x19
    004CE 24BB      CLR	R11
(0291) 	DDRA=0xFF;
    004CF EF8F      LDI	R24,0xFF
    004D0 BB8A      OUT	0x1A,R24
(0292) 	ep2_l;
    004D1 9180 0062 LDS	R24,0x62
    004D3 7F8E      ANDI	R24,0xFE
    004D4 9380 0062 STS	0x62,R24
(0293) 	return result;
    004D6 2D0A      MOV	R16,R10
    004D7 90B9      LD	R11,Y+
    004D8 90A9      LD	R10,Y+
    004D9 9508      RET
_read_data_xy:
  y                    --> R22
  x                    --> R20
    004DA 940E 0BBC CALL	push_xgsetF00C
    004DC 2F62      MOV	R22,R18
    004DD 2F40      MOV	R20,R16
(0294) }
(0295) //**************************
(0296) //读取函数，注意会ac位置
(0297) //**************************
(0298) uchar read_data_xy(unsigned char x,unsigned char y){
(0299) 	if (y == 0) {
    004DE 2366      TST	R22
    004DF F449      BNE	0x04E9
(0300)     	lcd_wcmd_1(0x80 + x);
    004E0 2F04      MOV	R16,R20
    004E1 5800      SUBI	R16,0x80
    004E2 DDD9      RCALL	_lcd_wcmd_1
(0301) 		delay_us(10);
    004E3 E00A      LDI	R16,0xA
    004E4 E010      LDI	R17,0
    004E5 940E 0073 CALL	_delay_us
(0302) 		return date_cmd_1();
    004E7 DFAA      RCALL	_date_cmd_1
    004E8 C024      RJMP	0x050D
(0303) 		
(0304)     }else  if(y==1){
    004E9 3061      CPI	R22,1
    004EA F449      BNE	0x04F4
(0305)     	lcd_wcmd_1(0x90 + x);
    004EB 2F04      MOV	R16,R20
    004EC 5700      SUBI	R16,0x70
    004ED DDCE      RCALL	_lcd_wcmd_1
(0306) 		delay_us(10);
    004EE E00A      LDI	R16,0xA
    004EF E010      LDI	R17,0
    004F0 940E 0073 CALL	_delay_us
(0307) 		return date_cmd_1();
    004F2 DF9F      RCALL	_date_cmd_1
    004F3 C019      RJMP	0x050D
(0308)     }else  if(y==2){
    004F4 3062      CPI	R22,2
    004F5 F451      BNE	0x0500
(0309)     	lcd_wcmd_2(0x80 + x);
    004F6 2F04      MOV	R16,R20
    004F7 5800      SUBI	R16,0x80
    004F8 DE47      RCALL	_lcd_wcmd_2
(0310) 		delay_us(10);
    004F9 E00A      LDI	R16,0xA
    004FA E010      LDI	R17,0
    004FB 940E 0073 CALL	_delay_us
(0311) 		return date_cmd_2();
    004FD DFB8      RCALL	_date_cmd_2
    004FE 2EA0      MOV	R10,R16
    004FF C00D      RJMP	0x050D
(0312)     }else  if(y==3){
    00500 3063      CPI	R22,3
    00501 F451      BNE	0x050C
(0313)     	lcd_wcmd_2(0x90 + x);
    00502 2F04      MOV	R16,R20
    00503 5700      SUBI	R16,0x70
    00504 DE3B      RCALL	_lcd_wcmd_2
(0314) 		delay_us(10);
    00505 E00A      LDI	R16,0xA
    00506 E010      LDI	R17,0
    00507 940E 0073 CALL	_delay_us
(0315) 		return date_cmd_2();
    00509 DFAC      RCALL	_date_cmd_2
    0050A 2EA0      MOV	R10,R16
    0050B C001      RJMP	0x050D
(0316)     }
(0317) 	
(0318) 	return 0x00;
    0050C 2700      CLR	R16
    0050D 940C 0BC3 JMP	pop_xgsetF00C
_read_data_1:
  addr                 --> R10
    0050F 92AA      ST	-Y,R10
    00510 2EA0      MOV	R10,R16
(0319) }
(0320) uchar read_data_1(unsigned char addr){
(0321) 	
(0322)     	lcd_wcmd_1(addr);
    00511 2D0A      MOV	R16,R10
    00512 DDA9      RCALL	_lcd_wcmd_1
(0323)     	return date_cmd_1();
    00513 DF7E      RCALL	_date_cmd_1
    00514 90A9      LD	R10,Y+
    00515 9508      RET
_read_data_2:
  addr                 --> R10
    00516 92AA      ST	-Y,R10
    00517 2EA0      MOV	R10,R16
(0324) }
(0325) uchar read_data_2(unsigned char addr){
(0326)     	lcd_wcmd_1(addr);
    00518 2D0A      MOV	R16,R10
    00519 DDA2      RCALL	_lcd_wcmd_1
(0327) 		return date_cmd_2();
    0051A DF9B      RCALL	_date_cmd_2
    0051B 90A9      LD	R10,Y+
    0051C 9508      RET
(0328) }
(0329) 
(0330) 
(0331) /*初始化功能*/
(0332) void lcd_init(void){
(0333) 	 //初始化端口功能
(0334) 	 DDRA |=0xFF;
_lcd_init:
    0051D B38A      IN	R24,0x1A
    0051E 6F8F      ORI	R24,0xFF
    0051F BB8A      OUT	0x1A,R24
(0335) 	 PORTA=0xFF;
    00520 EF8F      LDI	R24,0xFF
    00521 BB8B      OUT	0x1B,R24
(0336) 	 DDRG |=0x0F;
    00522 9180 0064 LDS	R24,0x64
    00524 608F      ORI	R24,0xF
    00525 9380 0064 STS	0x64,R24
(0337) 	 PORTG|=0x0F;
    00527 9180 0065 LDS	R24,0x65
    00529 608F      ORI	R24,0xF
    0052A 9380 0065 STS	0x65,R24
(0338) 	 DDRF|=0x01;
    0052C 9180 0061 LDS	R24,0x61
    0052E 6081      ORI	R24,1
    0052F 9380 0061 STS	0x61,R24
(0339) 	 PORTF|=0x01;
    00531 9180 0062 LDS	R24,0x62
    00533 6081      ORI	R24,1
    00534 9380 0062 STS	0x62,R24
(0340) 	 //lcd_wcmd(0x38);//初始化功能,8位，基本指令
(0341) 	 lcd_wcmd_1(0x30);//初始化功能,8位，基本指令
    00536 E300      LDI	R16,0x30
    00537 DD84      RCALL	_lcd_wcmd_1
(0342) 	 delay_us(1);
    00538 E001      LDI	R16,1
    00539 E010      LDI	R17,0
    0053A 940E 0073 CALL	_delay_us
(0343) 	  lcd_wcmd_1(0x08);//关显示
    0053C E008      LDI	R16,0x8
    0053D DD7E      RCALL	_lcd_wcmd_1
(0344) 	 delay_us(1);
    0053E E001      LDI	R16,1
    0053F E010      LDI	R17,0
    00540 940E 0073 CALL	_delay_us
(0345) 	  lcd_wcmd_1(0x01);//清显示
    00542 E001      LDI	R16,1
    00543 DD78      RCALL	_lcd_wcmd_1
(0346) 	 delay_us(1);
    00544 E001      LDI	R16,1
    00545 E010      LDI	R17,0
    00546 940E 0073 CALL	_delay_us
(0347) 	  lcd_wcmd_1(0x06);//输入模式，右移
    00548 E006      LDI	R16,6
    00549 DD72      RCALL	_lcd_wcmd_1
(0348) 	  delay_us(1);
    0054A E001      LDI	R16,1
    0054B E010      LDI	R17,0
    0054C 940E 0073 CALL	_delay_us
(0349) 	  lcd_wcmd_1(0x0c);//初始化光标,开显示
    0054E E00C      LDI	R16,0xC
    0054F DD6C      RCALL	_lcd_wcmd_1
(0350) 	
(0351) 	 delay_us(1);
    00550 E001      LDI	R16,1
    00551 E010      LDI	R17,0
    00552 940E 0073 CALL	_delay_us
(0352) 	  lcd_wcmd_2(0x30);//初始化功能,8位，基本指令
    00554 E300      LDI	R16,0x30
    00555 DDEA      RCALL	_lcd_wcmd_2
(0353) 	 delay_us(1);
    00556 E001      LDI	R16,1
    00557 E010      LDI	R17,0
    00558 940E 0073 CALL	_delay_us
(0354) 	 lcd_wcmd_2(0x08);//关显示
    0055A E008      LDI	R16,0x8
    0055B DDE4      RCALL	_lcd_wcmd_2
(0355) 	 delay_us(1);
    0055C E001      LDI	R16,1
    0055D E010      LDI	R17,0
    0055E 940E 0073 CALL	_delay_us
(0356) 	 lcd_wcmd_2(0x01);//清显示
    00560 E001      LDI	R16,1
    00561 DDDE      RCALL	_lcd_wcmd_2
(0357) 	 delay_us(1);
    00562 E001      LDI	R16,1
    00563 E010      LDI	R17,0
    00564 940E 0073 CALL	_delay_us
(0358) 	 lcd_wcmd_2(0x06);//输入模式，右移
    00566 E006      LDI	R16,6
    00567 DDD8      RCALL	_lcd_wcmd_2
(0359) 	  delay_us(1);
    00568 E001      LDI	R16,1
    00569 E010      LDI	R17,0
    0056A 940E 0073 CALL	_delay_us
(0360) 	 lcd_wcmd_2(0x0c);//初始化光标,开显示
    0056C E00C      LDI	R16,0xC
    0056D CDD2      RJMP	_lcd_wcmd_2
_cur_set:
  type                 --> R20
    0056E 934A      ST	-Y,R20
    0056F 935A      ST	-Y,R21
    00570 01A8      MOVW	R20,R16
(0361) }
(0362) //************
(0363) // 光标显示操作,默认初始化都是关闭。上半屏 0:关闭,1：开游标,2：游标反白,3：开游标、反白
(0364) // 下半屏  4:关闭,5：开游标,6：游标反白,7：开游标、反白
(0365) //************
(0366) void cur_set(uint type){
(0367) 	 if(type==0){
    00571 3040      CPI	R20,0
    00572 0745      CPC	R20,R21
    00573 F419      BNE	0x0577
(0368) 	 	lcd_wcmd_1(0x0c);	 
    00574 E00C      LDI	R16,0xC
    00575 DD46      RCALL	_lcd_wcmd_1
(0369) 	 }else if(type==1){
    00576 C030      RJMP	0x05A7
    00577 3041      CPI	R20,1
    00578 E0E0      LDI	R30,0
    00579 075E      CPC	R21,R30
    0057A F419      BNE	0x057E
(0370) 	     lcd_wcmd_1(0x0e);
    0057B E00E      LDI	R16,0xE
    0057C DD3F      RCALL	_lcd_wcmd_1
(0371) 	 }else if(type==2){
    0057D C029      RJMP	0x05A7
    0057E 3042      CPI	R20,2
    0057F E0E0      LDI	R30,0
    00580 075E      CPC	R21,R30
    00581 F419      BNE	0x0585
(0372) 	    lcd_wcmd_1(0x0d);
    00582 E00D      LDI	R16,0xD
    00583 DD38      RCALL	_lcd_wcmd_1
(0373) 	 }else if(type==3){
    00584 C022      RJMP	0x05A7
    00585 3043      CPI	R20,3
    00586 E0E0      LDI	R30,0
    00587 075E      CPC	R21,R30
    00588 F419      BNE	0x058C
(0374) 	    lcd_wcmd_1(0x0f);
    00589 E00F      LDI	R16,0xF
    0058A DD31      RCALL	_lcd_wcmd_1
(0375) 	 }else if(type==4){
    0058B C01B      RJMP	0x05A7
    0058C 3044      CPI	R20,4
    0058D E0E0      LDI	R30,0
    0058E 075E      CPC	R21,R30
    0058F F419      BNE	0x0593
(0376) 	    lcd_wcmd_2(0x0c);
    00590 E00C      LDI	R16,0xC
    00591 DDAE      RCALL	_lcd_wcmd_2
(0377) 	 }else if(type==5){
    00592 C014      RJMP	0x05A7
    00593 3045      CPI	R20,5
    00594 E0E0      LDI	R30,0
    00595 075E      CPC	R21,R30
    00596 F419      BNE	0x059A
(0378) 	    lcd_wcmd_2(0x0e);
    00597 E00E      LDI	R16,0xE
    00598 DDA7      RCALL	_lcd_wcmd_2
(0379) 	 }else if(type==6){
    00599 C00D      RJMP	0x05A7
    0059A 3046      CPI	R20,6
    0059B E0E0      LDI	R30,0
    0059C 075E      CPC	R21,R30
    0059D F419      BNE	0x05A1
(0380) 	    lcd_wcmd_2(0x0d);
    0059E E00D      LDI	R16,0xD
    0059F DDA0      RCALL	_lcd_wcmd_2
(0381) 	 }else if(type==7){
    005A0 C006      RJMP	0x05A7
    005A1 3047      CPI	R20,7
    005A2 E0E0      LDI	R30,0
    005A3 075E      CPC	R21,R30
    005A4 F411      BNE	0x05A7
(0382) 	    lcd_wcmd_2(0x0f);
    005A5 E00F      LDI	R16,0xF
    005A6 DD99      RCALL	_lcd_wcmd_2
(0383) 	 }
    005A7 9159      LD	R21,Y+
    005A8 9149      LD	R20,Y+
    005A9 9508      RET
(0384) }
(0385) //***************************************************
(0386) //   反白相关
(0387) //***************************************************
(0388) /********************************************************************  
(0389)     函 数 名：Set_Draw(  
(0390)     入口参数：无  
(0391)     出口参数：无  
(0392)     修改日期：  
(0393)     函数作用：  
(0394)     说    明：  
(0395)     ********************************************************************/   
(0396)     void Set_Draw(void)   
(0397)     {   
(0398)         //W_1byte(0,0,0x01);            //清屏   
(0399)         delay_ms(2);                  //延时   
_Set_Draw:
    005AA E002      LDI	R16,2
    005AB E010      LDI	R17,0
    005AC 940E 007D CALL	_delay_ms
(0400)         //W_1byte(0,0,0x34);            //8BIT控制界面，扩充指令集,，绘图显示OFF   
(0401)         lcd_wcmd_1(0x36); 
    005AE E306      LDI	R16,0x36
    005AF DD0C      RCALL	_lcd_wcmd_1
(0402) 		//lcd_wcmd_2(0x36);   
(0403)         delay_ms(2);                  //延时   
    005B0 E002      LDI	R16,2
    005B1 E010      LDI	R17,0
    005B2 940C 007D JMP	_delay_ms
(0404)     }
(0405) 	void Set_UNDraw(void)   
(0406)     {   
(0407)         //W_1byte(0,0,0x01);            //清屏   
(0408)         delay_ms(2);                  //延时   
_Set_UNDraw:
    005B4 E002      LDI	R16,2
    005B5 E010      LDI	R17,0
    005B6 940E 007D CALL	_delay_ms
(0409)         //W_1byte(0,0,0x34);            //8BIT控制界面，扩充指令集,，绘图显示OFF   
(0410)         lcd_wcmd_1(0x30); 
    005B8 E300      LDI	R16,0x30
    005B9 DD02      RCALL	_lcd_wcmd_1
(0411) 		//lcd_wcmd_2(0x36);   
(0412)         delay_ms(2);                  //延时   
    005BA E002      LDI	R16,2
    005BB E010      LDI	R17,0
    005BC 940C 007D JMP	_delay_ms
_Set_White_off:
  clr_y                --> R12
  clr_x                --> R14
  white_y              --> R20
  white_x              --> R22
  i                    --> R12
  white_end_x          --> R10
  j                    --> R14
  end_x                --> R10
  y                    --> Y,+12
  x                    --> Y,+10
    005BE 940E 0B87 CALL	push_arg4
    005C0 940E 0BA7 CALL	push_xgsetF0FC
    005C2 84AE      LDD	R10,Y+14
(0413)     }
(0414) /**************************************************  
(0415)     uchar x,起始位置
(0416) 	uchar y,对应y
(0417) 	uchar end_x, 反白结束位置
(0418) 	uchar clear 0：反白，1：不反白
(0419)  **************************************************/   
(0420)     void Set_White_off(uchar x,uchar y,uchar end_x)   
(0421)     {   
(0422)         uchar i, j, white_x, white_y,white_end_x,clr_x,clr_y;       //   
(0423)         white_end_x = (end_x-x+1);   
    005C3 2D8A      MOV	R24,R10
    005C4 840A      LDD	R0,Y+10
    005C5 1980      SUB	R24,R0
    005C6 5F8F      SUBI	R24,0xFF
    005C7 2EA8      MOV	R10,R24
(0424)         white_end_x <<= 1;   //16*16，一次写8个，所以乘2
    005C8 0CAA      LSL	R10
(0425) 		Set_Draw(); //开画图
    005C9 DFE0      RCALL	_Set_Draw
(0426) 		delay_us(1); 
    005CA E001      LDI	R16,1
    005CB E010      LDI	R17,0
    005CC 940E 0073 CALL	_delay_us
(0427)         if(y==1)   
    005CE 858C      LDD	R24,Y+12
    005CF 3081      CPI	R24,1
    005D0 F441      BNE	0x05D9
(0428)         {   
(0429)             white_x = (0x80+x-1);   
    005D1 856A      LDD	R22,Y+10
    005D2 5860      SUBI	R22,0x80
    005D3 5061      SUBI	R22,1
(0430)             white_y = 0x80;   
    005D4 E840      LDI	R20,0x80
(0431)             clr_x = 0x80;   
    005D5 E880      LDI	R24,0x80
    005D6 2EE8      MOV	R14,R24
(0432)             clr_y = 0x80;   
    005D7 2EC8      MOV	R12,R24
(0433)         }   
    005D8 C023      RJMP	0x05FC
(0434)         else if(y==2)   
    005D9 858C      LDD	R24,Y+12
    005DA 3082      CPI	R24,2
    005DB F449      BNE	0x05E5
(0435)         {   
(0436)             white_x = (0x80+x-1);   
    005DC 856A      LDD	R22,Y+10
    005DD 5860      SUBI	R22,0x80
    005DE 5061      SUBI	R22,1
(0437)             white_y = 0x90;   
    005DF E940      LDI	R20,0x90
(0438)             clr_x = 0x80;   
    005E0 E880      LDI	R24,0x80
    005E1 2EE8      MOV	R14,R24
(0439)             clr_y = 0x90;   
    005E2 E980      LDI	R24,0x90
    005E3 2EC8      MOV	R12,R24
(0440)         }   
    005E4 C017      RJMP	0x05FC
(0441)         else if(y==3)   
    005E5 858C      LDD	R24,Y+12
    005E6 3083      CPI	R24,3
    005E7 F449      BNE	0x05F1
(0442)         {   
(0443)             white_x = (0x88+x-1);   
    005E8 856A      LDD	R22,Y+10
    005E9 5768      SUBI	R22,0x78
    005EA 5061      SUBI	R22,1
(0444)             white_y = 0x80;   
    005EB E840      LDI	R20,0x80
(0445)             clr_x = 0x88;   
    005EC E888      LDI	R24,0x88
    005ED 2EE8      MOV	R14,R24
(0446)             clr_y = 0x80;   
    005EE E880      LDI	R24,0x80
    005EF 2EC8      MOV	R12,R24
(0447)         }   
    005F0 C00B      RJMP	0x05FC
(0448)         else if(y==4)   
    005F1 858C      LDD	R24,Y+12
    005F2 3084      CPI	R24,4
    005F3 F441      BNE	0x05FC
(0449)         {   
(0450)             white_x = (0x88+x-1);   
    005F4 856A      LDD	R22,Y+10
    005F5 5768      SUBI	R22,0x78
    005F6 5061      SUBI	R22,1
(0451)             white_y = 0x90;   
    005F7 E940      LDI	R20,0x90
(0452)             clr_x = 0x88;   
    005F8 E888      LDI	R24,0x88
    005F9 2EE8      MOV	R14,R24
(0453)             clr_y = 0x90;   
    005FA E980      LDI	R24,0x90
    005FB 2EC8      MOV	R12,R24
(0454)         }   
(0455)         delay_us(1);     
    005FC E001      LDI	R16,1
    005FD E010      LDI	R17,0
    005FE 940E 0073 CALL	_delay_us
(0456)         for(i=0;i<16;i++ )               //16行，因为是16*16汉字   
    00600 24CC      CLR	R12
    00601 C00E      RJMP	0x0610
(0457)         {   
(0458)             lcd_wcmd_1(white_y++);     //设置绘图区的Y地址坐标0   
    00602 2E24      MOV	R2,R20
    00603 5F4F      SUBI	R20,0xFF
    00604 2D02      MOV	R16,R2
    00605 DCB6      RCALL	_lcd_wcmd_1
(0459)             lcd_wcmd_1(white_x);       //设置绘图区的X地址坐标0   
    00606 2F06      MOV	R16,R22
    00607 DCB4      RCALL	_lcd_wcmd_1
(0460)             for(j=0;j<white_end_x;j++)   //   
    00608 24EE      CLR	R14
    00609 C003      RJMP	0x060D
(0461)             {     
(0462)               lcd_wdat_1(0x00); //取消这一行的8个点的反白，液晶地址自动加   
    0060A 2700      CLR	R16
    0060B DCDE      RCALL	_lcd_wdat_1
    0060C 94E3      INC	R14
    0060D 14EA      CP	R14,R10
    0060E F3D8      BCS	0x060A
    0060F 94C3      INC	R12
    00610 2D8C      MOV	R24,R12
    00611 3180      CPI	R24,0x10
    00612 F378      BCS	0x0602
(0463)             }   
(0464)         }
(0465) 		  Set_UNDraw();//关画图  
    00613 DFA0      RCALL	_Set_UNDraw
(0466) 		  delay_us(1);  
    00614 E001      LDI	R16,1
    00615 E010      LDI	R17,0
    00616 940E 0073 CALL	_delay_us
    00618 940E 0B9C CALL	pop_xgsetF0FC
    0061A 9624      ADIW	R28,4
    0061B 9508      RET
_Set_White:
  clr_y                --> R12
  clr_x                --> R14
  white_y              --> R20
  white_x              --> R22
  i                    --> R12
  white_end_x          --> R10
  j                    --> R14
  end_x                --> R10
  y                    --> Y,+12
  x                    --> Y,+10
    0061C 940E 0B87 CALL	push_arg4
    0061E 940E 0BA7 CALL	push_xgsetF0FC
    00620 84AE      LDD	R10,Y+14
(0467)     } 
(0468) 	void Set_White(uchar x,uchar y,uchar end_x)   
(0469)     {   
(0470)         uchar i, j, white_x, white_y,white_end_x,clr_x,clr_y;       //   
(0471)         white_end_x = (end_x-x+1);   
    00621 2D8A      MOV	R24,R10
    00622 840A      LDD	R0,Y+10
    00623 1980      SUB	R24,R0
    00624 5F8F      SUBI	R24,0xFF
    00625 2EA8      MOV	R10,R24
(0472)         white_end_x <<= 1;   //16*16，一次写8个，所以乘2
    00626 0CAA      LSL	R10
(0473) 		Set_Draw(); //开画图
    00627 DF82      RCALL	_Set_Draw
(0474) 		delay_us(1); 
    00628 E001      LDI	R16,1
    00629 E010      LDI	R17,0
    0062A 940E 0073 CALL	_delay_us
(0475)         if(y==1)   
    0062C 858C      LDD	R24,Y+12
    0062D 3081      CPI	R24,1
    0062E F441      BNE	0x0637
(0476)         {   
(0477)             white_x = (0x80+x-1);   
    0062F 856A      LDD	R22,Y+10
    00630 5860      SUBI	R22,0x80
    00631 5061      SUBI	R22,1
(0478)             white_y = 0x80;   
    00632 E840      LDI	R20,0x80
(0479)             clr_x = 0x80;   
    00633 E880      LDI	R24,0x80
    00634 2EE8      MOV	R14,R24
(0480)             clr_y = 0x80;   
    00635 2EC8      MOV	R12,R24
(0481)         }   
    00636 C023      RJMP	0x065A
(0482)         else if(y==2)   
    00637 858C      LDD	R24,Y+12
    00638 3082      CPI	R24,2
    00639 F449      BNE	0x0643
(0483)         {   
(0484)             white_x = (0x80+x-1);   
    0063A 856A      LDD	R22,Y+10
    0063B 5860      SUBI	R22,0x80
    0063C 5061      SUBI	R22,1
(0485)             white_y = 0x90;   
    0063D E940      LDI	R20,0x90
(0486)             clr_x = 0x80;   
    0063E E880      LDI	R24,0x80
    0063F 2EE8      MOV	R14,R24
(0487)             clr_y = 0x90;   
    00640 E980      LDI	R24,0x90
    00641 2EC8      MOV	R12,R24
(0488)         }   
    00642 C017      RJMP	0x065A
(0489)         else if(y==3)   
    00643 858C      LDD	R24,Y+12
    00644 3083      CPI	R24,3
    00645 F449      BNE	0x064F
(0490)         {   
(0491)             white_x = (0x88+x-1);   
    00646 856A      LDD	R22,Y+10
    00647 5768      SUBI	R22,0x78
    00648 5061      SUBI	R22,1
(0492)             white_y = 0x80;   
    00649 E840      LDI	R20,0x80
(0493)             clr_x = 0x88;   
    0064A E888      LDI	R24,0x88
    0064B 2EE8      MOV	R14,R24
(0494)             clr_y = 0x80;   
    0064C E880      LDI	R24,0x80
    0064D 2EC8      MOV	R12,R24
(0495)         }   
    0064E C00B      RJMP	0x065A
(0496)         else if(y==4)   
    0064F 858C      LDD	R24,Y+12
    00650 3084      CPI	R24,4
    00651 F441      BNE	0x065A
(0497)         {   
(0498)             white_x = (0x88+x-1);   
    00652 856A      LDD	R22,Y+10
    00653 5768      SUBI	R22,0x78
    00654 5061      SUBI	R22,1
(0499)             white_y = 0x90;   
    00655 E940      LDI	R20,0x90
(0500)             clr_x = 0x88;   
    00656 E888      LDI	R24,0x88
    00657 2EE8      MOV	R14,R24
(0501)             clr_y = 0x90;   
    00658 E980      LDI	R24,0x90
    00659 2EC8      MOV	R12,R24
(0502)         }       
(0503)         for(i=0;i<16;i++ )               //16行，因为是16*16汉字   
    0065A 24CC      CLR	R12
    0065B C00E      RJMP	0x066A
(0504)         {   
(0505)             lcd_wcmd_1(white_y++);     //设置绘图区的Y地址坐标0   
    0065C 2E24      MOV	R2,R20
    0065D 5F4F      SUBI	R20,0xFF
    0065E 2D02      MOV	R16,R2
    0065F DC5C      RCALL	_lcd_wcmd_1
(0506)             lcd_wcmd_1(white_x);       //设置绘图区的X地址坐标0   
    00660 2F06      MOV	R16,R22
    00661 DC5A      RCALL	_lcd_wcmd_1
(0507)             for(j=0;j<white_end_x;j++)   //   
    00662 24EE      CLR	R14
    00663 C003      RJMP	0x0667
(0508)             {    
(0509)                     lcd_wdat_1(0xff); //反白这一行的8个点，液晶地址自动加1     
    00664 EF0F      LDI	R16,0xFF
    00665 DC84      RCALL	_lcd_wdat_1
    00666 94E3      INC	R14
    00667 14EA      CP	R14,R10
    00668 F3D8      BCS	0x0664
    00669 94C3      INC	R12
    0066A 2D8C      MOV	R24,R12
    0066B 3180      CPI	R24,0x10
    0066C F378      BCS	0x065C
(0510)             }   
(0511)         }
(0512) 		  Set_UNDraw();//关画图  
    0066D DF46      RCALL	_Set_UNDraw
(0513) 		  delay_us(1);  
    0066E E001      LDI	R16,1
    0066F E010      LDI	R17,0
    00670 940E 0073 CALL	_delay_us
    00672 940E 0B9C CALL	pop_xgsetF0FC
    00674 9624      ADIW	R28,4
    00675 9508      RET
_lcd_Desk:
    00676 9722      SBIW	R28,2
(0514)     } 
(0515) 	/********************************************************************  
(0516)     函 数 名：Draw_Pic  128*64  
(0517)     入口参数：x,y,*Draw  
(0518)     出口参数：无  
(0519)     建立日期：2007年8月26日  
(0520)     修改日期：  
(0521)     函数作用：  
(0522)     说    明：  
(0523)     ********************************************************************/   
(0524)     /*************************************************/   
(0525)     /*   
(0526)     void Draw_Pic(uchar x, uchar y, const uchar *Draw)   
(0527)     {   
(0528)         uchar i, j, temp_x, temp_y;     //   
(0529)         temp_x = x;                     //   
(0530)         temp_y = y;                     //   
(0531)         temp_x |= 0x80;                 //   
(0532)         temp_y |= 0x80;                 //   
(0533)         for(i=0;i<32;i++ )               //上半屏32行   
(0534)         {   
(0535)             lcd_wcmd_1(0,0,temp_y++);      //设置绘图区的Y地址坐标0   
(0536)             lcd_wcmd_1(0,0,temp_x);        //设置绘图区的X地址坐标0   
(0537)             for(j=0;j<16;j++)            //   
(0538)             {   
(0539)                  lcd_wdat_2(0,1,*Draw++);  //   
(0540)             }   
(0541)         }   
(0542)            
(0543)         temp_x = 0x88;                  //   
(0544)         temp_y = 0x80;                  //   
(0545)         j = 0;                          //   
(0546)         for(;i<64;i++ )   
(0547)         {   
(0548)             lcd_wcmd_1(temp_y++);      //设置绘图区的Y地址坐标   
(0549)             lcd_wdat_2(temp_x);        //设置绘图区的X地址坐标   
(0550)             for(j=0;j<16;j++)   
(0551)             {   
(0552)                  lcd_wdat_2(0,1,*Draw++);  //   
(0553)             }   
(0554)         }   
(0555)             
(0556)     } */    
(0557)     /*************************************************/  
(0558) //***********************************************************************
(0559) //      液晶显示界面初始化
(0560) //***********************************************************************
(0561) void lcd_Desk(void)
(0562) { 
(0563)   //uint i=0;   
(0564)  // lcd_clear();
(0565)   //lcd_write_str(0,0,"ADC0:");
(0566)   lcd_write_str(0,3,"反白测试第一次");
    00677 E080      LDI	R24,0
    00678 E091      LDI	R25,1
    00679 8399      STD	Y+1,R25
    0067A 8388      ST	Y,R24
    0067B E023      LDI	R18,3
    0067C 2700      CLR	R16
    0067D DD7E      RCALL	_lcd_write_str
(0567)   lcd_write_str(0,0,"反白测试第一次");
    0067E E080      LDI	R24,0
    0067F E091      LDI	R25,1
    00680 8399      STD	Y+1,R25
    00681 8388      ST	Y,R24
    00682 2722      CLR	R18
    00683 2700      CLR	R16
    00684 DD77      RCALL	_lcd_write_str
(0568)   //delay_ms(100);
(0569)      
(0570)     Set_White(1,1,7); 
    00685 E087      LDI	R24,7
    00686 8388      ST	Y,R24
    00687 E021      LDI	R18,1
    00688 E001      LDI	R16,1
    00689 DF92      RCALL	_Set_White
(0571) 	   
(0572) 	 
(0573)     delay_ms(3000); 
    0068A EB08      LDI	R16,0xB8
    0068B E01B      LDI	R17,0xB
    0068C 940E 007D CALL	_delay_ms
(0574)      Set_White_off(1,1,7);
    0068E E087      LDI	R24,7
    0068F 8388      ST	Y,R24
    00690 E021      LDI	R18,1
    00691 E001      LDI	R16,1
    00692 DF2B      RCALL	_Set_White_off
(0575) 	Set_White(2,1,2); 
    00693 E082      LDI	R24,2
    00694 8388      ST	Y,R24
    00695 E021      LDI	R18,1
    00696 E002      LDI	R16,2
    00697 DF84      RCALL	_Set_White
(0576) 	 delay_ms(300); 
    00698 E20C      LDI	R16,0x2C
    00699 E011      LDI	R17,1
    0069A 940E 007D CALL	_delay_ms
(0577) 	 Set_White_off(2,2,7);
    0069C E087      LDI	R24,7
    0069D 8388      ST	Y,R24
    0069E E022      LDI	R18,2
    0069F E002      LDI	R16,2
    006A0 DF1D      RCALL	_Set_White_off
(0578) 	 Set_White(3,1,5);   
    006A1 E085      LDI	R24,5
    006A2 8388      ST	Y,R24
    006A3 E021      LDI	R18,1
    006A4 E003      LDI	R16,3
    006A5 DF76      RCALL	_Set_White
    006A6 9622      ADIW	R28,2
    006A7 9508      RET
_main:
  data                 --> R20
    006A8 9722      SBIW	R28,2
FILE: E:\ICCDemo\Temp_Control\temp_control\main.c
(0001) 
(0002) #include<iom128v.h>
(0003) #include "main.h"
(0004) #include "lcd.h"
(0005) #include "time.h"
(0006) #include "key.h"
(0007) #include "delay.h"
(0008) #include "timertask.h"
(0009) #include "eeprom.h"
(0010) unsigned int temp_h=0;
(0011) unsigned int temp_l=0;
(0012)  unsigned char send_buf[600];
(0013)  unsigned char receive_buf[600];
(0014)  unsigned int send_len;
(0015)  unsigned int receive_len;
(0016) //*************************************************************************
(0017) //			主程序
(0018) //*************************************************************************
(0019) void main(void)
(0020) { 
(0021)   uchar data;
(0022)   DDRE=0xFF;
    006A9 EF8F      LDI	R24,0xFF
    006AA B982      OUT	0x02,R24
(0023)   SREG|=0x80;//开中断
    006AB 9478      BSET	7
(0024)   lcd_init();
    006AC 940E 051D CALL	_lcd_init
(0025)   lcd_clear(); 
    006AE 940E 0490 CALL	_lcd_clear
(0026)   /*Initial_time();
(0027)    lcd_Desk(); 
(0028)    delay_us(10);
(0029)     data=read_data_xy(0,0);
(0030)   data=read_data_xy(0,0);
(0031)   lcd_write_char(2,2,data);
(0032)   lcd_write_char_con(2,date_cmd_1());
(0033)   lcd_write_char_con(2,date_cmd_1());
(0034)   lcd_write_char_con(2,date_cmd_1());
(0035)   lcd_write_char_con(2,date_cmd_1());
(0036)   lcd_write_char_con(2,date_cmd_1());
(0037)   lcd_write_char_con(2,date_cmd_1());
(0038)   lcd_write_char_con(2,date_cmd_1());
(0039)   lcd_write_char_con(2,date_cmd_1());
(0040)   lcd_write_char_con(2,date_cmd_1());
(0041)   lcd_write_char_con(2,date_cmd_1());
(0042)   lcd_write_char_con(2,date_cmd_1());
(0043)   lcd_write_char_con(2,date_cmd_1());
(0044)   lcd_write_char_con(2,date_cmd_1());
(0045)    //Timerinit_1(0x00,0x00);
(0046)    Timerinit_3(0x88,0x88);
(0047)    //Timerinit_0(0x88);
(0048)   // Timerinit_2(0x01);*/
(0049)  // EEPROM_write(0x00,0x00,0x02);
(0050)   data=EEPROM_read(0x00,0x00);
    006B0 2722      CLR	R18
    006B1 2733      CLR	R19
    006B2 2700      CLR	R16
    006B3 2711      CLR	R17
    006B4 940E 0B71 CALL	_EEPROM_read
    006B6 2F40      MOV	R20,R16
(0051)    lcd_write_char(8,0,0x30|data);
    006B7 2F84      MOV	R24,R20
    006B8 6380      ORI	R24,0x30
    006B9 8388      ST	Y,R24
    006BA 2722      CLR	R18
    006BB E008      LDI	R16,0x8
    006BC 940E 03D6 CALL	_lcd_write_char
(0052)    EEPROM_write(0x00,0x00,data+1);
    006BE 2F84      MOV	R24,R20
    006BF 2799      CLR	R25
    006C0 9601      ADIW	R24,1
    006C1 8399      STD	Y+1,R25
    006C2 8388      ST	Y,R24
    006C3 2722      CLR	R18
    006C4 2733      CLR	R19
    006C5 2700      CLR	R16
    006C6 2711      CLR	R17
    006C7 940E 0B5A CALL	_EEPROM_write
(0053)   PORTE=~data;
    006C9 2E24      MOV	R2,R20
    006CA 9420      COM	R2
    006CB B823      OUT	0x03,R2
(0054)    lcd_Desk(); 
    006CC 940E 0676 CALL	_lcd_Desk
    006CE C009      RJMP	0x06D8
(0055)  
(0056)   while(1){
(0057)    
(0058)    
(0059)    
(0060)    showTimeLcd();
    006CF 940E 00FE CALL	_showTimeLcd
(0061)     lcd_write_char(0,2,KeyScan_once());
    006D1 940E 0265 CALL	_KeyScan_once
    006D3 8308      ST	Y,R16
    006D4 E022      LDI	R18,2
    006D5 2700      CLR	R16
    006D6 940E 03D6 CALL	_lcd_write_char
    006D8 CFF6      RJMP	0x06CF
    006D9 9622      ADIW	R28,2
    006DA 9508      RET
FILE: E:\ICCDemo\Temp_Control\temp_control\timertask.c
(0001) #include<iom128v.h>
(0002) #include "timertask.h"
(0003) #include "time.h"
(0004) #include "lcd.h"
(0005) #include "delay.h"
(0006) unsigned char time_h_1, time_l_1,time_h_3, time_l_3,time_0, time_2,i;
(0007) //************************************************
(0008) //16位定时器，定时器1
(0009) //*************************************************
(0010) /*
(0011)   计数器1，16位的。普通计时，1024分频。在16M下约0.061ms计数一次。共4s钟,
(0012)   自行计算时间传入。传入高低八位
(0013) */
(0014) void Timerinit_1(uchar time_h,uchar time_l){
(0015)     time_h_1=time_h;
_Timerinit_1:
  time_l               --> R18
  time_h               --> R16
    006DB 9300 05CD STS	time_h_1,R16
(0016) 	time_l_1=time_l;
    006DD 9320 05CC STS	time_l_1,R18
(0017) 	 TCCR1B=0x00;
    006DF 2422      CLR	R2
    006E0 BC2E      OUT	0x2E,R2
(0018) 	//写入初值
(0019)     TCNT1H=time_h;
    006E1 BD0D      OUT	0x2D,R16
(0020)     TCNT1L=time_l;
    006E2 BD2C      OUT	0x2C,R18
(0021) 	//普通计数，1024分频
(0022)     TCCR1A=0x00;
    006E3 BC2F      OUT	0x2F,R2
(0023)     TCCR1B=0x05;
    006E4 E085      LDI	R24,5
    006E5 BD8E      OUT	0x2E,R24
(0024) 	 TIMSK|=0x04;//开定时器1溢出中断,16位的
    006E6 B787      IN	R24,0x37
    006E7 6084      ORI	R24,4
    006E8 BF87      OUT	0x37,R24
    006E9 9508      RET
(0025) }
(0026) //************************************************
(0027) //16位定时器，定时器3
(0028) //*************************************************
(0029) /*
(0030)   计数器1，16位的。普通计时，1024分频。在16M下约0.061ms计数一次。共4s钟,
(0031)   自行计算时间传入。传入高低八位
(0032) */
(0033) void Timerinit_3(uchar time_h,uchar time_l){
(0034)  	time_h_3=time_h;
_Timerinit_3:
  time_l               --> R18
  time_h               --> R16
    006EA 9300 05CB STS	time_h_3,R16
(0035) 	time_l_3=time_l;
    006EC 9320 05CA STS	time_l_3,R18
(0036) 	//写入初值
(0037) 	 TCCR3B=0x00;
    006EE 2422      CLR	R2
    006EF 9220 008A STS	0x8A,R2
(0038)     TCNT3H=time_h;
    006F1 9300 0089 STS	0x89,R16
(0039)     TCNT3L=time_l;
    006F3 9320 0088 STS	0x88,R18
(0040) 	//普通计数，1024分频
(0041)     TCCR3A=0x00;
    006F5 9220 008B STS	0x8B,R2
(0042)     TCCR3B=0x05;
    006F7 E085      LDI	R24,5
    006F8 9380 008A STS	0x8A,R24
(0043) 	ETIMSK |=0x04;//开外部中断1
    006FA 9180 007D LDS	R24,0x7D
    006FC 6084      ORI	R24,4
    006FD 9380 007D STS	0x7D,R24
    006FF 9508      RET
(0044) }
(0045) //************************************************
(0046) //8位定时器，定时器0
(0047) //*************************************************
(0048) 
(0049) /*
(0050)   计数器0，8位的。普通计时，1024分频。
(0051)   自行计算时间传入。
(0052) */
(0053) void Timerinit_0(uchar time){
(0054)     time_0=time;
_Timerinit_0:
  time                 --> R16
    00700 9300 05C9 STS	time_0,R16
(0055) 	//写入初值
(0056)     TCNT0=time;
    00702 BF02      OUT	0x32,R16
(0057) 	TIMSK|=0x01;//开定时器0溢出中断,8位的
    00703 B787      IN	R24,0x37
    00704 6081      ORI	R24,1
    00705 BF87      OUT	0x37,R24
(0058) 	 TCCR0=0x07;//普通计数，1024分频
    00706 E087      LDI	R24,7
    00707 BF83      OUT	0x33,R24
    00708 9508      RET
(0059) }
(0060) //************************************************
(0061) //8位定时器，定时器2
(0062) //*************************************************
(0063) /*
(0064)   计数器0，8位的。普通计时，1024分频。
(0065)   自行计算时间传入。
(0066) */
(0067) void Timerinit_2(uchar time){
(0068)     time_2=time;
_Timerinit_2:
  time                 --> R16
    00709 9300 05C8 STS	time_2,R16
(0069) 	//写入初值
(0070)     TCNT2=time;
    0070B BD04      OUT	0x24,R16
(0071) 	TIMSK|=0x40;//开定时器0溢出中断,8位的
    0070C B787      IN	R24,0x37
    0070D 6480      ORI	R24,0x40
    0070E BF87      OUT	0x37,R24
(0072) 	//普通计数，1024分频
(0073)     TCCR2=0x05;
    0070F E085      LDI	R24,5
    00710 BD85      OUT	0x25,R24
    00711 9508      RET
_int_timer0:
    00712 920A      ST	-Y,R0
    00713 921A      ST	-Y,R1
    00714 922A      ST	-Y,R2
    00715 923A      ST	-Y,R3
    00716 924A      ST	-Y,R4
    00717 925A      ST	-Y,R5
    00718 926A      ST	-Y,R6
    00719 927A      ST	-Y,R7
    0071A 928A      ST	-Y,R8
    0071B 929A      ST	-Y,R9
    0071C 930A      ST	-Y,R16
    0071D 931A      ST	-Y,R17
    0071E 932A      ST	-Y,R18
    0071F 933A      ST	-Y,R19
    00720 938A      ST	-Y,R24
    00721 939A      ST	-Y,R25
    00722 93AA      ST	-Y,R26
    00723 93BA      ST	-Y,R27
    00724 93EA      ST	-Y,R30
    00725 93FA      ST	-Y,R31
    00726 B60F      IN	R0,0x3F
    00727 920A      ST	-Y,R0
    00728 9721      SBIW	R28,1
(0074) }
(0075) #pragma interrupt_handler int_timer0:17
(0076) void int_timer0(void){ 
(0077) 		TCCR0=0x00;
    00729 2422      CLR	R2
    0072A BE23      OUT	0x33,R2
(0078) 		//adc_init_once();
(0079) 		for(i=0;i<5;i++){
    0072B 9220 05C7 STS	i,R2
    0072D C011      RJMP	0x073F
(0080)   		 lcd_write_char(0x01,3,0x30+i);	
    0072E 9180 05C7 LDS	R24,i
    00730 5D80      SUBI	R24,0xD0
    00731 8388      ST	Y,R24
    00732 E023      LDI	R18,3
    00733 E001      LDI	R16,1
    00734 940E 03D6 CALL	_lcd_write_char
(0081) 		 delay_ms(100);		
    00736 E604      LDI	R16,0x64
    00737 E010      LDI	R17,0
    00738 940E 007D CALL	_delay_ms
    0073A 9180 05C7 LDS	R24,i
    0073C 5F8F      SUBI	R24,0xFF
    0073D 9380 05C7 STS	i,R24
    0073F 9180 05C7 LDS	R24,i
    00741 3085      CPI	R24,5
    00742 F358      BCS	0x072E
(0082)         }
(0083) 		TCNT0=time_0;
    00743 9020 05C9 LDS	R2,time_0
    00745 BE22      OUT	0x32,R2
(0084) 		TCCR0=0x07;
    00746 E087      LDI	R24,7
    00747 BF83      OUT	0x33,R24
(0085) 		return;
    00748 9621      ADIW	R28,1
    00749 9009      LD	R0,Y+
    0074A BE0F      OUT	0x3F,R0
    0074B 91F9      LD	R31,Y+
    0074C 91E9      LD	R30,Y+
    0074D 91B9      LD	R27,Y+
    0074E 91A9      LD	R26,Y+
    0074F 9199      LD	R25,Y+
    00750 9189      LD	R24,Y+
    00751 9139      LD	R19,Y+
    00752 9129      LD	R18,Y+
    00753 9119      LD	R17,Y+
    00754 9109      LD	R16,Y+
    00755 9099      LD	R9,Y+
    00756 9089      LD	R8,Y+
    00757 9079      LD	R7,Y+
    00758 9069      LD	R6,Y+
    00759 9059      LD	R5,Y+
    0075A 9049      LD	R4,Y+
    0075B 9039      LD	R3,Y+
    0075C 9029      LD	R2,Y+
    0075D 9019      LD	R1,Y+
    0075E 9009      LD	R0,Y+
    0075F 9518      RETI
_int_timer1:
    00760 920A      ST	-Y,R0
    00761 921A      ST	-Y,R1
    00762 922A      ST	-Y,R2
    00763 923A      ST	-Y,R3
    00764 924A      ST	-Y,R4
    00765 925A      ST	-Y,R5
    00766 926A      ST	-Y,R6
    00767 927A      ST	-Y,R7
    00768 928A      ST	-Y,R8
    00769 929A      ST	-Y,R9
    0076A 930A      ST	-Y,R16
    0076B 931A      ST	-Y,R17
    0076C 932A      ST	-Y,R18
    0076D 933A      ST	-Y,R19
    0076E 938A      ST	-Y,R24
    0076F 939A      ST	-Y,R25
    00770 93AA      ST	-Y,R26
    00771 93BA      ST	-Y,R27
    00772 93EA      ST	-Y,R30
    00773 93FA      ST	-Y,R31
    00774 B60F      IN	R0,0x3F
    00775 920A      ST	-Y,R0
    00776 9721      SBIW	R28,1
(0086) }
(0087) //溢出中断。
(0088) #pragma interrupt_handler int_timer1:15
(0089) void int_timer1(void){
(0090) 		 TCCR1B=0x00;
    00777 2422      CLR	R2
    00778 BC2E      OUT	0x2E,R2
(0091) 		//adc_init_once();
(0092) 		for(i=0;i<5;i++){
    00779 9220 05C7 STS	i,R2
    0077B C011      RJMP	0x078D
(0093)   		 lcd_write_char(0x03,3,0x30+i);	
    0077C 9180 05C7 LDS	R24,i
    0077E 5D80      SUBI	R24,0xD0
    0077F 8388      ST	Y,R24
    00780 E023      LDI	R18,3
    00781 E003      LDI	R16,3
    00782 940E 03D6 CALL	_lcd_write_char
(0094) 		 delay_ms(100);		
    00784 E604      LDI	R16,0x64
    00785 E010      LDI	R17,0
    00786 940E 007D CALL	_delay_ms
    00788 9180 05C7 LDS	R24,i
    0078A 5F8F      SUBI	R24,0xFF
    0078B 9380 05C7 STS	i,R24
    0078D 9180 05C7 LDS	R24,i
    0078F 3085      CPI	R24,5
    00790 F358      BCS	0x077C
(0095)         }
(0096) 		TCNT1H=time_h_1;
    00791 9020 05CD LDS	R2,time_h_1
    00793 BC2D      OUT	0x2D,R2
(0097)          TCNT1L=time_l_1;
    00794 9020 05CC LDS	R2,time_l_1
    00796 BC2C      OUT	0x2C,R2
(0098) 		 TCCR1B=0x05;
    00797 E085      LDI	R24,5
    00798 BD8E      OUT	0x2E,R24
(0099) 		return;
    00799 9621      ADIW	R28,1
    0079A 9009      LD	R0,Y+
    0079B BE0F      OUT	0x3F,R0
    0079C 91F9      LD	R31,Y+
    0079D 91E9      LD	R30,Y+
    0079E 91B9      LD	R27,Y+
    0079F 91A9      LD	R26,Y+
    007A0 9199      LD	R25,Y+
    007A1 9189      LD	R24,Y+
    007A2 9139      LD	R19,Y+
    007A3 9129      LD	R18,Y+
    007A4 9119      LD	R17,Y+
    007A5 9109      LD	R16,Y+
    007A6 9099      LD	R9,Y+
    007A7 9089      LD	R8,Y+
    007A8 9079      LD	R7,Y+
    007A9 9069      LD	R6,Y+
    007AA 9059      LD	R5,Y+
    007AB 9049      LD	R4,Y+
    007AC 9039      LD	R3,Y+
    007AD 9029      LD	R2,Y+
    007AE 9019      LD	R1,Y+
    007AF 9009      LD	R0,Y+
    007B0 9518      RETI
_int_timer2:
    007B1 920A      ST	-Y,R0
    007B2 921A      ST	-Y,R1
    007B3 922A      ST	-Y,R2
    007B4 923A      ST	-Y,R3
    007B5 924A      ST	-Y,R4
    007B6 925A      ST	-Y,R5
    007B7 926A      ST	-Y,R6
    007B8 927A      ST	-Y,R7
    007B9 928A      ST	-Y,R8
    007BA 929A      ST	-Y,R9
    007BB 930A      ST	-Y,R16
    007BC 931A      ST	-Y,R17
    007BD 932A      ST	-Y,R18
    007BE 933A      ST	-Y,R19
    007BF 938A      ST	-Y,R24
    007C0 939A      ST	-Y,R25
    007C1 93AA      ST	-Y,R26
    007C2 93BA      ST	-Y,R27
    007C3 93EA      ST	-Y,R30
    007C4 93FA      ST	-Y,R31
    007C5 B60F      IN	R0,0x3F
    007C6 920A      ST	-Y,R0
    007C7 9721      SBIW	R28,1
(0100) }
(0101) #pragma interrupt_handler int_timer2:11
(0102) void int_timer2(void){
(0103)       PORTE=~PORTE;
    007C8 B023      IN	R2,0x03
    007C9 9420      COM	R2
    007CA B823      OUT	0x03,R2
(0104) 		TCCR2=0x00;
    007CB 2422      CLR	R2
    007CC BC25      OUT	0x25,R2
(0105) 		for(i=0;i<5;i++){
    007CD 9220 05C7 STS	i,R2
    007CF C011      RJMP	0x07E1
(0106)   		 lcd_write_char(0x00,3,0x30+i);	
    007D0 9180 05C7 LDS	R24,i
    007D2 5D80      SUBI	R24,0xD0
    007D3 8388      ST	Y,R24
    007D4 E023      LDI	R18,3
    007D5 2700      CLR	R16
    007D6 940E 03D6 CALL	_lcd_write_char
(0107) 		 delay_ms(100);		
    007D8 E604      LDI	R16,0x64
    007D9 E010      LDI	R17,0
    007DA 940E 007D CALL	_delay_ms
    007DC 9180 05C7 LDS	R24,i
    007DE 5F8F      SUBI	R24,0xFF
    007DF 9380 05C7 STS	i,R24
    007E1 9180 05C7 LDS	R24,i
    007E3 3085      CPI	R24,5
    007E4 F358      BCS	0x07D0
(0108)         }
(0109) 		TCNT2=time_2;
    007E5 9020 05C8 LDS	R2,time_2
    007E7 BC24      OUT	0x24,R2
(0110) 		TCCR2=0x05;
    007E8 E085      LDI	R24,5
    007E9 BD85      OUT	0x25,R24
(0111) 		return;
    007EA 9621      ADIW	R28,1
    007EB 9009      LD	R0,Y+
    007EC BE0F      OUT	0x3F,R0
    007ED 91F9      LD	R31,Y+
    007EE 91E9      LD	R30,Y+
    007EF 91B9      LD	R27,Y+
    007F0 91A9      LD	R26,Y+
    007F1 9199      LD	R25,Y+
    007F2 9189      LD	R24,Y+
    007F3 9139      LD	R19,Y+
    007F4 9129      LD	R18,Y+
    007F5 9119      LD	R17,Y+
    007F6 9109      LD	R16,Y+
    007F7 9099      LD	R9,Y+
    007F8 9089      LD	R8,Y+
    007F9 9079      LD	R7,Y+
    007FA 9069      LD	R6,Y+
    007FB 9059      LD	R5,Y+
    007FC 9049      LD	R4,Y+
    007FD 9039      LD	R3,Y+
    007FE 9029      LD	R2,Y+
    007FF 9019      LD	R1,Y+
    00800 9009      LD	R0,Y+
    00801 9518      RETI
_int_timer3:
    00802 920A      ST	-Y,R0
    00803 921A      ST	-Y,R1
    00804 922A      ST	-Y,R2
    00805 923A      ST	-Y,R3
    00806 924A      ST	-Y,R4
    00807 925A      ST	-Y,R5
    00808 926A      ST	-Y,R6
    00809 927A      ST	-Y,R7
    0080A 928A      ST	-Y,R8
    0080B 929A      ST	-Y,R9
    0080C 930A      ST	-Y,R16
    0080D 931A      ST	-Y,R17
    0080E 932A      ST	-Y,R18
    0080F 933A      ST	-Y,R19
    00810 938A      ST	-Y,R24
    00811 939A      ST	-Y,R25
    00812 93AA      ST	-Y,R26
    00813 93BA      ST	-Y,R27
    00814 93EA      ST	-Y,R30
    00815 93FA      ST	-Y,R31
    00816 B60F      IN	R0,0x3F
    00817 920A      ST	-Y,R0
    00818 9721      SBIW	R28,1
(0112) }
(0113) //16位定时器，定时器3溢出中断。
(0114) #pragma interrupt_handler int_timer3:30
(0115) void int_timer3(void){
(0116)     TCCR1B=0x00;
    00819 2422      CLR	R2
    0081A BC2E      OUT	0x2E,R2
(0117)      for(i=0;i<5;i++){
    0081B 9220 05C7 STS	i,R2
    0081D C011      RJMP	0x082F
(0118)   		 lcd_write_char(0x02,3,0x30+i);	
    0081E 9180 05C7 LDS	R24,i
    00820 5D80      SUBI	R24,0xD0
    00821 8388      ST	Y,R24
    00822 E023      LDI	R18,3
    00823 E002      LDI	R16,2
    00824 940E 03D6 CALL	_lcd_write_char
(0119) 		 delay_ms(100);		
    00826 E604      LDI	R16,0x64
    00827 E010      LDI	R17,0
    00828 940E 007D CALL	_delay_ms
    0082A 9180 05C7 LDS	R24,i
    0082C 5F8F      SUBI	R24,0xFF
    0082D 9380 05C7 STS	i,R24
    0082F 9180 05C7 LDS	R24,i
    00831 3085      CPI	R24,5
    00832 F358      BCS	0x081E
(0120)         }
(0121) 	TCNT3H=time_h_3;
    00833 9020 05CB LDS	R2,time_h_3
    00835 9220 0089 STS	0x89,R2
(0122)     TCNT3L=time_l_3;
    00837 9020 05CA LDS	R2,time_l_3
    00839 9220 0088 STS	0x88,R2
(0123) 	 TCCR1B=0x05;
    0083B E085      LDI	R24,5
    0083C BD8E      OUT	0x2E,R24
    0083D 9621      ADIW	R28,1
    0083E 9009      LD	R0,Y+
    0083F BE0F      OUT	0x3F,R0
    00840 91F9      LD	R31,Y+
    00841 91E9      LD	R30,Y+
    00842 91B9      LD	R27,Y+
    00843 91A9      LD	R26,Y+
    00844 9199      LD	R25,Y+
    00845 9189      LD	R24,Y+
    00846 9139      LD	R19,Y+
    00847 9129      LD	R18,Y+
    00848 9119      LD	R17,Y+
    00849 9109      LD	R16,Y+
    0084A 9099      LD	R9,Y+
    0084B 9089      LD	R8,Y+
    0084C 9079      LD	R7,Y+
    0084D 9069      LD	R6,Y+
    0084E 9059      LD	R5,Y+
    0084F 9049      LD	R4,Y+
    00850 9039      LD	R3,Y+
    00851 9029      LD	R2,Y+
    00852 9019      LD	R1,Y+
    00853 9009      LD	R0,Y+
    00854 9518      RETI
_readTemp_1:
  i                    --> R20
    00855 934A      ST	-Y,R20
    00856 935A      ST	-Y,R21
FILE: E:\ICCDemo\Temp_Control\temp_control\max6675.c
(0001) #include<iom128v.h>
(0002) #include "max6675.h"
(0003) #include "main.h"
(0004) #include "delay.h"
(0005) #define sck_h_1 PORTE|=(1<<PE3) 
(0006) #define sck_l_1 PORTE&=~(1<<PE3) 
(0007) #define cs_h_1 PORTE|=1<<PE4 
(0008) #define cs_l_1 PORTE&=~(1<<PE4) 
(0009) 
(0010) #define sck_h_2 PORTE|=(1<<PE6) 
(0011) #define sck_l_2 PORTE&=~(1<<PE6) 
(0012) #define cs_h_2 PORTE|=1<<PE7 
(0013) #define cs_l_2 PORTE&=~(1<<PE7) 
(0014) 
(0015) #define sck_h_3 PORTF|=(1<<PF0) 
(0016) #define sck_l_3 PORTF&=~(1<<PF0) 
(0017) #define cs_h_3 PORTF|=1<<PF2 
(0018) #define cs_l_3 PORTF&=~(1<<PF2) 
(0019) 
(0020) #define sck_h_4 PORTF|=(1<<PF4) 
(0021) #define sck_l_4 PORTF&=~(1<<PF4) 
(0022) #define cs_h_4 PORTF|=1<<PF5 
(0023) #define cs_l_4 PORTF&=~(1<<PF5) 
(0024) /*
(0025) 仿真中没有读出数据，也没有实物
(0026) 
(0027) */
(0028) void readTemp_1(void){
(0029) 	   uint i;
(0030) 	   DDRE&=0xFB;
    00857 B182      IN	R24,0x02
    00858 7F8B      ANDI	R24,0xFB
    00859 B982      OUT	0x02,R24
(0031) 	   sck_l_1;
    0085A 981B      CBI	0x03,3
(0032) 	   cs_l_1;
    0085B 981C      CBI	0x03,4
(0033) 	   delay_us(1);
    0085C E001      LDI	R16,1
    0085D E010      LDI	R17,0
    0085E 940E 0073 CALL	_delay_us
(0034) 	   for(i=0;i<8;i++){
    00860 2744      CLR	R20
    00861 2755      CLR	R21
    00862 C020      RJMP	0x0883
(0035) 			sck_h_1;
    00863 9A1B      SBI	0x03,3
(0036) 			delay_us(10);
    00864 E00A      LDI	R16,0xA
    00865 E010      LDI	R17,0
    00866 940E 0073 CALL	_delay_us
(0037) 	    	temp_h=temp_h|(PINE&0x04);
    00868 B181      IN	R24,0x01
    00869 2799      CLR	R25
    0086A 7084      ANDI	R24,4
    0086B 7090      ANDI	R25,0
    0086C 9020 010F LDS	R2,temp_h
    0086E 9030 0110 LDS	R3,temp_h+1
    00870 2A28      OR	R2,R24
    00871 2A39      OR	R3,R25
    00872 9230 0110 STS	temp_h+1,R3
    00874 9220 010F STS	temp_h,R2
(0038) 			temp_h<<=1;
    00876 0C22      LSL	R2
    00877 1C33      ROL	R3
    00878 9230 0110 STS	temp_h+1,R3
    0087A 9220 010F STS	temp_h,R2
(0039) 			sck_l_1;
    0087C 981B      CBI	0x03,3
(0040) 			delay_us(1);
    0087D E001      LDI	R16,1
    0087E E010      LDI	R17,0
    0087F 940E 0073 CALL	_delay_us
    00881 5F4F      SUBI	R20,0xFF
    00882 4F5F      SBCI	R21,0xFF
    00883 3048      CPI	R20,0x8
    00884 E0E0      LDI	R30,0
    00885 075E      CPC	R21,R30
    00886 F2E0      BCS	0x0863
(0041) 			
(0042) 	   }
(0043) 	   for(i=0;i<8;i++){
    00887 2744      CLR	R20
    00888 2755      CLR	R21
    00889 C022      RJMP	0x08AC
(0044) 			sck_h_1;
    0088A 9A1B      SBI	0x03,3
(0045) 			delay_us(10);
    0088B E00A      LDI	R16,0xA
    0088C E010      LDI	R17,0
    0088D 940E 0073 CALL	_delay_us
(0046) 	    	temp_l=temp_l|(PINE&0x04);
    0088F B181      IN	R24,0x01
    00890 2799      CLR	R25
    00891 7084      ANDI	R24,4
    00892 7090      ANDI	R25,0
    00893 9020 0111 LDS	R2,temp_l
    00895 9030 0112 LDS	R3,temp_l+1
    00897 2A28      OR	R2,R24
    00898 2A39      OR	R3,R25
    00899 9230 0112 STS	temp_l+1,R3
    0089B 9220 0111 STS	temp_l,R2
(0047) 			temp_l<<=temp_l;
    0089D 0191      MOVW	R18,R2
    0089E 0181      MOVW	R16,R2
    0089F 940E 0BEA CALL	lsl16
    008A1 9310 0112 STS	temp_l+1,R17
    008A3 9300 0111 STS	temp_l,R16
(0048) 			sck_l_1;
    008A5 981B      CBI	0x03,3
(0049) 			delay_us(1);
    008A6 E001      LDI	R16,1
    008A7 E010      LDI	R17,0
    008A8 940E 0073 CALL	_delay_us
    008AA 5F4F      SUBI	R20,0xFF
    008AB 4F5F      SBCI	R21,0xFF
    008AC 3048      CPI	R20,0x8
    008AD E0E0      LDI	R30,0
    008AE 075E      CPC	R21,R30
    008AF F2D0      BCS	0x088A
(0050) 	   }
(0051) 	   delay_us(1);
    008B0 E001      LDI	R16,1
    008B1 E010      LDI	R17,0
    008B2 940E 0073 CALL	_delay_us
(0052) 	  // temp_l=0x55;
(0053) 	   return ;
    008B4 9159      LD	R21,Y+
    008B5 9149      LD	R20,Y+
    008B6 9508      RET
_readTemp_2:
  i                    --> R20
    008B7 934A      ST	-Y,R20
    008B8 935A      ST	-Y,R21
(0054) }
(0055) void readTemp_2(void){
(0056) 	   uint i;
(0057) 	   DDRE&=0xDF;
    008B9 B182      IN	R24,0x02
    008BA 7D8F      ANDI	R24,0xDF
    008BB B982      OUT	0x02,R24
(0058) 	   sck_l_2;
    008BC 981E      CBI	0x03,6
(0059) 	   cs_l_2;
    008BD 981F      CBI	0x03,7
(0060) 	   delay_us(1);
    008BE E001      LDI	R16,1
    008BF E010      LDI	R17,0
    008C0 940E 0073 CALL	_delay_us
(0061) 	   for(i=0;i<8;i++){
    008C2 2744      CLR	R20
    008C3 2755      CLR	R21
    008C4 C020      RJMP	0x08E5
(0062) 			sck_h_2;
    008C5 9A1E      SBI	0x03,6
(0063) 			delay_us(10);
    008C6 E00A      LDI	R16,0xA
    008C7 E010      LDI	R17,0
    008C8 940E 0073 CALL	_delay_us
(0064) 	    	temp_h=temp_h|(PINE&0x20);
    008CA B181      IN	R24,0x01
    008CB 2799      CLR	R25
    008CC 7280      ANDI	R24,0x20
    008CD 7090      ANDI	R25,0
    008CE 9020 010F LDS	R2,temp_h
    008D0 9030 0110 LDS	R3,temp_h+1
    008D2 2A28      OR	R2,R24
    008D3 2A39      OR	R3,R25
    008D4 9230 0110 STS	temp_h+1,R3
    008D6 9220 010F STS	temp_h,R2
(0065) 			temp_h<<=1;
    008D8 0C22      LSL	R2
    008D9 1C33      ROL	R3
    008DA 9230 0110 STS	temp_h+1,R3
    008DC 9220 010F STS	temp_h,R2
(0066) 			sck_l_2;
    008DE 981E      CBI	0x03,6
(0067) 			delay_us(1);
    008DF E001      LDI	R16,1
    008E0 E010      LDI	R17,0
    008E1 940E 0073 CALL	_delay_us
    008E3 5F4F      SUBI	R20,0xFF
    008E4 4F5F      SBCI	R21,0xFF
    008E5 3048      CPI	R20,0x8
    008E6 E0E0      LDI	R30,0
    008E7 075E      CPC	R21,R30
    008E8 F2E0      BCS	0x08C5
(0068) 			
(0069) 	   }
(0070) 	   for(i=0;i<8;i++){
    008E9 2744      CLR	R20
    008EA 2755      CLR	R21
    008EB C022      RJMP	0x090E
(0071) 			sck_h_2;
    008EC 9A1E      SBI	0x03,6
(0072) 			delay_us(10);
    008ED E00A      LDI	R16,0xA
    008EE E010      LDI	R17,0
    008EF 940E 0073 CALL	_delay_us
(0073) 	    	temp_l=temp_l|(PINE&0x20);
    008F1 B181      IN	R24,0x01
    008F2 2799      CLR	R25
    008F3 7280      ANDI	R24,0x20
    008F4 7090      ANDI	R25,0
    008F5 9020 0111 LDS	R2,temp_l
    008F7 9030 0112 LDS	R3,temp_l+1
    008F9 2A28      OR	R2,R24
    008FA 2A39      OR	R3,R25
    008FB 9230 0112 STS	temp_l+1,R3
    008FD 9220 0111 STS	temp_l,R2
(0074) 			temp_l<<=temp_l;
    008FF 0191      MOVW	R18,R2
    00900 0181      MOVW	R16,R2
    00901 940E 0BEA CALL	lsl16
    00903 9310 0112 STS	temp_l+1,R17
    00905 9300 0111 STS	temp_l,R16
(0075) 			sck_l_2;
    00907 981E      CBI	0x03,6
(0076) 			delay_us(1);
    00908 E001      LDI	R16,1
    00909 E010      LDI	R17,0
    0090A 940E 0073 CALL	_delay_us
    0090C 5F4F      SUBI	R20,0xFF
    0090D 4F5F      SBCI	R21,0xFF
    0090E 3048      CPI	R20,0x8
    0090F E0E0      LDI	R30,0
    00910 075E      CPC	R21,R30
    00911 F2D0      BCS	0x08EC
(0077) 	   }
(0078) 	   delay_us(1);
    00912 E001      LDI	R16,1
    00913 E010      LDI	R17,0
    00914 940E 0073 CALL	_delay_us
(0079) 	  // temp_l=0x55;
(0080) 	   return ;
    00916 9159      LD	R21,Y+
    00917 9149      LD	R20,Y+
    00918 9508      RET
_readTemp_3:
  i                    --> R20
    00919 934A      ST	-Y,R20
    0091A 935A      ST	-Y,R21
(0081) }
(0082) void readTemp_3(void){
(0083) 	   uint i;
(0084) 	   DDRF&=0xFE;
    0091B 9180 0061 LDS	R24,0x61
    0091D 7F8E      ANDI	R24,0xFE
    0091E 9380 0061 STS	0x61,R24
(0085) 	   sck_l_3;
    00920 9180 0062 LDS	R24,0x62
    00922 7F8E      ANDI	R24,0xFE
    00923 9380 0062 STS	0x62,R24
(0086) 	   cs_l_3;
    00925 9180 0062 LDS	R24,0x62
    00927 7F8B      ANDI	R24,0xFB
    00928 9380 0062 STS	0x62,R24
(0087) 	   delay_us(1);
    0092A E001      LDI	R16,1
    0092B E010      LDI	R17,0
    0092C 940E 0073 CALL	_delay_us
(0088) 	   for(i=0;i<8;i++){
    0092E 2744      CLR	R20
    0092F 2755      CLR	R21
    00930 C028      RJMP	0x0959
(0089) 			sck_h_3;
    00931 9180 0062 LDS	R24,0x62
    00933 6081      ORI	R24,1
    00934 9380 0062 STS	0x62,R24
(0090) 			delay_us(10);
    00936 E00A      LDI	R16,0xA
    00937 E010      LDI	R17,0
    00938 940E 0073 CALL	_delay_us
(0091) 	    	temp_h=temp_h|(PINF&0x01);
    0093A B180      IN	R24,0x00
    0093B 2799      CLR	R25
    0093C 7081      ANDI	R24,1
    0093D 7090      ANDI	R25,0
    0093E 9020 010F LDS	R2,temp_h
    00940 9030 0110 LDS	R3,temp_h+1
    00942 2A28      OR	R2,R24
    00943 2A39      OR	R3,R25
    00944 9230 0110 STS	temp_h+1,R3
    00946 9220 010F STS	temp_h,R2
(0092) 			temp_h<<=1;
    00948 0C22      LSL	R2
    00949 1C33      ROL	R3
    0094A 9230 0110 STS	temp_h+1,R3
    0094C 9220 010F STS	temp_h,R2
(0093) 			sck_l_3;
    0094E 9180 0062 LDS	R24,0x62
    00950 7F8E      ANDI	R24,0xFE
    00951 9380 0062 STS	0x62,R24
(0094) 			delay_us(1);
    00953 E001      LDI	R16,1
    00954 E010      LDI	R17,0
    00955 940E 0073 CALL	_delay_us
    00957 5F4F      SUBI	R20,0xFF
    00958 4F5F      SBCI	R21,0xFF
    00959 3048      CPI	R20,0x8
    0095A E0E0      LDI	R30,0
    0095B 075E      CPC	R21,R30
    0095C F2A0      BCS	0x0931
(0095) 			
(0096) 	   }
(0097) 	   for(i=0;i<8;i++){
    0095D 2744      CLR	R20
    0095E 2755      CLR	R21
    0095F C02A      RJMP	0x098A
(0098) 			sck_h_3;
    00960 9180 0062 LDS	R24,0x62
    00962 6081      ORI	R24,1
    00963 9380 0062 STS	0x62,R24
(0099) 			delay_us(10);
    00965 E00A      LDI	R16,0xA
    00966 E010      LDI	R17,0
    00967 940E 0073 CALL	_delay_us
(0100) 	    	temp_l=temp_l|(PINF&0x01);
    00969 B180      IN	R24,0x00
    0096A 2799      CLR	R25
    0096B 7081      ANDI	R24,1
    0096C 7090      ANDI	R25,0
    0096D 9020 0111 LDS	R2,temp_l
    0096F 9030 0112 LDS	R3,temp_l+1
    00971 2A28      OR	R2,R24
    00972 2A39      OR	R3,R25
    00973 9230 0112 STS	temp_l+1,R3
    00975 9220 0111 STS	temp_l,R2
(0101) 			temp_l<<=temp_l;
    00977 0191      MOVW	R18,R2
    00978 0181      MOVW	R16,R2
    00979 940E 0BEA CALL	lsl16
    0097B 9310 0112 STS	temp_l+1,R17
    0097D 9300 0111 STS	temp_l,R16
(0102) 			sck_l_3;
    0097F 9180 0062 LDS	R24,0x62
    00981 7F8E      ANDI	R24,0xFE
    00982 9380 0062 STS	0x62,R24
(0103) 			delay_us(1);
    00984 E001      LDI	R16,1
    00985 E010      LDI	R17,0
    00986 940E 0073 CALL	_delay_us
    00988 5F4F      SUBI	R20,0xFF
    00989 4F5F      SBCI	R21,0xFF
    0098A 3048      CPI	R20,0x8
    0098B E0E0      LDI	R30,0
    0098C 075E      CPC	R21,R30
    0098D F290      BCS	0x0960
(0104) 	   }
(0105) 	   delay_us(1);
    0098E E001      LDI	R16,1
    0098F E010      LDI	R17,0
    00990 940E 0073 CALL	_delay_us
(0106) 	  // temp_l=0x55;
(0107) 	   return ;
    00992 9159      LD	R21,Y+
    00993 9149      LD	R20,Y+
    00994 9508      RET
_readTemp_4:
  i                    --> R20
    00995 934A      ST	-Y,R20
    00996 935A      ST	-Y,R21
(0108) }
(0109) void readTemp_4(void){
(0110) 	   uint i;
(0111) 	   DDRF&=0xF7;
    00997 9180 0061 LDS	R24,0x61
    00999 7F87      ANDI	R24,0xF7
    0099A 9380 0061 STS	0x61,R24
(0112) 	   sck_l_4;
    0099C 9180 0062 LDS	R24,0x62
    0099E 7E8F      ANDI	R24,0xEF
    0099F 9380 0062 STS	0x62,R24
(0113) 	   cs_l_4;
    009A1 9180 0062 LDS	R24,0x62
    009A3 7D8F      ANDI	R24,0xDF
    009A4 9380 0062 STS	0x62,R24
(0114) 	   delay_us(1);
    009A6 E001      LDI	R16,1
    009A7 E010      LDI	R17,0
    009A8 940E 0073 CALL	_delay_us
(0115) 	   for(i=0;i<8;i++){
    009AA 2744      CLR	R20
    009AB 2755      CLR	R21
    009AC C028      RJMP	0x09D5
(0116) 			sck_h_4;
    009AD 9180 0062 LDS	R24,0x62
    009AF 6180      ORI	R24,0x10
    009B0 9380 0062 STS	0x62,R24
(0117) 			delay_us(10);
    009B2 E00A      LDI	R16,0xA
    009B3 E010      LDI	R17,0
    009B4 940E 0073 CALL	_delay_us
(0118) 	    	temp_h=temp_h|(PINF&0x80);
    009B6 B180      IN	R24,0x00
    009B7 2799      CLR	R25
    009B8 7880      ANDI	R24,0x80
    009B9 7090      ANDI	R25,0
    009BA 9020 010F LDS	R2,temp_h
    009BC 9030 0110 LDS	R3,temp_h+1
    009BE 2A28      OR	R2,R24
    009BF 2A39      OR	R3,R25
    009C0 9230 0110 STS	temp_h+1,R3
    009C2 9220 010F STS	temp_h,R2
(0119) 			temp_h<<=1;
    009C4 0C22      LSL	R2
    009C5 1C33      ROL	R3
    009C6 9230 0110 STS	temp_h+1,R3
    009C8 9220 010F STS	temp_h,R2
(0120) 			sck_l_4;
    009CA 9180 0062 LDS	R24,0x62
    009CC 7E8F      ANDI	R24,0xEF
    009CD 9380 0062 STS	0x62,R24
(0121) 			delay_us(1);
    009CF E001      LDI	R16,1
    009D0 E010      LDI	R17,0
    009D1 940E 0073 CALL	_delay_us
    009D3 5F4F      SUBI	R20,0xFF
    009D4 4F5F      SBCI	R21,0xFF
    009D5 3048      CPI	R20,0x8
    009D6 E0E0      LDI	R30,0
    009D7 075E      CPC	R21,R30
    009D8 F2A0      BCS	0x09AD
(0122) 			
(0123) 	   }
(0124) 	   for(i=0;i<8;i++){
    009D9 2744      CLR	R20
    009DA 2755      CLR	R21
    009DB C02A      RJMP	0x0A06
(0125) 			sck_h_4;
    009DC 9180 0062 LDS	R24,0x62
    009DE 6180      ORI	R24,0x10
    009DF 9380 0062 STS	0x62,R24
(0126) 			delay_us(10);
    009E1 E00A      LDI	R16,0xA
    009E2 E010      LDI	R17,0
    009E3 940E 0073 CALL	_delay_us
(0127) 	    	temp_l=temp_l|(PINF&0x80);
    009E5 B180      IN	R24,0x00
    009E6 2799      CLR	R25
    009E7 7880      ANDI	R24,0x80
    009E8 7090      ANDI	R25,0
    009E9 9020 0111 LDS	R2,temp_l
    009EB 9030 0112 LDS	R3,temp_l+1
    009ED 2A28      OR	R2,R24
    009EE 2A39      OR	R3,R25
    009EF 9230 0112 STS	temp_l+1,R3
    009F1 9220 0111 STS	temp_l,R2
(0128) 			temp_l<<=temp_l;
    009F3 0191      MOVW	R18,R2
    009F4 0181      MOVW	R16,R2
    009F5 940E 0BEA CALL	lsl16
    009F7 9310 0112 STS	temp_l+1,R17
    009F9 9300 0111 STS	temp_l,R16
(0129) 			sck_l_4;
    009FB 9180 0062 LDS	R24,0x62
    009FD 7E8F      ANDI	R24,0xEF
    009FE 9380 0062 STS	0x62,R24
(0130) 			delay_us(1);
    00A00 E001      LDI	R16,1
    00A01 E010      LDI	R17,0
    00A02 940E 0073 CALL	_delay_us
    00A04 5F4F      SUBI	R20,0xFF
    00A05 4F5F      SBCI	R21,0xFF
    00A06 3048      CPI	R20,0x8
    00A07 E0E0      LDI	R30,0
    00A08 075E      CPC	R21,R30
    00A09 F290      BCS	0x09DC
(0131) 	   }
(0132) 	   delay_us(1);
    00A0A E001      LDI	R16,1
    00A0B E010      LDI	R17,0
    00A0C 940E 0073 CALL	_delay_us
(0133) 	  // temp_l=0x55;
(0134) 	   return ;
    00A0E 9159      LD	R21,Y+
    00A0F 9149      LD	R20,Y+
    00A10 9508      RET
(0135) }
(0136) uchar readOC(void){
(0137) 	  DDRD&=0x07;
_readOC:
    00A11 B381      IN	R24,0x11
    00A12 7087      ANDI	R24,7
    00A13 BB81      OUT	0x11,R24
(0138) 	  return PIND&(0xF8);
    00A14 B300      IN	R16,0x10
    00A15 7F08      ANDI	R16,0xF8
    00A16 9508      RET
FILE: E:\ICCDemo\Temp_Control\temp_control\out.c
(0001) #include<iom128v.h>
(0002) #include "out.h"
(0003) 
(0004) void out_all(uchar out){
(0005)   DDRC=0xFF;
_out_all:
  out                  --> R16
    00A17 EF8F      LDI	R24,0xFF
    00A18 BB84      OUT	0x14,R24
(0006)   PORTC=out;
    00A19 BB05      OUT	0x15,R16
    00A1A 9508      RET
_out_port:
  port                 --> R10
  out                  --> R20
    00A1B 940E 0BB2 CALL	push_xgset300C
    00A1D 0159      MOVW	R10,R18
    00A1E 01A8      MOVW	R20,R16
(0007) }
(0008) //0、1的传入。port由0~7
(0009) void out_port(uint out,uint port){
(0010)   DDRC=0xFF;
    00A1F EF8F      LDI	R24,0xFF
    00A20 BB84      OUT	0x14,R24
(0011)   if(out==0){
    00A21 3040      CPI	R20,0
    00A22 0745      CPC	R20,R21
    00A23 F471      BNE	0x0A32
(0012)    PORTC&=~(1<<port);
    00A24 E001      LDI	R16,1
    00A25 E010      LDI	R17,0
    00A26 0195      MOVW	R18,R10
    00A27 940E 0BEA CALL	lsl16
    00A29 0118      MOVW	R2,R16
    00A2A 9420      COM	R2
    00A2B 9430      COM	R3
    00A2C B245      IN	R4,0x15
    00A2D 2455      CLR	R5
    00A2E 2042      AND	R4,R2
    00A2F 2053      AND	R5,R3
    00A30 BA45      OUT	0x15,R4
(0013)   }else if(out==1){
    00A31 C00E      RJMP	0x0A40
    00A32 3041      CPI	R20,1
    00A33 E0E0      LDI	R30,0
    00A34 075E      CPC	R21,R30
    00A35 F451      BNE	0x0A40
(0014)    PORTC|=(1<<port);
    00A36 E001      LDI	R16,1
    00A37 E010      LDI	R17,0
    00A38 0195      MOVW	R18,R10
    00A39 940E 0BEA CALL	lsl16
    00A3B B225      IN	R2,0x15
    00A3C 2433      CLR	R3
    00A3D 2A20      OR	R2,R16
    00A3E 2A31      OR	R3,R17
    00A3F BA25      OUT	0x15,R2
(0015)   }
    00A40 940C 0BB7 JMP	pop_xgset300C
_read_port:
  port                 --> R10
    00A42 92AA      ST	-Y,R10
    00A43 92BA      ST	-Y,R11
    00A44 0158      MOVW	R10,R16
(0016) }
(0017) uint read_port(uint port){
(0018)   return PINC&(1<<port);
    00A45 E001      LDI	R16,1
    00A46 E010      LDI	R17,0
    00A47 0195      MOVW	R18,R10
    00A48 940E 0BEA CALL	lsl16
    00A4A B223      IN	R2,0x13
    00A4B 2433      CLR	R3
    00A4C 2220      AND	R2,R16
    00A4D 2231      AND	R3,R17
    00A4E 0181      MOVW	R16,R2
    00A4F 90B9      LD	R11,Y+
    00A50 90A9      LD	R10,Y+
    00A51 9508      RET
FILE: E:\ICCDemo\Temp_Control\temp_control\uart.c
(0001) #include <iom128v.h>
(0002) #include "uart.h"
(0003) 
(0004) //常量定义
(0005) #define BAUDRATE1       115200	//波特率
(0006) //#define BAUDRATE2       9600	//波特率
(0007) #define F_CPU		7372800//晶振频率
(0008) 
(0009) //变量定义
(0010) extern unsigned char send_buf[600];
(0011) extern unsigned char receive_buf[600];
(0012) extern unsigned int send_len;
(0013) extern unsigned int receive_len;
(0014) 
(0015) unsigned char uart_timeout_flag1;
(0016) unsigned char uart_timeout_flag2;
(0017) 
(0018) //串口1对应程序
(0019) ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
(0020) //USART 初始化
(0021) void init_USART1(void)
(0022) {
(0023)     //USART 115200 8, n,1  PC上位机软件(超级终端等)也要设成同样的设置才能通讯
(0024)     UCSR0C = (1<<USBS0)|(3<<UCSZ00);
_init_USART1:
    00A52 E08E      LDI	R24,0xE
    00A53 9380 0095 STS	0x95,R24
(0025)     
(0026)   //异步，8位数据，无奇偶校验，一个停止位，无倍速   
(0027)     //U2X=0时的公式计算
(0028)     UBRR0L= (F_CPU/BAUDRATE1/16-1)%256;
    00A55 E083      LDI	R24,3
    00A56 B989      OUT	0x09,R24
(0029)     UBRR0H= (F_CPU/BAUDRATE1/16-1)/256;
    00A57 2422      CLR	R2
    00A58 9220 0090 STS	0x90,R2
(0030) 
(0031)     UCSR0A = 0x00;
    00A5A B82B      OUT	0x0B,R2
(0032) 
(0033)     //使能接收中断，使能接收，使能发送
(0034)     UCSR0B = (1<<RXEN0)|(1<<TXEN0);
    00A5B E188      LDI	R24,0x18
    00A5C B98A      OUT	0x0A,R24
    00A5D 9508      RET
(0035)     
(0036) }
(0037) 
(0038) //向串口1写数
(0039) void put_c1(unsigned char c)
(0040) {
(0041) 	while( !(UCSR0A & (1<<UDRE0)) );
_put_c1:
  c                    --> R16
    00A5E 9B5D      SBIS	0x0B,5
    00A5F CFFE      RJMP	_put_c1
(0042) 	UDR0=c;	
    00A60 B90C      OUT	0x0C,R16
    00A61 9508      RET
(0043) }
(0044) 
(0045) //从串口1读数
(0046) unsigned char USART_Receive1( void )
(0047) {
(0048)    unsigned int j=0;
_USART_Receive1:
  j                    --> R16
    00A62 2700      CLR	R16
    00A63 2711      CLR	R17
(0049)    uart_timeout_flag1=0; 
    00A64 2422      CLR	R2
    00A65 9220 05CF STS	uart_timeout_flag1,R2
    00A67 C00B      RJMP	0x0A73
(0050)   //等待接受标志
(0051)   while ( !(UCSR0A & (1<<RXC0)) ){
(0052)     if(j==32000) //判断超时，并设置标志
    00A68 3000      CPI	R16,0
    00A69 E7ED      LDI	R30,0x7D
    00A6A 071E      CPC	R17,R30
    00A6B F429      BNE	0x0A71
(0053)     { uart_timeout_flag1=1;   
    00A6C E081      LDI	R24,1
    00A6D 9380 05CF STS	uart_timeout_flag1,R24
(0054)     return FAILURE;}
    00A6F E001      LDI	R16,1
    00A70 C005      RJMP	0x0A76
(0055) 	else 
(0056) 		j++;
    00A71 5F0F      SUBI	R16,0xFF
    00A72 4F1F      SBCI	R17,0xFF
    00A73 9B5F      SBIS	0x0B,7
    00A74 CFF3      RJMP	0x0A68
(0057)     ;}
(0058)   //读接收数据  
(0059)   return UDR0;
    00A75 B10C      IN	R16,0x0C
    00A76 9508      RET
_receiveStrfromCom:
  k                    --> R20
    00A77 92AA      ST	-Y,R10
    00A78 934A      ST	-Y,R20
(0060) }
(0061) 
(0062) //从串口接收数据串
(0063) unsigned char receiveStrfromCom(void)
(0064) {
    00A79 C03E      RJMP	0x0AB8
(0065)   unsigned char k;
(0066) 
(0067)   while(1)
(0068)   {
(0069)     ///以下为从串口接收数据的过程
(0070)     send_buf[0]=USART_Receive1();
    00A7A DFE7      RCALL	_USART_Receive1
    00A7B 9300 036F STS	send_buf,R16
(0071)     //若接收的不是命令头则继续等待
(0072)     if(send_buf[0]!=0x02)continue;
    00A7D 3002      CPI	R16,2
    00A7E F009      BEQ	0x0A80
    00A7F C038      RJMP	0x0AB8
(0073)       
(0074)     for(k=1;k<5;k++)
    00A80 E041      LDI	R20,1
    00A81 C00F      RJMP	0x0A91
(0075)     {
(0076)         send_buf[k]=USART_Receive1(); 
    00A82 DFDF      RCALL	_USART_Receive1
    00A83 E68F      LDI	R24,0x6F
    00A84 E093      LDI	R25,3
    00A85 2FE4      MOV	R30,R20
    00A86 27FF      CLR	R31
    00A87 0FE8      ADD	R30,R24
    00A88 1FF9      ADC	R31,R25
    00A89 8300      ST	Z,R16
(0077)         if(uart_timeout_flag1==1)
    00A8A 9180 05CF LDS	R24,uart_timeout_flag1
    00A8C 3081      CPI	R24,1
    00A8D F411      BNE	0x0A90
(0078)         {  
(0079) //          ComSendResponse(send_buf[3],EXE_TIME_OUT,1);
(0080)           return FAILURE;
    00A8E E001      LDI	R16,1
    00A8F C029      RJMP	0x0AB9
    00A90 9543      INC	R20
    00A91 3045      CPI	R20,5
    00A92 F378      BCS	0x0A82
(0081)         }  
(0082)     }
(0083)     
(0084)     send_len=send_buf[4];
    00A93 9020 0373 LDS	R2,send_buf+4
    00A95 2433      CLR	R3
    00A96 9230 0116 STS	send_len+1,R3
    00A98 9220 0115 STS	send_len,R2
(0085)     
(0086)     for(k=5;k<send_len+6;k++)
    00A9A E045      LDI	R20,5
    00A9B C010      RJMP	0x0AAC
(0087)     {
(0088)         send_buf[k]=USART_Receive1(); 
    00A9C DFC5      RCALL	_USART_Receive1
    00A9D 2EA0      MOV	R10,R16
    00A9E E68F      LDI	R24,0x6F
    00A9F E093      LDI	R25,3
    00AA0 2FE4      MOV	R30,R20
    00AA1 27FF      CLR	R31
    00AA2 0FE8      ADD	R30,R24
    00AA3 1FF9      ADC	R31,R25
    00AA4 82A0      ST	Z,R10
(0089)         if(uart_timeout_flag1==1)
    00AA5 9180 05CF LDS	R24,uart_timeout_flag1
    00AA7 3081      CPI	R24,1
    00AA8 F411      BNE	0x0AAB
(0090)         {  
(0091) //           ComSendResponse(send_buf[3],EXE_TIME_OUT,1);
(0092)            return FAILURE; 
    00AA9 E001      LDI	R16,1
    00AAA C00E      RJMP	0x0AB9
    00AAB 9543      INC	R20
    00AAC 9180 0115 LDS	R24,send_len
    00AAE 9190 0116 LDS	R25,send_len+1
    00AB0 9606      ADIW	R24,6
    00AB1 2E24      MOV	R2,R20
    00AB2 2433      CLR	R3
    00AB3 1628      CP	R2,R24
    00AB4 0639      CPC	R3,R25
    00AB5 F330      BCS	0x0A9C
(0093)         }  
(0094)     }  
(0095)     return SUCCESS;
    00AB6 2700      CLR	R16
    00AB7 C001      RJMP	0x0AB9
    00AB8 CFC1      RJMP	0x0A7A
    00AB9 9149      LD	R20,Y+
    00ABA 90A9      LD	R10,Y+
    00ABB 9508      RET
_outStrtoCom:
  i                    --> R10
  length               --> R12
  pData                --> R14
    00ABC 940E 0BAB CALL	push_xgset00FC
    00ABE 0169      MOVW	R12,R18
    00ABF 0178      MOVW	R14,R16
(0096) 
(0097)   }  
(0098)   return FAILURE;
(0099) } 
(0100) 
(0101) //向串口输出数据串
(0102) void outStrtoCom(unsigned char *pData,unsigned int length)
(0103) {
(0104) 	unsigned char i;
(0105) 	for(i=0;i<length;i++)
    00AC0 24AA      CLR	R10
    00AC1 C007      RJMP	0x0AC9
(0106) 		put_c1(pData[i]);
    00AC2 2DEA      MOV	R30,R10
    00AC3 27FF      CLR	R31
    00AC4 0DEE      ADD	R30,R14
    00AC5 1DFF      ADC	R31,R15
    00AC6 8100      LD	R16,Z
    00AC7 DF96      RCALL	_put_c1
    00AC8 94A3      INC	R10
    00AC9 2C2A      MOV	R2,R10
    00ACA 2433      CLR	R3
    00ACB 142C      CP	R2,R12
    00ACC 043D      CPC	R3,R13
    00ACD F3A0      BCS	0x0AC2
    00ACE 940C 0B8C JMP	pop_xgset00FC
_MAC_CalCrc16:
  i                    --> R10
  j                    --> R22
  value_CRC            --> R20
  ucLen                --> R12
  pCrc16               --> R18
  pInput               --> R16
    00AD0 940E 0BD8 CALL	push_xgsetF03C
    00AD2 84C8      LDD	R12,Y+8
(0107) }
(0108) /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
(0109) 
(0110) /*-----------------------------------------------
(0111) 函数名： 　MAC_CalCrc16
(0112) 功  能：  以字节为单位计算len个数的CRC16校验和，首字节
(0113) 		  为pInput[0].
(0114) 参  数：  pInput			为需要计算CRC的数据的指针
(0115)           pCrc16			为指向存储CRC值的数组
(0116)           ucLen				为需要计算CRC的数据长度
(0117) 返回值：　无　
(0118) 作  者：　lz
(0119) 日  期：  2008-06-18
(0120) ------------------------------------------------*/
(0121) void MAC_CalCrc16(unsigned char  *pInput, unsigned char * pCrc16, unsigned char ucLen)   
(0122) {   
(0123)     unsigned int value_CRC=0xffff;
    00AD3 EF4F      LDI	R20,0xFF
    00AD4 EF5F      LDI	R21,0xFF
(0124)     unsigned char i;
(0125)     unsigned char j;
(0126) 
(0127) 	for( i=0; i<ucLen; i++ )
    00AD5 24AA      CLR	R10
    00AD6 C01B      RJMP	0x0AF2
(0128) 	{	
(0129) 		value_CRC = value_CRC ^((unsigned int)pInput[i]);
    00AD7 2DEA      MOV	R30,R10
    00AD8 27FF      CLR	R31
    00AD9 0FE0      ADD	R30,R16
    00ADA 1FF1      ADC	R31,R17
    00ADB 8020      LD	R2,Z
    00ADC 2433      CLR	R3
    00ADD 2542      EOR	R20,R2
    00ADE 2553      EOR	R21,R3
(0130) 		for (j = 0; j < 8; j++)
    00ADF 2766      CLR	R22
    00AE0 C00E      RJMP	0x0AEF
(0131) 		{
(0132) 			if (value_CRC & 0x0001)
    00AE1 FF40      SBRS	R20,0
    00AE2 C009      RJMP	0x0AEC
(0133) 			{
(0134) 				value_CRC = (value_CRC >> 1) ^ 0x8408;
    00AE3 E088      LDI	R24,0x8
    00AE4 E894      LDI	R25,0x84
    00AE5 011A      MOVW	R2,R20
    00AE6 9436      LSR	R3
    00AE7 9427      ROR	R2
    00AE8 2628      EOR	R2,R24
    00AE9 2639      EOR	R3,R25
    00AEA 01A1      MOVW	R20,R2
(0135) 			}
    00AEB C002      RJMP	0x0AEE
(0136) 			else
(0137) 			{
(0138) 				value_CRC = (value_CRC >> 1);
    00AEC 9556      LSR	R21
    00AED 9547      ROR	R20
    00AEE 9563      INC	R22
    00AEF 3068      CPI	R22,0x8
    00AF0 F380      BCS	0x0AE1
    00AF1 94A3      INC	R10
    00AF2 14AC      CP	R10,R12
    00AF3 F318      BCS	0x0AD7
(0139) 			}
(0140) 		}
(0141) 	}
(0142) 	
(0143)   	pCrc16[0] = (unsigned char)(value_CRC>>8);
    00AF4 011A      MOVW	R2,R20
    00AF5 2C23      MOV	R2,R3
    00AF6 2433      CLR	R3
    00AF7 01F9      MOVW	R30,R18
    00AF8 8220      ST	Z,R2
(0144) 	pCrc16[1] = (unsigned char)(value_CRC);
    00AF9 8341      STD	Z+1,R20
(0145) 	
(0146) 	return;
    00AFA 940C 0BE1 JMP	pop_xgsetF03C
_MAC_CheckCrc16:
  CrcChk               --> Y,+1
  ucLen                --> R20
  pInput               --> R10
    00AFC 940E 0BB2 CALL	push_xgset300C
    00AFE 2F42      MOV	R20,R18
    00AFF 0158      MOVW	R10,R16
    00B00 9723      SBIW	R28,3
(0147) }
(0148) 
(0149) 
(0150) /*-----------------------------------------------
(0151) 函数名：	MAC_CheckCrc16
(0152) 功  能：  校验一帧长度为ucLen的数据，pInput[ucLen]
(0153)           pInput[ucLen+1]是这帧数据的校验字节。
(0154) 参  数：  pInput      校验帧的首地址
(0155)           ucLen 　　　需校验的数据帧的长度 
(0156) 返回值：　0表示校验通过，1表示校验失败　
(0157) 作  者：　lz
(0158) 日  期：  2008-06-18
(0159) ------------------------------------------------*/
(0160) unsigned char MAC_CheckCrc16(unsigned char * pInput, unsigned char ucLen)
(0161) {
(0162) 	unsigned char CrcChk[2];
(0163) 
(0164) 	MAC_CalCrc16(pInput,CrcChk,ucLen-2);
    00B01 2F84      MOV	R24,R20
    00B02 5082      SUBI	R24,2
    00B03 8388      ST	Y,R24
    00B04 019E      MOVW	R18,R28
    00B05 5F2F      SUBI	R18,0xFF
    00B06 4F3F      SBCI	R19,0xFF
    00B07 0185      MOVW	R16,R10
    00B08 DFC7      RCALL	_MAC_CalCrc16
(0165) 
(0166) 	if (CrcChk[0]!=pInput[ucLen-2] || CrcChk[1]!=pInput[ucLen-1])
    00B09 2FE4      MOV	R30,R20
    00B0A 27FF      CLR	R31
    00B0B 9732      SBIW	R30,2
    00B0C 0DEA      ADD	R30,R10
    00B0D 1DFB      ADC	R31,R11
    00B0E 8020      LD	R2,Z
    00B0F 8039      LDD	R3,Y+1
    00B10 1432      CP	R3,R2
    00B11 F449      BNE	0x0B1B
    00B12 2FE4      MOV	R30,R20
    00B13 27FF      CLR	R31
    00B14 9731      SBIW	R30,1
    00B15 0DEA      ADD	R30,R10
    00B16 1DFB      ADC	R31,R11
    00B17 8020      LD	R2,Z
    00B18 803A      LDD	R3,Y+2
    00B19 1432      CP	R3,R2
    00B1A F011      BEQ	0x0B1D
(0167) 	{
(0168) 		return FAILURE; // crc16 fail!
    00B1B E001      LDI	R16,1
    00B1C C001      RJMP	0x0B1E
(0169) 	}
(0170) 	
(0171) 	return SUCCESS; // crc16 ok!
    00B1D 2700      CLR	R16
    00B1E 9623      ADIW	R28,3
    00B1F 940C 0BB7 JMP	pop_xgset300C
_ComSendResponse:
  crc_buf              --> Y,+1
  LenData              --> R20
  statusdata           --> R12
  CmdData              --> R10
    00B21 940E 0BCA CALL	push_xgset303C
    00B23 2EC2      MOV	R12,R18
    00B24 2EA0      MOV	R10,R16
    00B25 9723      SBIW	R28,3
    00B26 8549      LDD	R20,Y+9
(0172) }
(0173) /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
(0174) //发送命令响应结果
(0175) void ComSendResponse(unsigned char CmdData,unsigned char statusdata,unsigned char LenData)
(0176) {
(0177)     unsigned char crc_buf[2];
(0178)     
(0179)     receive_buf[5]= statusdata;
    00B27 92C0 011C STS	receive_buf+5,R12
(0180) 
(0181)     receive_buf[4]=LenData;
    00B29 9340 011B STS	receive_buf+4,R20
(0182) 
(0183)     receive_buf[3]=CmdData;
    00B2B 92A0 011A STS	receive_buf+3,R10
(0184)     
(0185)     receive_buf[1]=0x00;receive_buf[2]=0x01;
    00B2D 2422      CLR	R2
    00B2E 9220 0118 STS	receive_buf+1,R2
    00B30 E081      LDI	R24,1
    00B31 9380 0119 STS	receive_buf+2,R24
(0186) 
(0187)     receive_buf[0]=0x02;
    00B33 E082      LDI	R24,2
    00B34 9380 0117 STS	receive_buf,R24
(0188)     
(0189)     MAC_CalCrc16(receive_buf, crc_buf,LenData+5); 
    00B36 2F84      MOV	R24,R20
    00B37 5F8B      SUBI	R24,0xFB
    00B38 8388      ST	Y,R24
    00B39 019E      MOVW	R18,R28
    00B3A 5F2F      SUBI	R18,0xFF
    00B3B 4F3F      SBCI	R19,0xFF
    00B3C E107      LDI	R16,0x17
    00B3D E011      LDI	R17,1
    00B3E DF91      RCALL	_MAC_CalCrc16
(0190)     
(0191)     receive_buf[LenData+5]=crc_buf[0];
    00B3F E18C      LDI	R24,0x1C
    00B40 E091      LDI	R25,1
    00B41 2FE4      MOV	R30,R20
    00B42 27FF      CLR	R31
    00B43 0FE8      ADD	R30,R24
    00B44 1FF9      ADC	R31,R25
    00B45 8029      LDD	R2,Y+1
    00B46 8220      ST	Z,R2
(0192)     
(0193)     receive_buf[LenData+6]=crc_buf[1];//数据包尾 
    00B47 E18D      LDI	R24,0x1D
    00B48 E091      LDI	R25,1
    00B49 2FE4      MOV	R30,R20
    00B4A 27FF      CLR	R31
    00B4B 0FE8      ADD	R30,R24
    00B4C 1FF9      ADC	R31,R25
    00B4D 802A      LDD	R2,Y+2
    00B4E 8220      ST	Z,R2
(0194)     
(0195)     init_USART1(); 
    00B4F DF02      RCALL	_init_USART1
(0196)     outStrtoCom(receive_buf,LenData+7); 
    00B50 2F24      MOV	R18,R20
    00B51 2733      CLR	R19
    00B52 5F29      SUBI	R18,0xF9
    00B53 4F3F      SBCI	R19,0xFF
    00B54 E107      LDI	R16,0x17
    00B55 E011      LDI	R17,1
    00B56 DF65      RCALL	_outStrtoCom
(0197)    
(0198)     return;
    00B57 9623      ADIW	R28,3
    00B58 940C 0BD1 JMP	pop_xgset303C
_EEPROM_write:
  data                 --> R10
  addr_l               --> R14
  addr_h               --> R12
    00B5A 940E 0BAB CALL	push_xgset00FC
    00B5C 0179      MOVW	R14,R18
    00B5D 0168      MOVW	R12,R16
    00B5E 80AE      LDD	R10,Y+6
    00B5F 80BF      LDD	R11,Y+7
FILE: E:\ICCDemo\Temp_Control\temp_control\eeprom.c
(0001) #include<iom128v.h>
(0002) #include "eeprom.h"
(0003) #include "delay.h"
(0004) void EEPROM_write(uint addr_h,uint addr_l,uint data){
(0005)    SREG&=0x7F;//关中断
    00B60 B78F      IN	R24,0x3F
    00B61 778F      ANDI	R24,0x7F
    00B62 BF8F      OUT	0x3F,R24
(0006)     while(EECR & (1<<EEWE)){
    00B63 99E1      SBIC	0x1C,1
    00B64 CFFE      RJMP	0x0B63
(0007) 	 			 
(0008) 	 }
(0009) 	 EEARL=addr_l;
    00B65 BAEE      OUT	0x1E,R14
(0010) 	 EEARH=addr_h;
    00B66 BACF      OUT	0x1F,R12
(0011) 	 
(0012) 	 EEDR=data;
    00B67 BAAD      OUT	0x1D,R10
(0013) 	 EECR|=(1<<EEMWE);
    00B68 9AE2      SBI	0x1C,2
(0014) 	 EECR|=(1<<EEWE);
    00B69 9AE1      SBI	0x1C,1
(0015) 	  delay_us(1);
    00B6A E001      LDI	R16,1
    00B6B E010      LDI	R17,0
    00B6C 940E 0073 CALL	_delay_us
(0016) 	 SREG|=0x80;//开中断
    00B6E 9478      BSET	7
(0017) 	 return;
    00B6F 940C 0B8C JMP	pop_xgset00FC
_EEPROM_read:
  data                 --> R10
  addr_l               --> R12
  addr_h               --> R10
    00B71 92AA      ST	-Y,R10
    00B72 92CA      ST	-Y,R12
    00B73 0169      MOVW	R12,R18
    00B74 0158      MOVW	R10,R16
(0018) }
(0019) uchar EEPROM_read(uint addr_h,uint addr_l){
(0020)    uchar data;
(0021)    SREG&=0x7F;//关中断
    00B75 B78F      IN	R24,0x3F
    00B76 778F      ANDI	R24,0x7F
    00B77 BF8F      OUT	0x3F,R24
(0022)     while(EECR & (1<<EEWE)){ 			 
    00B78 99E1      SBIC	0x1C,1
    00B79 CFFE      RJMP	0x0B78
(0023) 	 }
(0024) 	 EEARL=addr_l;
    00B7A BACE      OUT	0x1E,R12
(0025) 	 EEARH=addr_h;
    00B7B BAAF      OUT	0x1F,R10
(0026) 	 
(0027) 	 EECR|=(1<<EERE);
    00B7C 9AE0      SBI	0x1C,0
(0028) 	 delay_us(1);
    00B7D E001      LDI	R16,1
    00B7E E010      LDI	R17,0
    00B7F 940E 0073 CALL	_delay_us
(0029) 	 data=EEDR;
    00B81 B2AD      IN	R10,0x1D
(0030) 	 SREG|=0x80;//开中断
    00B82 9478      BSET	7
(0031) 	 return data;
FILE: <library>
    00B83 2D0A      MOV	R16,R10
    00B84 90C9      LD	R12,Y+
    00B85 90A9      LD	R10,Y+
    00B86 9508      RET
push_arg4:
    00B87 933A      ST	-Y,R19
    00B88 932A      ST	-Y,R18
push_arg2:
    00B89 931A      ST	-Y,R17
    00B8A 930A      ST	-Y,R16
    00B8B 9508      RET
pop_xgset00FC:
    00B8C 90A9      LD	R10,Y+
    00B8D 90B9      LD	R11,Y+
    00B8E 90C9      LD	R12,Y+
    00B8F 90D9      LD	R13,Y+
    00B90 90E9      LD	R14,Y+
    00B91 90F9      LD	R15,Y+
    00B92 9508      RET
pop_xgset30FC:
    00B93 90A9      LD	R10,Y+
    00B94 90B9      LD	R11,Y+
    00B95 90C9      LD	R12,Y+
    00B96 90D9      LD	R13,Y+
    00B97 90E9      LD	R14,Y+
    00B98 90F9      LD	R15,Y+
    00B99 9149      LD	R20,Y+
    00B9A 9159      LD	R21,Y+
    00B9B 9508      RET
pop_xgsetF0FC:
    00B9C 90A9      LD	R10,Y+
    00B9D 90B9      LD	R11,Y+
    00B9E 90C9      LD	R12,Y+
    00B9F 90D9      LD	R13,Y+
    00BA0 90E9      LD	R14,Y+
    00BA1 90F9      LD	R15,Y+
    00BA2 9149      LD	R20,Y+
    00BA3 9159      LD	R21,Y+
    00BA4 9169      LD	R22,Y+
    00BA5 9179      LD	R23,Y+
    00BA6 9508      RET
push_xgsetF0FC:
    00BA7 937A      ST	-Y,R23
    00BA8 936A      ST	-Y,R22
push_xgset30FC:
    00BA9 935A      ST	-Y,R21
    00BAA 934A      ST	-Y,R20
push_xgset00FC:
    00BAB 92FA      ST	-Y,R15
    00BAC 92EA      ST	-Y,R14
push_xgset003C:
    00BAD 92DA      ST	-Y,R13
    00BAE 92CA      ST	-Y,R12
    00BAF 92BA      ST	-Y,R11
    00BB0 92AA      ST	-Y,R10
    00BB1 9508      RET
push_xgset300C:
    00BB2 935A      ST	-Y,R21
    00BB3 934A      ST	-Y,R20
    00BB4 92BA      ST	-Y,R11
    00BB5 92AA      ST	-Y,R10
    00BB6 9508      RET
pop_xgset300C:
    00BB7 90A9      LD	R10,Y+
    00BB8 90B9      LD	R11,Y+
    00BB9 9149      LD	R20,Y+
    00BBA 9159      LD	R21,Y+
    00BBB 9508      RET
push_xgsetF00C:
    00BBC 937A      ST	-Y,R23
    00BBD 936A      ST	-Y,R22
    00BBE 935A      ST	-Y,R21
    00BBF 934A      ST	-Y,R20
    00BC0 92BA      ST	-Y,R11
    00BC1 92AA      ST	-Y,R10
    00BC2 9508      RET
pop_xgsetF00C:
    00BC3 90A9      LD	R10,Y+
    00BC4 90B9      LD	R11,Y+
    00BC5 9149      LD	R20,Y+
    00BC6 9159      LD	R21,Y+
    00BC7 9169      LD	R22,Y+
    00BC8 9179      LD	R23,Y+
    00BC9 9508      RET
push_xgset303C:
    00BCA 935A      ST	-Y,R21
    00BCB 934A      ST	-Y,R20
    00BCC 92DA      ST	-Y,R13
    00BCD 92CA      ST	-Y,R12
    00BCE 92BA      ST	-Y,R11
    00BCF 92AA      ST	-Y,R10
    00BD0 9508      RET
pop_xgset303C:
    00BD1 90A9      LD	R10,Y+
    00BD2 90B9      LD	R11,Y+
    00BD3 90C9      LD	R12,Y+
    00BD4 90D9      LD	R13,Y+
    00BD5 9149      LD	R20,Y+
    00BD6 9159      LD	R21,Y+
    00BD7 9508      RET
push_xgsetF03C:
    00BD8 937A      ST	-Y,R23
    00BD9 936A      ST	-Y,R22
    00BDA 935A      ST	-Y,R21
    00BDB 934A      ST	-Y,R20
    00BDC 92DA      ST	-Y,R13
    00BDD 92CA      ST	-Y,R12
    00BDE 92BA      ST	-Y,R11
    00BDF 92AA      ST	-Y,R10
    00BE0 9508      RET
pop_xgsetF03C:
    00BE1 90A9      LD	R10,Y+
    00BE2 90B9      LD	R11,Y+
    00BE3 90C9      LD	R12,Y+
    00BE4 90D9      LD	R13,Y+
    00BE5 9149      LD	R20,Y+
    00BE6 9159      LD	R21,Y+
    00BE7 9169      LD	R22,Y+
    00BE8 9179      LD	R23,Y+
    00BE9 9508      RET
lsl16:
    00BEA 2322      TST	R18
    00BEB F021      BEQ	0x0BF0
    00BEC 0F00      LSL	R16
    00BED 1F11      ROL	R17
    00BEE 952A      DEC	R18
    00BEF CFFA      RJMP	lsl16
    00BF0 9508      RET
lsl8:
    00BF1 2311      TST	R17
    00BF2 F019      BEQ	0x0BF6
    00BF3 0F00      LSL	R16
    00BF4 951A      DEC	R17
    00BF5 CFFB      RJMP	lsl8
    00BF6 9508      RET
